<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Java并发相关的知识点，主要是在bilibili看的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发知识学习">
<meta property="og:url" content="http://yoursite.com/2020/03/21/Java%E5%B9%B6%E5%8F%91%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="cdx">
<meta property="og:description" content="Java并发相关的知识点，主要是在bilibili看的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="c:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581577933752.png">
<meta property="article:published_time" content="2020-03-21T03:02:10.000Z">
<meta property="article:modified_time" content="2020-03-21T05:49:57.590Z">
<meta property="article:author" content="Cao Duanxi">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://yoursite.com/2020/03/21/Java%E5%B9%B6%E5%8F%91%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java并发知识学习 | cdx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cdx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人生没有Debug!</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Aaron-cdx" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/Java%E5%B9%B6%E5%8F%91%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Cao Duanxi">
      <meta itemprop="description" content="静心，摒弃表面的浮华，多思考内在的深度!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cdx">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发知识学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-21 11:02:10 / 修改时间：13:49:57" itemprop="dateCreated datePublished" datetime="2020-03-21T11:02:10+08:00">2020-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>
            <div class="post-description">Java并发相关的知识点，主要是在bilibili看的</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1-使用线程"><a href="#1-使用线程" class="headerlink" title="1. 使用线程"></a>1. 使用线程</h2><p>使用线程的三种方法：准确来说应该是四种：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>使用线程池</li>
</ul>
<h3 id="1-1-继承类与实现接口使用线程对比"><a href="#1-1-继承类与实现接口使用线程对比" class="headerlink" title="1.1 继承类与实现接口使用线程对比"></a>1.1 继承类与实现接口使用线程对比</h3><p>实现接口会更好一些，因为java不支持多继承，但是支持多实现，继承Thread的开销过大</p>
<h2 id="2-线程机制"><a href="#2-线程机制" class="headerlink" title="2. 线程机制"></a>2. 线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>创建提交任务的Runnable任务，管理任务的异步执行，一般是使用它的子接口ExecutorService来创建线程池，无需程序员显式的管理线程的生命周期。这里的异步指代多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>常见的线程池类型有：</p>
<ul>
<li><p>CachedThreadPool：可以任务是线程池容量巨大的线程池</p>
</li>
<li><p>FixedThreadPool：创建固定大小线程个数的线程池</p>
</li>
<li><p>SingleThreadExecutor：创建容量为1个线程的线程池</p>
</li>
<li><p>ScheduledThreadPool：定时线程池</p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>说起线程池，一般的面试会问道线程池一般的类型，构建线程池的参数，以及如何自定义线程池。</p>
<ol>
<li>线程池的类型如上：一般的话还有ForkJoinPool，分支合并线程池</li>
<li>线程池的参数：由下面可以看出核心线程个数，最大线程池个数，线程存活时间，时间单位，阻塞队列。核心线程数与最大线程数的区别在于：一个是公司固定上班员工，一个是加上实习生之后的总的员工数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如何自定义线程池，使用ThreadPoolExecutor创建即可。注意通过Executors可以直接创建已有的上述几种类型的线程池！</li>
</ol>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程，守护线程是在程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，当所有非守护线程运行结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main线程属于非守护线程。创建线程可以使用<code>thread.setDaemon(true)</code>将当前线程设置为守护线程。</p>
<p>守护线程拥有结束自己生命周期的特性，而非守护线程不具备这样的特性。JVM中的垃圾回收线程就是守护线程，一旦程序结束，JVM的垃圾回收也就结束了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行守护thread中的run方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 使用setDaemon方法设置守护线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>sleep字面上理解就是睡觉的意思，在这里指代线程的休眠，线程在指定的时间内啥也不干，处于休眠状态。</p>
<p>注意sleep方法可能会抛出<code>InterruptedException</code>异常，如何有任何线程中断了当前线程的执行，抛出此异常，将会清楚当前线程的中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>字面上理解就是礼让的意思，在线程中调用此方法指代当前线程会让出自己的cpu处理器给其他线程处理，该方法只是对线程调度器的一个建议，而且只建议具有相同优先级的其他线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h2><p>线程在正常执行完毕的时候会自行结束，或在发生异常的情况下也会结束。</p>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>中断异常，通过调用Interrupted()方法来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待，就会抛出InterruptedException，从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。</p>
<p>上面意思就是只要是处于阻塞状态或者是sleep，wait，join状态的，只要调用interrupted方法，就会抛出异常！</p>
<p>如果想要中断一个线程的话，可以使用submit方法提交线程，获取一个Future对象，在Future中可以执行对线程的中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可中断系列</span></span><br><span class="line">Future&lt;?&gt; future = <span class="keyword">new</span> ExecutorService().submit(<span class="keyword">new</span> Runnable() &#123;...&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-互斥同步"><a href="#4-互斥同步" class="headerlink" title="4. 互斥同步"></a>4. 互斥同步</h2><p>一般面试的时候会先问进程与线程的区别，然后问进程的通信方式，然后问线程的通信方式。</p>
<p>而线程由于共用一个资源，之间的通信只是对于资源访问的同步机制。</p>
<h3 id="1-同步一个代码块"><a href="#1-同步一个代码块" class="headerlink" title="1. 同步一个代码块"></a>1. 同步一个代码块</h3><p>同步代码块同步的是当前的对象，如果同时有两个线程中的同一个对象想要访问这个对象的这个方法中的资源，第一个线程获取到锁之后，第二个线程只能执行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是呢，如果创建了两个不同的对象，两个对象之间是分别都有自己的资源的，此时如果调用自己当前的方法中的资源，是同步交替进行的，不需要等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"i= "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个对象和两个对象直接调用，情况是不同的！</span></span><br><span class="line">    TestSynchronized test = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    TestSynchronized test1 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            test.func();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            test1.func();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2. 同步一个方法"></a>2. 同步一个方法</h3><p>与代码块一样，作用范围都是当前对象，毕竟方法存在于对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3. 同步一个类"></a>3. 同步一个类</h3><p>作用范围：作用于整个类（执行的那个类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-同步静态方法"><a href="#4-同步静态方法" class="headerlink" title="4. 同步静态方法"></a>4. 同步静态方法</h3><p>作用范围：作用与整个类，static表示是类的一部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-ReentrantLock"><a href="#5-ReentrantLock" class="headerlink" title="5. ReentrantLock"></a>5. ReentrantLock</h3><p>ReentrantLock是java.util.concurrent并发包下的锁。此锁是基于代码实现的。使用ReentrantLock的话，lock()方法加锁，在finally语句块中一定别忘了unlock()方法的调用。ReentrantLock可以实现公平锁与非公平锁，默认实现的是非公平锁。</p>
<h3 id="6-synchronized与ReentrantLock的比较"><a href="#6-synchronized与ReentrantLock的比较" class="headerlink" title="6. synchronized与ReentrantLock的比较"></a>6. synchronized与ReentrantLock的比较</h3><ul>
<li><p><strong>两者都是可重入锁</strong>：可重入锁表示的是只要当前锁住该对象的锁是自己，自己再次访问依然能够进入，一般是锁住m1，也锁住m2，在m1中可以访问m2，也就是实现了可重入锁。每锁一次计数加1，为0时才能够释放锁。</p>
</li>
<li><p><strong>synchronized依赖于底层JVM，而ReentrantLock依赖于API</strong>：synchronized依赖于JVM实现的，ReentrantLock是通过API实现的，我们可以直接看到其源码。</p>
</li>
<li><p><strong>ReentrantLock比synchronized的功能要多</strong>：主要体现在：</p>
<ul>
<li>等待可中断：使用lock.lockInterruptibly()来实现，表示正在等待的线程可以选择放弃等待，进而处理其他事情。一般的实现是当前锁可以被获取锁，如果获取到了锁的话，返回锁，如果没有获取到锁则进入等待状态，直到获取到锁或者被其他线程打断，如果被interrupted方法打断的话，一定会抛出异常。</li>
<li>实现公平锁：在synchronized为了保证性能采用了非公平锁即抢占式的锁，但是在ReentrantLock中可以实现公平锁，公平锁就是按照先来先获取锁的准则来的，默认是非公平锁。</li>
<li>选择性通知：synchronized利用wait()和notify/notifyAll()方法相结合实现等待/通知机制。ReentrantLock中引入了Condition这一类来是实现选择性通知到某一个类。await()、singnal()</li>
</ul>
</li>
<li><p><strong>性能已不是选择的标准</strong>：synchronized性能被优化了，目前两者性能相差不大。</p>
</li>
</ul>
<p>使用ReentrantLock唯一的缺点在于需要手动释放锁，否则会导致死锁的产生，而synchronized不会有这样的问题，因为JVM会保证锁的释放。</p>
<h2 id="5-线程之间的协作"><a href="#5-线程之间的协作" class="headerlink" title="5. 线程之间的协作"></a>5. 线程之间的协作</h2><h3 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h3><p>join()方法表示在一个线程中调用另一个线程执行，当前线程会等待被join的线程处理完毕再继续执行。</p>
<h3 id="2-wait-notify-notifyAll"><a href="#2-wait-notify-notifyAll" class="headerlink" title="2. wait/notify/notifyAll"></a><span id="anchor">2</span>. wait/notify/notifyAll</h3><p>一般用于常见的生产消费模型中，wait方法表示线程暂时挂起，等待notify或者notifyAll方法的唤醒挂起的线程。</p>
<p>它们属于Object的方法，不属于线程Thread，且只能在同步方法或者同步语句块中使用，否则会抛出IllegalMonitorStateException</p>
<p>使用wait线程挂起的时候，线程会释放锁，因为如果没有释放锁的话，其他同步方法就没有机会进入到对象的同步方法或者同步代码块中去，就无法使用notify或者notifyAll来唤醒挂起的线程，造成死锁现象的产生。</p>
<p><font color="red">需要注意的是sleep方法不会释放锁，因为睡眠过后，当前线程还是要接着运行，这是它与wait方法最主要的区别。且wait方法属于Object，sleep方法属于Thread</font></p>
<h3 id="3-await-signal-signalAll"><a href="#3-await-signal-signalAll" class="headerlink" title="3. await/signal/signalAll"></a>3. await/signal/signalAll</h3><p>这三个方法主要是JUC中的Condition类中实现线程之间协调的方法，可以在Condition上调用await()方法使线程等待，其他线程调用signal/signalAll方法唤醒等待的线程。</p>
<p>相比<a href="#anchor">2</a>中的方法await方法可以指定条件，更加灵活。</p>
<h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6. 线程的状态"></a>6. 线程的状态</h2><p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="1-NEW-新建"><a href="#1-NEW-新建" class="headerlink" title="1. NEW-新建"></a>1. NEW-新建</h3><p>一个线程被new出来就进入了NEW状态，表示创建后未启动</p>
<h3 id="2-RUNNABLE-可运行"><a href="#2-RUNNABLE-可运行" class="headerlink" title="2. RUNNABLE-可运行"></a>2. RUNNABLE-可运行</h3><p>表示当前线程具备运行的资质，但是具体什么时候运行，这个属于操作系统底层的调度一块的内容。</p>
<h3 id="3-BLOCKED-阻塞状态"><a href="#3-BLOCKED-阻塞状态" class="headerlink" title="3. BLOCKED-阻塞状态"></a>3. BLOCKED-阻塞状态</h3><p>请求获取monitor lock从而进入synchronized函数或者代码块的时候，此时如果其他线程占用了该monitor lock，当前线程处于阻塞状态。当其他线程释放锁时候，当前线程获得锁之后进入RUNNABLE状态，等待被调度。</p>
<h3 id="4-WAITING-无限期等待"><a href="#4-WAITING-无限期等待" class="headerlink" title="4. WAITING-无限期等待"></a>4. WAITING-无限期等待</h3><p>等待其他线程显式唤醒。一般是object.wait()方法对应object.notify()/object.notifyAll()方法。Thread.join()方法，结束的话只需要等待结束即可。最后一个不常见：LockSupport.park()等待LockSupport.unpark(Thread)。</p>
<p>3中的阻塞和当前的等待之间的区别在于，阻塞是被动的，等待获取monitor lock（被动的原因是因为其他线程已经获取到了monitor lock，自己没有办法，只能等，造成被动现象的产生）。而等待是主动的，join()等方法都是自己显式的在代码中写入的，是主动的。</p>
<h3 id="5-TIMED-WAITING-限期等待"><a href="#5-TIMED-WAITING-限期等待" class="headerlink" title="5. TIMED_WAITING-限期等待"></a>5. TIMED_WAITING-限期等待</h3><p>此种等待不需要其他方法的唤醒，而是到了一定的时间会被系统自动唤醒。</p>
<p>sleep(time)，Object.wait(time)，join(time)，LockSupport.parkNanos()/LockSupport.parkUntil，注意即使设置了时间，依旧可以利用相关的通知机制唤醒。</p>
<p><font color="red">sleep表示线程睡眠，wait表示线程挂起，两者表示行为，而阻塞表示一种状态。</font></p>
<h3 id="6-Terminated-死亡"><a href="#6-Terminated-死亡" class="headerlink" title="6. Terminated_死亡"></a>6. Terminated_死亡</h3><p>线程正常执行完毕结束，或者执行中遇到异常而提前结束。</p>
<h2 id="7-JUC-AQS"><a href="#7-JUC-AQS" class="headerlink" title="7. JUC-AQS"></a>7. JUC-AQS</h2><p>JUC是java中的并发包，AQS是JUC中的核心。</p>
<h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>表示门闩的意思，用来控制一个或者多个线程等待多个线程执行的过程。count.countDown方法是给门闩个数减一，到了0的时候，调用了await()方法会运行下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待门闩开放</span></span><br><span class="line">            count.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m1 method execute!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.getCount() != <span class="number">0</span>) &#123; <span class="comment">// 门闩未到0，上面继续阻塞，执行当前程序</span></span><br><span class="line">                System.out.println(<span class="string">"latch count:"</span> + count.getCount());</span><br><span class="line">                count.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"m2 method execute, i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCountDownLatch testCountDownLatch = <span class="keyword">new</span> TestCountDownLatch();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                testCountDownLatch.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                testCountDownLatch.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>latch count:5<br>m2 method execute, i = 0<br>latch count:4<br>m2 method execute, i = 1<br>latch count:3<br>m2 method execute, i = 2<br>latch count:2<br>m2 method execute, i = 3<br>latch count:1<br>m1 method execute!</p>
</blockquote>
<h3 id="2-CycliBarrier"><a href="#2-CycliBarrier" class="headerlink" title="2. CycliBarrier"></a>2. CycliBarrier</h3><p>听名字表示栅栏的意思，用来控制多个线程之间互相等待执行，多个线程到达时才会执行。</p>
<p>线程之间需要相互等待，也是通过计数器实现的，await每调用一次则数量减一，到0才会执行后面的逻辑。</p>
<p>CycliBarrier中实现循环屏障使用的是reset方法，可以重新设置初始化此时次数。</p>
<p>第一种构造方法，第一个参数表示线程个数，第二个参数表示每次到达数量的线程，会调用执行一次。类似于回调的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the first constructor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the second</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        Runnable worker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(<span class="string">"first arravial Thread is arrived:"</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"worker is done"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread of Worker is "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfoThreadWhenDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 回调</span></span><br><span class="line">                System.out.println(<span class="string">"[directory] Thread in invert call function is "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        process(barrier);</span><br><span class="line">        System.out.println(<span class="string">"[directory] the main Thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCyclicBarrier barrier = <span class="keyword">new</span> TestCyclicBarrier();</span><br><span class="line">        barrier.showInfoThreadWhenDirectory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore与线程之间的同步机制比较相似，可以控制对互斥资源的线程访问个数。</p>
<p>一旦semaphore的acquire许可证不可用，则阻塞等待可用。release释放许可证，使其回到信号量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphorePratice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 抢到了车位~"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 等待了3s后离开！"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-JUC其余组件"><a href="#8-JUC其余组件" class="headerlink" title="8. JUC其余组件"></a>8. JUC其余组件</h2><h3 id="1-FutureTask"><a href="#1-FutureTask" class="headerlink" title="1. FutureTask"></a>1. FutureTask</h3><p>一般用于异步计算，如果计算一个很复杂的任务，可以使用FutureTask将其分为结果任务执行，主线程完成任务之后再去获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFutureTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 要求有返回值，所以使用Callable</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    res += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread is running~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 为了确保上面线程运行完，所以睡眠2s</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BlockingQueue"><a href="#2-BlockingQueue" class="headerlink" title="2. BlockingQueue"></a>2. BlockingQueue</h3><p>阻塞队列在java多线程下用的很多。阻塞队列接口的实现主要有（用的比较多的）：</p>
<ul>
<li>FIFO队列：LinkedBlockingQueue，ArrayBlockingQueue</li>
<li>优先级队列： PriorityBlockingQueue</li>
</ul>
<p>可以使用阻塞队列实现生产者消费者模型，而且在消息队列中间件底层的实现都是阻塞队列。</p>
<p><a href="https://blog.csdn.net/cao1315020626/article/details/104295409" target="_blank" rel="noopener">生产者消费者模型的三种实现</a></p>
<p>BlockingQueue有三种常用的组合</p>
<blockquote>
<ul>
<li>第一种组合：add+remove+element<ul>
<li>add如果满了还继续添加的话会抛出异常IllegalStateException</li>
<li>remove如果空了还继续删除抛出异常NoSuchElementException</li>
<li>element是获取队列中的元素，如果为空抛出异常NoSuchElementException</li>
<li><p></li>
<li>第二种组合：offer+poll+peek</li>
<li>offer如果满了继续添加，返回false</li>
<li>poll如果空了继续删除，返回null</li>
<li>peek方法获取队列中的元素，为空的话返回null</li>
<li><p></li>
<li>第三种组合：put+take</li>
<li>这种是阻塞模式，如果put中的元素满了，就一直阻塞等待消费，直到take消费才释放队列</li>
<li>如果put为空，此时调用take方法，take方法会一直阻塞直到put放入元素队列可用为止</li>
<li><p></li>
<li>第四种组合：offer(time,unit)/poll(time,unit)</li>
<li>允许等待一段时间，看是否能获取到插入元素的空间，或者等到空间有元素 再执行获取元素</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-ForkJoin"><a href="#3-ForkJoin" class="headerlink" title="3. ForkJoin"></a>3. ForkJoin</h3><p>类似于MapReduce分片的思想，将大的数据分成若干个小块去并行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_07ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块-放入随机数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            numbers[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin, end;</span><br><span class="line">        <span class="comment">// 重写计算方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 进入计算</span></span><br><span class="line">            <span class="keyword">if</span> ((end - begin) &lt; MAX_SIZE) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则二分</span></span><br><span class="line">                <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">                AddTask task1 = <span class="keyword">new</span> AddTask(begin, mid);</span><br><span class="line">                AddTask task2 = <span class="keyword">new</span> AddTask(mid, end);</span><br><span class="line">                task1.fork();</span><br><span class="line">                task2.fork();</span><br><span class="line">                <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, numbers.length);</span><br><span class="line">        Long aLong = pool.submit(task).get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool是通过窃取算法来实现的，每个线程都维护了一个双端序列，用来存储需要执行的任务，工作窃取算法允许空闲的线程从其他线程的双端队列中窃取一个任务来执行，窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<h2 id="9-线程安全"><a href="#9-线程安全" class="headerlink" title="9. 线程安全"></a>9. 线程安全</h2><p>一般在多线程环境下对于一个变量在多个线程中操作的时候，此时的结果会出现丢失的情况。这就造成了线程不安全的情况发生。</p>
<p>会发生这样的问题主要是与java的内存模型有关，java的内存模型有工作内存和主内存，每次线程访问java内存的时候，会将这个变量的一份复制到自己的工作内存中，计算完之后，将自己的结果更新，然后更新到主内存中去。但是多个线程处理情况下，A线程更新主内存之后，B线程还是按照自己工作内存中的值去计算的话，就会造成数据的丢失。</p>
<p>下面这种请款就会造成数据的丢失。要想保证线程安全，就需要让a具有可见性，可以使用volatile关键字修饰a，以此保证，每个线程在使用这个变量的时候都需要从主内存中取出，以此保证线程的安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadUnSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            a += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadUnSafe test = <span class="keyword">new</span> TestThreadUnSafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                test.compute();</span><br><span class="line">            &#125;, <span class="string">"i"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止速度太快</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">"a的真实最终结果:"</span> + <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"a的计算最终结果:"</span> + test.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-主内存和工作内存"><a href="#1-主内存和工作内存" class="headerlink" title="1. 主内存和工作内存"></a>1. 主内存和工作内存</h3><p>主内存和工作内存图如下，以及线程与工作内存之间的交互如下。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581577933752.png" alt="1581577933752"></p>
<h3 id="2-内存模型的三大特性"><a href="#2-内存模型的三大特性" class="headerlink" title="2. 内存模型的三大特性"></a>2. 内存模型的三大特性</h3><ul>
<li>原子性<ul>
<li>原子性的实现可以使用AtomicInteger等原子类来实现原子操作</li>
</ul>
</li>
<li>可见性<ul>
<li>主要使用volatile和synchronized来实现，或者使用final关键字修饰。</li>
</ul>
</li>
<li>有序性<ul>
<li>有序性指代的是：在本线程内观察所有的操作都是有序的，但是在另外一个线程观察一个线程，所有的操作都是无序的，无序是因为发生了指令重排。在java内存模型中，允许编译器和处理器对指令进行重排优化执行，重排序对于单线程来说没有问题，但是在多线程的环境下会发生错误。</li>
<li>可以使用volatile关键字通过添加内存屏障实现禁止指令重排。</li>
<li>synchronized关键字也可以实现有序性，它保证每个时刻只有一个线程在执行同步代码，相当于让线程顺序执行同步代码。</li>
</ul>
</li>
</ul>
<h3 id="3-synchronized与volatile的区别"><a href="#3-synchronized与volatile的区别" class="headerlink" title="3. synchronized与volatile的区别"></a>3. synchronized与volatile的区别</h3><p><strong>面试的时候，有些面试官会问synchronized与volatile的区别</strong>：</p>
<ul>
<li>volatile关键字是是线程同步的轻量实现，volatile的性能比synchronized好，但是volatile关键字只能作用于变量，synchronized关键字可以作用与代码块以及方法，实际开发synchronized关键字使用的更多一点。</li>
<li>多线程访问volatile关键字不会发生阻塞，而访问synchronized关键字可能会发生阻塞</li>
<li>volatile关键字只能保证数据的可见性，不能保证数据的原子性。 而synchronizd关键字全都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性</li>
</ul>
<h2 id="10-线程安全的实现方式"><a href="#10-线程安全的实现方式" class="headerlink" title="10. 线程安全的实现方式"></a>10. 线程安全的实现方式</h2><h3 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h3><p>不可变的对象一定是线程安全的，不需要采取任何的线程安全措施保证安全。多线程环境下应该尽可能保证对象为不可变对象，使得线程保持安全。</p>
<p>不可变的数据类型：</p>
<ul>
<li>final关键字修饰的基本数据类型</li>
<li>String（底层是不可变的数组实现的）修饰符为final</li>
<li>枚举类型（一旦定义就不会改变了）</li>
<li>Number部分子类。基本数据的包装类型或者BigDecimal的大数据包装类型。但是AtomicInteger等原子类是可变的。</li>
<li>集合类可以通过Collections总的相关创建不可变对象的方法创建不可变对象</li>
</ul>
<h3 id="2-互斥同步"><a href="#2-互斥同步" class="headerlink" title="2. 互斥同步"></a>2. 互斥同步</h3><p>synchronized和ReentrantLock</p>
<h3 id="3-非阻塞同步"><a href="#3-非阻塞同步" class="headerlink" title="3. 非阻塞同步"></a>3. 非阻塞同步</h3><p>互斥同步主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略（这里悲观类似于乐观锁与悲观锁，悲观锁就是特别悲观，害怕别人在自己做事的时候影响自己，所以总是加锁。而乐观锁是每次做事的时候相信别人不会影响自己，虽然自己做完事之后还是会去确认一下。）</p>
<p>随着硬件指令集的发展，可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程争用共享数据，操作就成功了。否则就需要采取补偿措施。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步被称为非阻塞同步。</p>
<h4 id="①-CAS"><a href="#①-CAS" class="headerlink" title="① CAS"></a>① CAS</h4><p>CAS称为CompareAndSwap比较并交换，需要提供3个参数，分别是内存地址V，旧的预期值A和新值B，只有V=A的时候，才能够将V的值更新为B，底层是Unsafe根据相应地偏移量来判断并实现的。</p>
<h4 id="②-Atmoic相关原子操作类"><a href="#②-Atmoic相关原子操作类" class="headerlink" title="② Atmoic相关原子操作类"></a>② Atmoic相关原子操作类</h4><p>AtomicInteger等底层都是调用了Unsafe的CAS实现的原子操作。一旦发生冲突就不断地进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出一旦发生比较交换失败，会一直进行重试，直到成功返回值。</p>
<h4 id="③-ABA问题"><a href="#③-ABA问题" class="headerlink" title="③ ABA问题"></a>③ ABA问题</h4><p>ABA问题的产生是由于CAS引起的，这也是CAS中存在的问题。为什么这么说呢？我们来看看A B两个线程同时操作一个变量C=3. A来操作的时候将其改成了5，然后想想不对劲又改成了3，此时B如果来操作，它会发现这压根没人动过，但实际上值被改过。就产生了俗称的“ABA”问题</p>
<p>JUC中有一个AtmoicStampedReference类可以给对象值加个类似邮戳的记录，一旦被修改，邮戳+1，这样可以保证ABA问题如果发生，邮戳对不上的话也是更新失败。</p>
<p>下面的例子运行下就会明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;Integer&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========ABA问题的产生======"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            reference.compareAndSet(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">            reference.compareAndSet(<span class="number">100</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t修改成功否："</span> + reference.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">",最终值为："</span> + reference.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">        System.out.println(<span class="string">"============ABA问题的解决================="</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始的版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference() + <span class="string">"\t当前版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line">            stamp = atomicStampedReference.getStamp();</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference() + <span class="string">"\t当前版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; </span><br><span class="line">            <span class="comment">// 被t3线程修改的，是不能够在这里获取到，所以false</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t成功否："</span> + atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>) + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"t4"</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-线程本地存储-ThreadLocal-Storage"><a href="#4-线程本地存储-ThreadLocal-Storage" class="headerlink" title="4. 线程本地存储(ThreadLocal Storage)"></a>4. 线程本地存储(ThreadLocal Storage)</h3><p>ThreadLocal给线程提供局部变量用的，下面代码可以看见t2线程对t1线程的threadLocal变量没有任何影响。提供变量副本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+threadLocal.get()); <span class="comment">// t1 1</span></span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+threadLocal.get());<span class="comment">// t2 2</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set()</code>方法，获取到当前线程，如果不为null的话设置值，否则自己构建一个存入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get()</code>方法，获取到当前线程，获取到Map看看是否有值，有值就取出。否则返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal从理论上来说并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景下（尤其是使用线程池）的情况下，由于ThreadLocal.ThreadLocalMap的底层数据结构导致ThreadLocal有内存泄露的风险，应该尽可能的在使用完ThreadLocal后调用remove方法。以避免出现ThreadLocal经典的内存泄露甚至是造成自身业务混乱的情况。</p>
<p>造成内存泄露的原因是因为ThreadLocalMap结构的问题，如果键被回收了key=null，那么值value并非弱引用，没有被回收，如果线程也没有被回收，也即线程没有销毁，那么value就永远不会被回收，当产生大量value的时候，此时就会造成内存泄露。</p>
<p>（JDK1.8之后不会有这种情况了，在set的时候如果发现线程没有被回收，此时存在key=null，value!=null）的情况，直接将key=null的进行替换即可避免内存泄露问题的产生。（具体看源码！）</p>
<h2 id="11-锁优化"><a href="#11-锁优化" class="headerlink" title="11. 锁优化"></a>11. 锁优化</h2><p>锁优化策略指的是JVM层面对synchronized的优化</p>
<h3 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h3><p>互斥同步进入阻塞的开销都很大，应该尽量避免频繁进入阻塞发生。在许多情况下，共享数据的锁定只会持续一会儿。自旋的思想是让获取不到锁的线程执行循环（自旋）一段时间，如果能够获取到锁，就不用进入到阻塞状态。</p>
<p>自旋锁虽然能够避免进入阻塞状态从而减少开销，但是需要进行空循环操作占用CPU时间，它只适用于共享数据锁定时间短的场景。</p>
<p>自适应自旋锁表示次数不再是固定的，而是由前一次在同一个锁上的自旋次数以及锁的拥有者的状态来决定。</p>
<h3 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争分析的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其他线程访问到，那么就把他们当做私有数据对待，即可将他们的锁进行消除。</p>
<p>StringBuffer就是利用synchronized关键字对操作加锁的，当前如果没有锁消除的话，会执行三次加锁三次释放锁，但是现在有了锁消除，只需要一次加锁即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上段代码也可以用与展示锁粗化，三次加锁的对象都是sb，可以直接简化为一次。即将加锁的范围放大。</p>
<h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h3><p>JDK1.6引入了偏向锁和轻量级锁，从而让锁拥有四个状态：无锁状态unlocked、偏向锁biasable、轻量级锁light weighted locked和重量级锁locked</p>
<p>轻量级锁是相对于重量级锁而言的，它使用CAS 操作来避免重量级锁使用互斥量的开销，对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都是用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败再采用互斥量进行同步。</p>
<p>[轻量级锁具体的实现]([<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81]" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81]</a>(<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 并发?id=轻量级锁))</p>
<p>如果CAS操作失败，虚拟机会先检查对象的Mark Word（标记锁对象的锁的状态）是否指向当前线程的虚拟机，如果是的话，表明当前线程已经拥有了这个锁对象，可以直接进入同步代码块继续执行。否则说明这个锁对象被其他线程抢占了。如果两个线程同时抢占一把锁，轻量级锁不再有效，需要膨胀为重量级锁。</p>
<h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程在之后获取到该锁的时候不再需要进行同步操作，甚至连CAS也不需要。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<h2 id="12-多线程开发良好实践"><a href="#12-多线程开发良好实践" class="headerlink" title="12. 多线程开发良好实践"></a>12. 多线程开发良好实践</h2><ol>
<li>给线程起个有意义的名字，方便找bug</li>
<li>缩小同步范围，从而减少锁争用。synchronized应尽可能使用同步块，而不是同步方法</li>
<li>多用同步工具，少用wait/notify/notifyAll这些方法，多用CountDownLatch，CycliBarrier,Semaphore这些同步类。</li>
<li>使用BlockingQueue实现生产者消费者问题</li>
<li>多用并发集合，少用同步集合，例如ConcurrentHashMap而不是HashTable</li>
<li>使用本地变量和不可变类来保证线程安全</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效的利用有限的线程来处理任务。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/21/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" rel="prev" title="面试准备知识">
      <i class="fa fa-chevron-left"></i> 面试准备知识
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/21/Leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/" rel="next" title="Leetcode之数组">
      Leetcode之数组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NTExNi8yMTYzMw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发"><span class="nav-number">1.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-使用线程"><span class="nav-number">1.1.</span> <span class="nav-text">1. 使用线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-继承类与实现接口使用线程对比"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 继承类与实现接口使用线程对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-线程机制"><span class="nav-number">1.2.</span> <span class="nav-text">2. 线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">1.2.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.2.2.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Daemon"><span class="nav-number">1.2.3.</span> <span class="nav-text">Daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">1.2.4.</span> <span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-number">1.2.5.</span> <span class="nav-text">yield()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-中断"><span class="nav-number">1.3.</span> <span class="nav-text">3. 中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptedException"><span class="nav-number">1.3.1.</span> <span class="nav-text">InterruptedException</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-互斥同步"><span class="nav-number">1.4.</span> <span class="nav-text">4. 互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-同步一个代码块"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 同步一个代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-同步一个方法"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 同步一个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-同步一个类"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 同步一个类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-同步静态方法"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 同步静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ReentrantLock"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-synchronized与ReentrantLock的比较"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. synchronized与ReentrantLock的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-线程之间的协作"><span class="nav-number">1.5.</span> <span class="nav-text">5. 线程之间的协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-join"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-wait-notify-notifyAll"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. wait&#x2F;notify&#x2F;notifyAll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-await-signal-signalAll"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. await&#x2F;signal&#x2F;signalAll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-线程的状态"><span class="nav-number">1.6.</span> <span class="nav-text">6. 线程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-NEW-新建"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. NEW-新建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-RUNNABLE-可运行"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. RUNNABLE-可运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-BLOCKED-阻塞状态"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. BLOCKED-阻塞状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-WAITING-无限期等待"><span class="nav-number">1.6.4.</span> <span class="nav-text">4. WAITING-无限期等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-TIMED-WAITING-限期等待"><span class="nav-number">1.6.5.</span> <span class="nav-text">5. TIMED_WAITING-限期等待</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Terminated-死亡"><span class="nav-number">1.6.6.</span> <span class="nav-text">6. Terminated_死亡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-JUC-AQS"><span class="nav-number">1.7.</span> <span class="nav-text">7. JUC-AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CountDownLatch"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-CycliBarrier"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. CycliBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Semaphore"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. Semaphore</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-JUC其余组件"><span class="nav-number">1.8.</span> <span class="nav-text">8. JUC其余组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-FutureTask"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-BlockingQueue"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. BlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ForkJoin"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. ForkJoin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-线程安全"><span class="nav-number">1.9.</span> <span class="nav-text">9. 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-主内存和工作内存"><span class="nav-number">1.9.1.</span> <span class="nav-text">1. 主内存和工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内存模型的三大特性"><span class="nav-number">1.9.2.</span> <span class="nav-text">2. 内存模型的三大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-synchronized与volatile的区别"><span class="nav-number">1.9.3.</span> <span class="nav-text">3. synchronized与volatile的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-线程安全的实现方式"><span class="nav-number">1.10.</span> <span class="nav-text">10. 线程安全的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-不可变"><span class="nav-number">1.10.1.</span> <span class="nav-text">1. 不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-互斥同步"><span class="nav-number">1.10.2.</span> <span class="nav-text">2. 互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-非阻塞同步"><span class="nav-number">1.10.3.</span> <span class="nav-text">3. 非阻塞同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#①-CAS"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">① CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#②-Atmoic相关原子操作类"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">② Atmoic相关原子操作类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#③-ABA问题"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">③ ABA问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-线程本地存储-ThreadLocal-Storage"><span class="nav-number">1.10.4.</span> <span class="nav-text">4. 线程本地存储(ThreadLocal Storage)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-锁优化"><span class="nav-number">1.11.</span> <span class="nav-text">11. 锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-自旋锁"><span class="nav-number">1.11.1.</span> <span class="nav-text">1. 自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-锁消除"><span class="nav-number">1.11.2.</span> <span class="nav-text">2. 锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-锁粗化"><span class="nav-number">1.11.3.</span> <span class="nav-text">3. 锁粗化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-轻量级锁"><span class="nav-number">1.11.4.</span> <span class="nav-text">4. 轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-偏向锁"><span class="nav-number">1.11.5.</span> <span class="nav-text">5. 偏向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-多线程开发良好实践"><span class="nav-number">1.12.</span> <span class="nav-text">12. 多线程开发良好实践</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cao Duanxi"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Cao Duanxi</p>
  <div class="site-description" itemprop="description">静心，摒弃表面的浮华，多思考内在的深度!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aaron-cdx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aaron-cdx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cao1315020626" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;cao1315020626" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cao Duanxi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">127k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
