<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="算法视频学习二分法学习Binary Search数组Leetcode 283 Move Zeros 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode） 链接：https:&#x2F;&#x2F;le">
<meta property="og:type" content="article">
<meta property="og:title" content="算法视频学习">
<meta property="og:url" content="http://yoursite.com/2020/06/01/%E7%AE%97%E6%B3%95%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="cdx">
<meta property="og:description" content="算法视频学习二分法学习Binary Search数组Leetcode 283 Move Zeros 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode） 链接：https:&#x2F;&#x2F;le">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg">
<meta property="article:published_time" content="2020-06-01T14:59:11.676Z">
<meta property="article:modified_time" content="2020-06-11T14:51:50.131Z">
<meta property="article:author" content="Cao Duanxi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg">

<link rel="canonical" href="http://yoursite.com/2020/06/01/%E7%AE%97%E6%B3%95%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>算法视频学习 | cdx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cdx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人生没有Debug!</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Aaron-cdx" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E7%AE%97%E6%B3%95%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Cao Duanxi">
      <meta itemprop="description" content="静心，摒弃表面的浮华，多思考内在的深度!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cdx">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法视频学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 22:59:11" itemprop="dateCreated datePublished" datetime="2020-06-01T22:59:11+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-11 22:51:50" itemprop="dateModified" datetime="2020-06-11T22:51:50+08:00">2020-06-11</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>74k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:07</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="算法视频学习"><a href="#算法视频学习" class="headerlink" title="算法视频学习"></a>算法视频学习</h2><h3 id="二分法学习"><a href="#二分法学习" class="headerlink" title="二分法学习"></a>二分法学习</h3><h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="Leetcode-283-Move-Zeros"><a href="#Leetcode-283-Move-Zeros" class="headerlink" title="Leetcode 283 Move Zeros"></a>Leetcode 283 Move Zeros</h4><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br> 输出: [1,3,12,0,0]<br> 说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br> 尽量减少操作次数。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>使用双指针，当遇到0的时候就交换，此时k一定是在非0的元素上面，一直向后遍历，直到结束</p>
<p>时间复杂度：O(n)    空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">  if (nums &#x3D;&#x3D; null) return;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    if (nums[i] !&#x3D; 0) &#123;</span><br><span class="line">      swap(nums,i,k);</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] nums, int a, int b) &#123;</span><br><span class="line">  int temp &#x3D; nums[a];</span><br><span class="line">  nums[a] &#x3D; nums[b];</span><br><span class="line">  nums[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-27-Remove-Element"><a href="#Leetcode-27-Remove-Element" class="headerlink" title="Leetcode 27 Remove Element"></a>Leetcode 27 Remove Element</h4><h4 id="Leetcode-26-Remove-Duplicated-from-Sorted-Array"><a href="#Leetcode-26-Remove-Duplicated-from-Sorted-Array" class="headerlink" title="Leetcode 26 Remove Duplicated from Sorted Array"></a>Leetcode 26 Remove Duplicated from Sorted Array</h4><h4 id="Leetcode-80-Remove-Duplicated-frim-Sorted-Array-II"><a href="#Leetcode-80-Remove-Duplicated-frim-Sorted-Array-II" class="headerlink" title="Leetcode 80 Remove Duplicated frim Sorted Array II"></a>Leetcode 80 Remove Duplicated frim Sorted Array II</h4><h4 id="Leetcode-75-Sort-Colors"><a href="#Leetcode-75-Sort-Colors" class="headerlink" title="Leetcode 75 Sort Colors"></a>Leetcode 75 Sort Colors</h4><h4 id="Leetcode-88-Merge-Sorted-Array"><a href="#Leetcode-88-Merge-Sorted-Array" class="headerlink" title="Leetcode 88 Merge Sorted Array"></a>Leetcode 88 Merge Sorted Array</h4><h4 id="Leetcode-215-Kth-Largest-Element-in-an-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="Leetcode 215 Kth Largest Element in an Array"></a>Leetcode 215 Kth Largest Element in an Array</h4><h3 id="双索引技术-对撞指针"><a href="#双索引技术-对撞指针" class="headerlink" title="双索引技术-对撞指针"></a><strong>双索引技术-对撞指针</strong></h3><h4 id="Leetcode-167-Two-Sum-II-Input-array-is-Sorted"><a href="#Leetcode-167-Two-Sum-II-Input-array-is-Sorted" class="headerlink" title="Leetcode 167 Two Sum II - Input array is Sorted"></a>Leetcode 167 Two Sum II - Input array is Sorted</h4><blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br> 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例:</p>
<p>输入: numbers = [2, 7, 11, 15], target = 9<br> 输出: [1,2]<br> 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>双指针技术，利用头尾两个指针向中间夹逼。值等于就停止。取出下标即可，注意题目是有序。</p>
<p>时间复杂度：O(n)  空间复杂度：O(1)</p>
</blockquote>
<h4 id="Leetcode-125-Valid-Palindrome"><a href="#Leetcode-125-Valid-Palindrome" class="headerlink" title="Leetcode 125 Valid Palindrome"></a>Leetcode 125 Valid Palindrome</h4><blockquote>
<p>前后双指针夹逼，遇到非字母直接跳过。</p>
</blockquote>
<h4 id="Leetcode-344-Reverse-String"><a href="#Leetcode-344-Reverse-String" class="headerlink" title="Leetcode 344 Reverse String"></a>Leetcode 344 Reverse String</h4><blockquote>
<p>前后双指针，交换即可</p>
</blockquote>
<h4 id="Leetcode-345-Reverse-Vowels-of-a-String"><a href="#Leetcode-345-Reverse-Vowels-of-a-String" class="headerlink" title="Leetcode 345 Reverse Vowels of a String"></a>Leetcode 345 Reverse Vowels of a String</h4><blockquote>
<p>前后双指针，两者都遇到元音字母才交换</p>
</blockquote>
<h4 id="Leetcode-11-Container-With-Most-Water"><a href="#Leetcode-11-Container-With-Most-Water" class="headerlink" title="Leetcode 11 Container With Most Water"></a>Leetcode 11 Container With Most Water</h4><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<blockquote>
<p>双指针前后，小的前面才可能遇到更大的。所以移动小的一端，向中间夹逼即可。</p>
</blockquote>
<h3 id="双索引技术-滑动窗口"><a href="#双索引技术-滑动窗口" class="headerlink" title="双索引技术-滑动窗口"></a>双索引技术-滑动窗口</h3><h4 id="Leetcode-209-Minimum-Size-Subarray-Sum"><a href="#Leetcode-209-Minimum-Size-Subarray-Sum" class="headerlink" title="Leetcode 209 Minimum Size Subarray Sum"></a>Leetcode 209 Minimum Size Subarray Sum</h4><blockquote>
<p>长度最小的子数组</p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例:</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br> 输出: 2<br> 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br> 进阶:</p>
<p>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先滑动窗口，需要保持窗口前侧不越界，其次保持窗口后侧的跟随移动即可。</p>
<p>时间复杂度：O(n)  空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">  if (nums.length &lt; 1) return 0;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  int j &#x3D; -1;</span><br><span class="line">  int res &#x3D; 0;</span><br><span class="line">  int len &#x3D; nums.length + 1;</span><br><span class="line">  &#x2F;&#x2F; 滑动窗口的终止条件</span><br><span class="line">  while (i &lt; nums.length) &#123;</span><br><span class="line">    if (res &lt; s) &#123;</span><br><span class="line">      &#x2F;&#x2F; 需要确保j+1不能越界</span><br><span class="line">      if(j+1 &gt;&#x3D; nums.length) break;</span><br><span class="line">      res +&#x3D; nums[++j];</span><br><span class="line">    &#125; else if (res &gt;&#x3D; s) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果大于等于，此时计算长度，i向前进</span><br><span class="line">      len &#x3D; Math.min(len, j - i + 1);</span><br><span class="line">      res -&#x3D; nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len &#x3D;&#x3D; nums.length+1 ? 0 : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-3-Longest-Substring-Without-Repeating-Characters"><a href="#Leetcode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Leetcode 3 Longest Substring Without Repeating Characters"></a>Leetcode 3 Longest Substring Without Repeating Characters</h4><blockquote>
<p>双指针，可以利用一个数据存储，遇到重复的则将窗口向前移动即可。每次不重复的话则计算长度即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">  int l &#x3D; 0;</span><br><span class="line">  int r &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 要应对全部的字符</span><br><span class="line">  int[] nums &#x3D; new int[256];</span><br><span class="line">  int res &#x3D; Integer.MIN_VALUE;</span><br><span class="line">  while (r &lt; s.length()) &#123;</span><br><span class="line">    char c &#x3D; s.charAt(r);</span><br><span class="line">    &#x2F;&#x2F; 表示不重复，继续向前</span><br><span class="line">    if (nums[c] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      nums[c]++;</span><br><span class="line">      r++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 此时遇到重复，取长度，然后窗口向前移动，当前字符--</span><br><span class="line">      res &#x3D; Math.max(r - l, res);</span><br><span class="line">      nums[s.charAt(l++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(r - l, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-438-Find-All-Anagrams-in-a-String"><a href="#Leetcode-438-Find-All-Anagrams-in-a-String" class="headerlink" title="Leetcode 438 Find All Anagrams in a String"></a>Leetcode 438 Find All Anagrams in a String</h4><blockquote>
<p>找到字符串中的所有字母异位词</p>
<p>思路：按照双指针，数组，使用数组的性质来删除不符合条件的，从左到右，左边的不符合需要删除，右边一直前进，直到到达终点位置为止。</p>
<p>如果是找对应的字符或者是字符串，一定要知道，有进有出才是可以保证整个窗口持续前进的基础，否则一切都白搭，不会得到结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (p.length() &lt; 1) return res;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        int[] nums &#x3D; new int[26];</span><br><span class="line">        int[] nump &#x3D; new int[26];</span><br><span class="line">        for (int l &#x3D; 0; l &lt; p.length(); l++) &#123;</span><br><span class="line">            nums[p.charAt(l) - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; s.length()) &#123;</span><br><span class="line">            int temp &#x3D; s.charAt(j) - &#39;a&#39;;</span><br><span class="line">            nump[temp]++;</span><br><span class="line">            &#x2F;&#x2F; 如果有相同的</span><br><span class="line">            while (nump[temp] &gt; nums[temp]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 算出左边当前的，移除左边的</span><br><span class="line">                int cnt &#x3D; s.charAt(i) - &#39;a&#39;;</span><br><span class="line">                i++;&#x2F;&#x2F; 左边前进</span><br><span class="line">                nump[cnt]--;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((j - i + 1) &#x3D;&#x3D; p.length()) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76 Minimum Window Substring"></a>Leetcode 76 Minimum Window Substring</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 最小覆盖字串问题</span><br><span class="line"> *&#x2F;</span><br><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一定要保证进来多少就要出去多少！</span><br><span class="line">  Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;Character, Integer&gt; resMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; t.length(); i++) &#123;</span><br><span class="line">    char c &#x3D; t.charAt(i);</span><br><span class="line">    map.put(c, map.getOrDefault(c, 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  int l &#x3D; 0;</span><br><span class="line">  int r &#x3D; 0;</span><br><span class="line">  int match &#x3D; 0;&#x2F;&#x2F; 匹配的个数，只关心字符，出现次数也需要一样</span><br><span class="line">  String res &#x3D; &quot;&quot;;</span><br><span class="line">  int len &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  while (r &lt; s.length()) &#123;</span><br><span class="line">    char temp &#x3D; s.charAt(r);</span><br><span class="line">    if (map.containsKey(temp)) &#123;</span><br><span class="line">      resMap.put(temp, resMap.getOrDefault(temp, 0) + 1);</span><br><span class="line">      if (map.get(temp).equals(resMap.get(temp))) &#123;</span><br><span class="line">        match++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r++; &#x2F;&#x2F; 向前进</span><br><span class="line">    &#x2F;&#x2F; 匹配到需要的长度，也就是map中的元素个数长度</span><br><span class="line">    while (match &#x3D;&#x3D; map.size()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果长度小的话，则截取</span><br><span class="line">      if ((r - l) &lt; len) &#123;</span><br><span class="line">        res &#x3D; s.substring(l, r);</span><br><span class="line">        len &#x3D; res.length();</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 此时需要向右移动</span><br><span class="line">      char t1 &#x3D; s.charAt(l);</span><br><span class="line">      if (map.containsKey(t1)) &#123;</span><br><span class="line">        resMap.put(t1, resMap.get(t1) - 1);</span><br><span class="line">        &#x2F;&#x2F; 不匹配的话，是因为resMap中的当前字母个数小于map中的</span><br><span class="line">        if (map.get(t1) &gt; resMap.getOrDefault(t1, 0)) &#123;</span><br><span class="line">          match--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return res.length() &lt; Integer.MAX_VALUE ? res : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><h3 id="Set和Map数据结构的使用"><a href="#Set和Map数据结构的使用" class="headerlink" title="Set和Map数据结构的使用"></a>Set和Map数据结构的使用</h3><h4 id="Leetcode-349-Intersection-of-Two-Arrays"><a href="#Leetcode-349-Intersection-of-Two-Arrays" class="headerlink" title="Leetcode 349 Intersection of Two Arrays"></a>Leetcode 349 Intersection of Two Arrays</h4><h4 id="Leetcode-350-Intersection-of-Two-Arrays"><a href="#Leetcode-350-Intersection-of-Two-Arrays" class="headerlink" title="Leetcode 350 Intersection of Two Arrays"></a>Leetcode 350 Intersection of Two Arrays</h4><blockquote>
<p>如果上述的数组是有序该如何解决？可以不借助map和set的数据结构</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>

<p>思路：排序或者使用map表来记录响应的数据出现次数，排序是最稳妥的，前后遍历即可。每次遇到比自己大的自己向后走，小则对方向后走，等则加入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 时间复杂度:O(nlogn+mlogm)主要是两趟排序的时间，遍历的可以忽略  空间复杂度:O(1)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int[] intersect_1(int[] nums1, int[] nums2) &#123;</span><br><span class="line">  if (nums1 &#x3D;&#x3D; null || nums2 &#x3D;&#x3D; null) return null;</span><br><span class="line">  Arrays.sort(nums1);</span><br><span class="line">  Arrays.sort(nums2);</span><br><span class="line">  int len1 &#x3D; nums1.length;</span><br><span class="line">  int len2 &#x3D; nums2.length;</span><br><span class="line">  int l1 &#x3D; 0;</span><br><span class="line">  int l2 &#x3D; 0;</span><br><span class="line">  List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  while (l1 &lt; len1 &amp;&amp; l2 &lt; len2) &#123;</span><br><span class="line">    if (nums1[l1] &gt; nums2[l2]) &#123;</span><br><span class="line">      l2++;</span><br><span class="line">    &#125; else if (nums1[l1] &lt; nums2[l2]) &#123;</span><br><span class="line">      l1++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      list.add(nums1[l1]);</span><br><span class="line">      l1++;</span><br><span class="line">      l2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] res &#x3D; new int[list.size()];</span><br><span class="line">  l1 &#x3D; 0;</span><br><span class="line">  for (Integer num : list) &#123;</span><br><span class="line">    res[l1++] &#x3D; num;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 另外一种方法用map记录此时去重复</span><br><span class="line"> * 时间复杂度:O(m+n) 空间复杂度:O(min(m,n))</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">  if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    return intersect(nums2, nums1); &#x2F;&#x2F; 选出短的</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int num : nums1) &#123;</span><br><span class="line">    map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  for (int num : nums2) &#123;</span><br><span class="line">    int cnt &#x3D; map.getOrDefault(num, 0);</span><br><span class="line">    if (cnt &gt; 0) &#123;</span><br><span class="line">      nums1[k++] &#x3D; num;</span><br><span class="line">      map.put(num, cnt - 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Arrays.copyOfRange(nums1,0,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-242-Valid-Anagram"><a href="#Leetcode-242-Valid-Anagram" class="headerlink" title="Leetcode 242 Valid Anagram"></a>Leetcode 242 Valid Anagram</h4><blockquote>
<p>转变为字符char类型数组，排序，判断是否相等</p>
<p>使用数组加减，看最后所有的是否为0</p>
</blockquote>
<h4 id="Leetcode-202-Happy-Number"><a href="#Leetcode-202-Happy-Number" class="headerlink" title="Leetcode 202 Happy Number"></a>Leetcode 202 Happy Number</h4><blockquote>
<p>快乐数</p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br> 输出：true<br> 解释：<br> 12 + 92 = 82<br> 82 + 22 = 68<br> 62 + 82 = 100<br> 12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>1.如果不是快乐数，最终是会经历等于4的状态</p>
<p>2.如果不是快乐数，最终是会经历相等的状态，且不为1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不是快乐数最终会变为4</span><br><span class="line">public boolean isHappy1(int n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 也就是最后需要为100，值为1</span><br><span class="line">  if(n &#x3D;&#x3D; 4) return false;</span><br><span class="line">  if(n &#x3D;&#x3D; 1) return true;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  while(n !&#x3D; 0)&#123;</span><br><span class="line">    sum +&#x3D; (n%10)*(n%10);</span><br><span class="line">    n &#x2F;&#x3D; 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return isHappy1(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用快慢指针的思路</span><br><span class="line">     *&#x2F;</span><br><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">  int fast &#x3D; n;</span><br><span class="line">  int slow &#x3D; n;</span><br><span class="line">  &#x2F;&#x2F; 不是快乐数最终是会相遇的</span><br><span class="line">  do&#123;</span><br><span class="line">    slow &#x3D; getSum(slow);</span><br><span class="line">    fast &#x3D; getSum(fast);</span><br><span class="line">    fast &#x3D; getSum(fast);</span><br><span class="line">  &#125;while(slow !&#x3D; fast);</span><br><span class="line">  return slow &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSum(int n)&#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  while(n !&#x3D; 0)&#123;</span><br><span class="line">    sum +&#x3D; (n%10)*(n%10);</span><br><span class="line">    n &#x2F;&#x3D; 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-290-Word-Pattern"><a href="#Leetcode-290-Word-Pattern" class="headerlink" title="Leetcode 290 Word Pattern"></a>Leetcode 290 Word Pattern</h4><blockquote>
<p>单词匹配问题</p>
<p>“abba” =&gt; “dog cat cat dog”  true</p>
<p>“abba” =&gt; “dog dog dog dog” false</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空间复杂度：O(n)  时间复杂度：O(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean wordPattern1(String pattern, String str) &#123;</span><br><span class="line">  char[] chars &#x3D; pattern.toCharArray();</span><br><span class="line">  String[] s &#x3D; str.split(&quot; &quot;);</span><br><span class="line">  int l1 &#x3D; chars.length;</span><br><span class="line">  int l2 &#x3D; s.length;</span><br><span class="line">  if (l1 !&#x3D; l2) return false;</span><br><span class="line">  &#x2F;&#x2F; abba    dog dog dog dog  &#x3D;&#x3D;&gt; false</span><br><span class="line">  Map&lt;Character, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">  int index &#x3D; 0;</span><br><span class="line">  while (index &lt; l1) &#123;</span><br><span class="line">    if (!map.containsKey(chars[index])) &#123;</span><br><span class="line">      map.put(chars[index], s[index]);</span><br><span class="line">      boolean add &#x3D; set.add(s[index]);  &#x2F;&#x2F; set添加</span><br><span class="line">      if (!add) &#123; &#x2F;&#x2F; 如果set失败的话，就遇到了键不同，值相同的情况</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 否则就是包含</span><br><span class="line">      if (!map.get(chars[index]).equals(s[index])) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">  String[] s &#x3D; str.split(&quot; &quot;); &#x2F;&#x2F; 主要是pattern为&quot;&quot; str为&quot;beef&quot;类似这种</span><br><span class="line">  if (s.length !&#x3D; pattern.length()) return false;</span><br><span class="line">  String[] p &#x3D; pattern.split(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return judgement(p, s) &amp;&amp; judgement(s, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean judgement(String[] p, String[] s) &#123;</span><br><span class="line">  int len &#x3D; p.length;</span><br><span class="line">  Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    if (map.containsKey(p[i])) &#123;</span><br><span class="line">      if (!map.get(p[i]).equals(s[i])) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F; 不包含</span><br><span class="line">      map.put(p[i], s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-205-Isomorphic-Strings"><a href="#Leetcode-205-Isomorphic-Strings" class="headerlink" title="Leetcode 205 Isomorphic Strings"></a>Leetcode 205 Isomorphic Strings</h4><blockquote>
<p>思路与上面一题几乎一致</p>
</blockquote>
<h4 id="Leetcode-451-Sort-Characters-By-Frequency"><a href="#Leetcode-451-Sort-Characters-By-Frequency" class="headerlink" title="Leetcode 451 Sort Characters By Frequency"></a>Leetcode 451 Sort Characters By Frequency</h4><blockquote>
<p>根据字符出现频率排序</p>
<p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例 1:</p>
<p>输入:<br> “tree”</p>
<p>输出:<br> “eert”</p>
<p>解释:<br> ‘e’出现两次，’r’和’t’都只出现一次。<br> 因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/sort-characters-by-frequency" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-characters-by-frequency</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>这一题再面试中见过，使用堆对字符串出现次数排序，自己构造对象，重写比较方法即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 通过HashMap获取值，然后排序获得</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort1(String s) &#123;</span><br><span class="line">  if (s &#x3D;&#x3D; null) return s;</span><br><span class="line">  Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  String[] split &#x3D; s.split(&quot;&quot;);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; split.length; i++) &#123;</span><br><span class="line">    map.put(split[i], map.getOrDefault(split[i], 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt; entries &#x3D; new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">  Collections.sort(entries, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123;</span><br><span class="line">      return o1.getValue().compareTo(o2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">    int cnt &#x3D; entry.getValue();</span><br><span class="line">    String key &#x3D; entry.getKey();</span><br><span class="line">    while (cnt !&#x3D; 0) &#123;</span><br><span class="line">      sb.append(key);</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用map和结构化数组来实现</span><br><span class="line">     * 数组中放入list，其中数组大小由最大次数决定即数组中有list</span><br><span class="line">     * 次数是list的下标，而这么多次数的字母在list中</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort2(String s) &#123;</span><br><span class="line">  if(s &#x3D;&#x3D; null) return s;</span><br><span class="line">  Map&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  int maxTimes &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);</span><br><span class="line">    maxTimes &#x3D; Math.max(maxTimes,map.get(s.charAt(i)));</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Character&gt;[] arrayLists &#x3D; new ArrayList[maxTimes+1];</span><br><span class="line">  for (Character c : map.keySet()) &#123;</span><br><span class="line">    int f &#x3D; map.get(c);</span><br><span class="line">    if(arrayLists[f] &#x3D;&#x3D; null)&#123;</span><br><span class="line">      arrayLists[f] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    arrayLists[f].add(c);</span><br><span class="line">  &#125;</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (int i &#x3D; maxTimes; i &gt;&#x3D; 0 ; i--) &#123;</span><br><span class="line">    if(arrayLists[i] !&#x3D; null)&#123;</span><br><span class="line">      for (Character c : arrayLists[i]) &#123;</span><br><span class="line">        while(i !&#x3D; 0)&#123;</span><br><span class="line">          sb.append(c);</span><br><span class="line">          i--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 学了面向对象，居然不会用面向对象，可笑</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用大顶堆，自己构建一个对象，对象实现comparator接口</span><br><span class="line">     * 重写比较方法即可维护一个属于自己的判断的大顶堆</span><br><span class="line">     * 最后根据大顶堆输出字符的次数，StringBuilder拼接即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort(String s) &#123;</span><br><span class="line">  int[] tab &#x3D; new int[256];</span><br><span class="line">  char[] chars &#x3D; s.toCharArray();</span><br><span class="line">  for (char c : chars) &#123;</span><br><span class="line">    tab[c]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PriorityQueue&lt;Latter&gt; queue &#x3D; new PriorityQueue&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; tab.length; i++) &#123;</span><br><span class="line">    if(tab[i] !&#x3D; 0)&#123;</span><br><span class="line">      queue.add(new Latter((char) i, tab[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  while (!queue.isEmpty())&#123;</span><br><span class="line">    Latter poll &#x3D; queue.poll();</span><br><span class="line">    int cnt &#x3D; poll.cnt;</span><br><span class="line">    while (cnt !&#x3D; 0)&#123;</span><br><span class="line">      sb.append(poll.c);</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造对象</span><br><span class="line">class Latter implements Comparable&#123;</span><br><span class="line">  char c;</span><br><span class="line">  int cnt;</span><br><span class="line"></span><br><span class="line">  public Latter(char c, int cnt) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.cnt &#x3D; cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int compareTo(Object o) &#123;</span><br><span class="line">    return ((Latter) o).cnt - this.cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><h4 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode 1 Two Sum"></a>Leetcode 1 Two Sum</h4><h4 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15 3Sum"></a>Leetcode 15 3Sum</h4><blockquote>
<p>三数之和</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br> [<br> [-1, 0, 1],<br> [-1, -1, 2]<br> ]</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先需要遍历一次，暴力解法的话O(n^3)，时间复杂度过高。采用遍历一次，其中使用二分法夹逼。但是注意需要去重复逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (nums.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">    if (i - 1 &gt;&#x3D; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">    for (int j &#x3D; i + 1; j &lt; nums.length - 1; j++) &#123;</span><br><span class="line">      if (j - 1 &gt; i &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">      for (int k &#x3D; j + 1; k &lt; nums.length; k++) &#123;</span><br><span class="line">        if (k - 1 &gt; j &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">        if (nums[j] + nums[k] + nums[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          res.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum_1(int[] nums) &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (nums.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 二分法</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">    if(i - 1 &gt;&#x3D; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1]) continue;</span><br><span class="line">    int l &#x3D; i+1;</span><br><span class="line">    int r &#x3D; nums.length-1;</span><br><span class="line">    int temp &#x3D; -nums[i];</span><br><span class="line">    &#x2F;&#x2F; 大于0的话，由于排序了，后面的数不可能为负数</span><br><span class="line">    if(nums[i] &gt; 0)&#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">      &#x2F;&#x2F; [-2,0,0,2,2]</span><br><span class="line">      &#x2F;&#x2F; 内部也要去重复</span><br><span class="line">      int tmp &#x3D; nums[l]+nums[r];</span><br><span class="line">      if(tmp &gt; temp)&#123;</span><br><span class="line">        r--; &#x2F;&#x2F; 先想前走，如果还是等于后面的，继续走，去重逻辑</span><br><span class="line">        while (r &gt; l &amp;&amp; nums[r] &#x3D;&#x3D; nums[r+1])&#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else if(tmp &lt; temp)&#123;</span><br><span class="line">        l++; &#x2F;&#x2F; 先向后走，如果还是等于前面的，继续走，去重逻辑</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l-1])&#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        res.add(Arrays.asList(nums[i],nums[l],nums[r]));</span><br><span class="line">        r--; &#x2F;&#x2F; 先前后都走，如果两个还是等于，继续一起走</span><br><span class="line">        l++;</span><br><span class="line">        while( l &lt; r &amp;&amp; nums[r+1] &#x3D;&#x3D; nums[r] &amp;&amp; nums[l] &#x3D;&#x3D; nums[l-1])&#123;</span><br><span class="line">          r--;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode 18 4Sum"></a>Leetcode 18 4Sum</h4><blockquote>
<p>四数之和</p>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：第一种四层循环，注意去重，第二种两重循环，外加双指针，注意去重即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 利用四重循环的思路可以解决，时间复杂度O(n^4)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum1(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 4) return res;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 3; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; len - 2; j++) &#123;</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j - 1] &#x3D;&#x3D; nums[j]) continue;</span><br><span class="line">            int temp &#x3D; nums[i] + nums[j];</span><br><span class="line">            for (int k &#x3D; j + 1; k &lt; len - 1; k++) &#123;</span><br><span class="line">                if (k &gt; j + 1 &amp;&amp; nums[k - 1] &#x3D;&#x3D; nums[k]) continue;</span><br><span class="line">                for (int l &#x3D; k + 1; l &lt; len; l++) &#123;</span><br><span class="line">                    if (l &gt; k + 1 &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) continue;</span><br><span class="line">                    if (temp + nums[k] + nums[l] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用双指针的方式</span><br><span class="line"> * 排序O(nlogn) 双重遍历O(n^2) 其中双指针操作O(n&#x2F;2)</span><br><span class="line"> * 总的时间复杂度O(n^3)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 4) return res;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 3; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; len - 2; j++) &#123;</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j - 1] &#x3D;&#x3D; nums[j]) continue;</span><br><span class="line">            &#x2F;&#x2F; 嵌套双指针</span><br><span class="line">            int l &#x3D; j + 1;</span><br><span class="line">            int r &#x3D; nums.length - 1;</span><br><span class="line">            int temp &#x3D; nums[i] + nums[j];</span><br><span class="line">            while (l &lt; r) &#123;</span><br><span class="line">                int t &#x3D; nums[l] + nums[r];</span><br><span class="line">                if (temp + t &lt; target) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) &#123;</span><br><span class="line">                        l++;&#x2F;&#x2F; 这里l已经+1所以是和自己前面的对比</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (temp + t &gt; target) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[r + 1] &#x3D;&#x3D; nums[r]) &#123;</span><br><span class="line">                        r--;&#x2F;&#x2F; 这里r已经-1，所以是和自己后面的对比</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));</span><br><span class="line">                    r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l - 1] &amp;&amp; nums[r] &#x3D;&#x3D; nums[r + 1]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-16-3Sum-Closet"><a href="#Leetcode-16-3Sum-Closet" class="headerlink" title="Leetcode 16 3Sum Closet"></a>Leetcode 16 3Sum Closet</h4><blockquote>
<p>最接近三数之和</p>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：与三数之和基本一致，只是多了个比较绝对值的操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 时间复杂度O(n^2) 外层循环+内层双指针</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    int res &#x3D; 1000000;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    &#x2F;&#x2F; 怎么最接近，就是剪去target，看谁绝对值更小</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        int l &#x3D; i + 1;</span><br><span class="line">        int r &#x3D; len - 1;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int temp &#x3D; nums[l] + nums[r]; &#x2F;&#x2F; 注意这里需要比较绝对值更小的才是最接近</span><br><span class="line">            res &#x3D; Math.abs(res - target) &gt; Math.abs(temp + nums[i] - target) ? temp+nums[i] : res;</span><br><span class="line">            if (temp + nums[i] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return target;</span><br><span class="line">            &#125; else if (temp + nums[i] &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[r + 1] &#x3D;&#x3D; nums[r]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l++;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-454-4Sum-II"><a href="#Leetcode-454-4Sum-II" class="headerlink" title="Leetcode 454 4Sum II"></a>Leetcode 454 4Sum II</h4><blockquote>
<p>四数之和II</p>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p>例如:</p>
<p>输入:<br> A = [ 1, 2]<br> B = [-2,-1]<br> C = [-1, 2]<br> D = [ 0, 2]</p>
<p>输出:<br> 2</p>
<p>解释:<br> 两个元组如下:</p>
<ol>
<li><p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</p>
</li>
<li><p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</p>
</li>
</ol>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/4sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：四重循环也可。或者使用map将其变换为两数之和</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 使用map获取两个，然后通过组合</span><br><span class="line"> * 时间复杂度O(n^2) 空间复杂度(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (A.length &#x3D;&#x3D; 0 || B.length &#x3D;&#x3D; 0</span><br><span class="line">            || C.length &#x3D;&#x3D; 0 || D.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; A.length;</span><br><span class="line">    &#x2F;&#x2F; 时间复杂度按照n^2来走</span><br><span class="line">    Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">            int t &#x3D; A[i] + B[j];</span><br><span class="line">            map.put(t, map.getOrDefault(t, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">            int t &#x3D; C[i] + D[j];</span><br><span class="line">            map2.put(t, map2.getOrDefault(t, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set &#x3D; map.keySet();</span><br><span class="line">    for (int a : set) &#123;</span><br><span class="line">        res +&#x3D; map.get(a) * map2.getOrDefault(-a, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-49-Group-Anagrams"><a href="#Leetcode-49-Group-Anagrams" class="headerlink" title="Leetcode 49 Group Anagrams"></a>Leetcode 49 Group Anagrams</h4><blockquote>
<p>字母异位词分组</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>所有输入均为小写字母。<br> 不考虑答案输出的顺序。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/group-anagrams" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>遍历排序用map记录相同的string，内部维护list记录，最后遍历取出list即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 遍历内部排序</span><br><span class="line"> * 时间复杂度:O(nklogk) n表示strs长度，k表示字符串长度</span><br><span class="line"> * 空间复杂度:O(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (strs.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (String str : strs) &#123;</span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        ;</span><br><span class="line">        String temp &#x3D; String.valueOf(chars);</span><br><span class="line">        if (!map.containsKey(temp)) &#123;</span><br><span class="line">            map.put(temp, new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(temp).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    for (String s : map.keySet()) &#123;</span><br><span class="line">        res.add(map.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-447-Number-of-Boomerangs"><a href="#Leetcode-447-Number-of-Boomerangs" class="headerlink" title="Leetcode 447 Number of Boomerangs"></a>Leetcode 447 Number of Boomerangs</h4><blockquote>
<p>回旋镖的数量</p>
<p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</p>
<p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p>
<p>示例:</p>
<p>输入:<br> [[0,0],[1,0],[2,0]]</p>
<p>输出:<br> 2</p>
<p>解释:<br> 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/number-of-boomerangs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-boomerangs</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>计算距离，总数目为n(n-1)，考虑到下一次再出现数目为(n+1)n，地增量为2*n，所以每次只要有超过1个以上的就计算数目即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    public int numberOfBoomerangs(int[][] points) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (points &#x3D;&#x3D; null) return 0;</span><br><span class="line"></span><br><span class="line">    int m &#x3D; points.length;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">           int sum &#x3D; getSum(i,j,points);</span><br><span class="line">           if(!map.containsKey(sum))&#123;</span><br><span class="line">               map.put(sum,1);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               int n &#x3D; map.get(sum);</span><br><span class="line">               res +&#x3D; 2 * n;</span><br><span class="line">               map.put(sum,n+1);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">    public int getSum(int i, int j, int[][] points)&#123;</span><br><span class="line">    return (points[i][0]-points[j][0])*(points[i][0]-points[j][0])</span><br><span class="line">            + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-149-Max-Points-on-a-Line"><a href="#Leetcode-149-Max-Points-on-a-Line" class="headerlink" title="Leetcode 149 Max Points on a Line"></a>Leetcode 149 Max Points on a Line</h4><blockquote>
<p>直线上最多的点数</p>
<p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p>
<p>示例 1:</p>
<p>输入: [[1,1],[2,2],[3,3]]<br> 输出: 3<br> 解释:<br> ^<br> |<br> |        o<br> |     o<br> |  o<br> +————-&gt;<br> 0  1  2  3  4<br> 示例 2:</p>
<p>输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br> 输出: 4<br> 解释:<br> ^<br> |<br> |  o<br> |     o        o<br> |        o<br> |  o        o<br> +——————-&gt;<br> 0  1  2  3  4  5  6</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/max-points-on-a-line" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-points-on-a-line</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：使用map记录，由于出现的数可能会非常大，此时就获取最大公约数来获取同样的值，同时自定义键，注意有重复的使用duplicate记录下来即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    public int maxPoints(int[][] points) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算斜率，正负都要考虑</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    int l &#x3D; points.length;</span><br><span class="line">    if (l &lt; 2) return l;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">        int duplicate &#x3D; 0; &#x2F;&#x2F; 计算重复的元素</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; l; j++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) continue;</span><br><span class="line">            &#x2F;&#x2F; 需要计算入一个重复的元素</span><br><span class="line">            &#x2F;&#x2F; 否则计算斜率</span><br><span class="line">            int x &#x3D; (points[i][0] - points[j][0]);</span><br><span class="line">            int y &#x3D; (points[i][1] - points[j][1]);</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                duplicate++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 辗转相除获取最大公约数</span><br><span class="line">            int a &#x3D; gcdII(x, y);</span><br><span class="line">            x &#x3D; x &#x2F; a;</span><br><span class="line">            y &#x3D; y &#x2F; a;</span><br><span class="line">            &#x2F;&#x2F; 获取最大公约数</span><br><span class="line">            String key &#x3D; x + &quot;-&quot; + y;</span><br><span class="line">            map.put(key, map.getOrDefault(key, 0) + 1);</span><br><span class="line">            max &#x3D; Math.max(max, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, max + duplicate + 1);</span><br><span class="line">        map.clear();&#x2F;&#x2F; 注意清除</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int gcdII(int a, int b) &#123;</span><br><span class="line">    while(b !&#x3D; 0)&#123;</span><br><span class="line">        int temp &#x3D; a % b;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口-查找表"><a href="#滑动窗口-查找表" class="headerlink" title="滑动窗口+查找表"></a>滑动窗口+查找表</h3><h4 id="Leetcode-219-Contains-Duplicate-II"><a href="#Leetcode-219-Contains-Duplicate-II" class="headerlink" title="Leetcode 219 Contains Duplicate II"></a>Leetcode 219 Contains Duplicate II</h4><blockquote>
<p>存在重复元素II</p>
<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br> 输出: true<br> 示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br> 输出: true<br> 示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br> 输出: false</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：利用set维护相同的情况，一旦插入失败，判断间距大小是否符合，符合true，不符合移除元素。如果能够插入，需要保持间距k，所以需要适当移除元素。</p>
<p>时间复杂度：O(n)；空间复杂度：O(k)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">    if (nums.length &lt;&#x3D; 1 || k &lt; 0) return false;</span><br><span class="line">    int l &#x3D; 0;</span><br><span class="line">    int r &#x3D; 0;</span><br><span class="line">    Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 窗口大小维持k大小</span><br><span class="line">    while (r &lt; nums.length) &#123;</span><br><span class="line">        if (!set.add(nums[r])) &#123;</span><br><span class="line">            if (r - l &lt;&#x3D; k) return true;</span><br><span class="line">            else set.remove(nums[l++]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 因为如果等于k的话，此时也要移除</span><br><span class="line">            if (r - l &gt;&#x3D; k) set.remove(nums[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-217-Contains-Duplicate"><a href="#Leetcode-217-Contains-Duplicate" class="headerlink" title="Leetcode 217 Contains Duplicate"></a>Leetcode 217 Contains Duplicate</h4><h4 id="Leetcode-220-Contains-Duplicate-III"><a href="#Leetcode-220-Contains-Duplicate-III" class="headerlink" title="Leetcode 220 Contains Duplicate III"></a>Leetcode 220 Contains Duplicate III</h4><blockquote>
<p>存在重复元素III</p>
<p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3, t = 0<br> 输出: true</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-iii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：利用TreeMap底层是红黑树实现的特性，且有序的特性，动态获取大于当前值的值，然后通过大小为k的窗口获取</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 利用TreeMap获取自己上半部分的值</span><br><span class="line"> * 利用判断获取自己下半部分的值</span><br><span class="line"> *    nums[i]-t  &lt;&#x3D; temp &lt;&#x3D; nums[i]+t ，则证明有效</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">    if (nums.length &lt; 2 || k &lt; 0) return false;</span><br><span class="line">    &#x2F;&#x2F; 利用查找表结合滑动窗口来实现啊</span><br><span class="line">   TreeSet&lt;Long&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 给出一个大于当前给的值的值</span><br><span class="line">        Long temp &#x3D; set.ceiling((long)nums[i]-(long)t);</span><br><span class="line">        if(temp !&#x3D; null &amp;&amp; temp &lt;&#x3D; (long)nums[i]+(long)t)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((long)nums[i]);</span><br><span class="line">        if(set.size() &#x3D;&#x3D; k+1)&#123;</span><br><span class="line">            set.remove((long)nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="Leetcode-206-Reverse-Linked-List"><a href="#Leetcode-206-Reverse-Linked-List" class="headerlink" title="Leetcode 206 Reverse Linked List"></a>Leetcode 206 Reverse Linked List</h4><blockquote>
<p>反转链表</p>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br> 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br> 进阶:<br> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：遍历一遍还是很简单，如果使用递归的话一定要注意到了最后的节点，要注意衔接前和后的关系。head.next.next=head;head.next=null;主要就在这了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 直接利用走一趟的方式解决</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseList1(ListNode head) &#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    while(head.next !&#x3D; null)&#123;</span><br><span class="line">        ListNode temp &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 利用递归的方式解决链表反转</span><br><span class="line"> * 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"> * 首先到5，然后pre&#x3D;5      head</span><br><span class="line"> * head.next.next&#x3D;head,即  4 -&gt; 5 -&gt; 4 然后head.next切断4-&gt;5</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; reverseList(head.next);</span><br><span class="line">    &#x2F;&#x2F; 此处反转</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 释放当前的head</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92 Reverse Linked List II"></a>Leetcode 92 Reverse Linked List II</h4><blockquote>
<p>反转链表II</p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br> 1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br> 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>第一种方法：遍历实现，找到初始标记点，往后所有的点往这个点后面插即可，开始的第一个点一直向后走直到到达最后一个点为止。</p>
<p>第二种方法：利用递归实现，利用前n个翻转实现，前n个翻转记住后面的后继节点即可，然后翻转前半部分，而翻转区间如果m为1的话等同于翻转前n个，如果不为1的话，表名当前节点的下一个节点可能为需要翻转的部分，但是翻转n个从1开始，所以相对而言，区间需要保持同时减一，向后移动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 使用一遍遍历，首先找到一个基准位节点，最后每次将第一个节点</span><br><span class="line"> * 的后面的节点插入到当前基准位节点之后就好。一直遍历到n节点即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseBetween1(ListNode head, int m, int n) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    int res &#x3D; 0; &#x2F;&#x2F; 用来记录遍历到的位置</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode pre &#x3D; dummyNode;</span><br><span class="line">    ListNode cur &#x3D; dummyNode.next;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m - 1; i++) &#123;</span><br><span class="line">        pre &#x3D; pre.next;</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; pre保持不变，第一个节点一直向后走，其余遇到的节点向第一个节点后面插就好</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n - m; i++) &#123;</span><br><span class="line">        ListNode temp &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; cur.next.next;&#x2F;&#x2F; 交换当前节点与后面节点的指向</span><br><span class="line">        &#x2F;&#x2F; 解除之前的连接</span><br><span class="line">        temp.next &#x3D; pre.next;</span><br><span class="line">        pre.next &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 翻转前n个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">private ListNode successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">public ListNode reverseN(ListNode head, int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        successor &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 成环了</span><br><span class="line">    ListNode res &#x3D; reverseN(head.next, n - 1);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line"></span><br><span class="line">    head.next &#x3D; successor;&#x2F;&#x2F; 每一个的尾部都指向successor也就是尾端</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 递归实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">    if (m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则的需要向后走，由于m与n是相对位置，所以需要一起减少</span><br><span class="line">    head.next &#x3D; reverseBetween(head.next, m - 1, n - 1);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h4><blockquote>
<p>删除排序链表中的重复元素</p>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br> 输出: 1-&gt;2<br> 示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br> 输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：第一种思路：双指针，不同一起走，相同的话找到后面的不同，然后改变指针指向。第二种思路：单指针，如果下一个与自己相同，改变指向，改变指向比较频繁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到不同的那个点，然后改变指针指向</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode q = p.next;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span> &amp;&amp; q.val == p.val)&#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = q;</span><br><span class="line">        <span class="keyword">if</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要相同一直改变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">            <span class="comment">// 改变指针指向</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = temp.next;</span><br><span class="line">            temp.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 利用虚拟头节点是一个方法，每次都新建一个节点拼接</span><br><span class="line"> * 最后将两条链表组合即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode partition(ListNode head, int x) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode small &#x3D; new ListNode(0);</span><br><span class="line">    ListNode s &#x3D; small;</span><br><span class="line">    ListNode big &#x3D; new ListNode(0);</span><br><span class="line">    ListNode b &#x3D; big;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        if (head.val &lt; x) &#123;</span><br><span class="line">            s.next &#x3D; new ListNode(head.val);</span><br><span class="line">            s &#x3D; s.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            b.next &#x3D; new ListNode(head.val);</span><br><span class="line">            b &#x3D; b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    s.next &#x3D; big.next;</span><br><span class="line">    return small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-328-Odd-Even-Linked-List"><a href="#Leetcode-328-Odd-Even-Linked-List" class="headerlink" title="Leetcode 328 Odd Even Linked List"></a>Leetcode 328 Odd Even Linked List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    public ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode even &#x3D; head.next;</span><br><span class="line">    ListNode o &#x3D; head;&#x2F;&#x2F; 奇数节点</span><br><span class="line">    ListNode e &#x3D; even;&#x2F;&#x2F; 偶数节点</span><br><span class="line">    while (e !&#x3D; null &amp;&amp; e.next !&#x3D; null) &#123;</span><br><span class="line">        o.next &#x3D; e.next;</span><br><span class="line">        o &#x3D; e.next;&#x2F;&#x2F; 奇数节点到偶数节点的下一个节点</span><br><span class="line">        e.next &#x3D; o.next;</span><br><span class="line">        e &#x3D; o.next;&#x2F;&#x2F; 偶数节点到奇数节点的下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    o.next &#x3D; even;&#x2F;&#x2F; 奇数节点的下一个节点连接到偶数节点的头节点</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h4><blockquote>
<p>两数相加</p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br> 输出：7 -&gt; 0 -&gt; 8<br> 原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：官方给的这个例子不好，其实因为正反都是807。24+56=701，可以看到进位在往后走，只需要依据链表不为null，且进位不等于0，就结束计算，任有一项不满足结束计算，否则继续拼接。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode sum &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; sum;</span><br><span class="line">        &#x2F;&#x2F; 是否有进位</span><br><span class="line">        int carry &#x3D; 0;</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null || carry !&#x3D; 0)&#123;</span><br><span class="line">            int l1val &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">            int l2val &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">            int temp &#x3D; l1val + l2val + carry;</span><br><span class="line">            carry &#x3D; temp &#x2F; 10; &#x2F;&#x2F; 获取余数即进位至下一环节,是将余数进位！</span><br><span class="line">            cur.next &#x3D; new ListNode(temp % 10); &#x2F;&#x2F; 获取十位上作为节点填充</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            if(l1 !&#x3D; null) l1 &#x3D; l1.next;</span><br><span class="line">            if(l2 !&#x3D; null) l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-445-Add-Two-Numbers-II"><a href="#Leetcode-445-Add-Two-Numbers-II" class="headerlink" title="Leetcode 445 Add Two Numbers II"></a>Leetcode 445 Add Two Numbers II</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    l1 &#x3D; reverse(l1);</span><br><span class="line">    l2 &#x3D; reverse(l2);</span><br><span class="line">    int carry &#x3D; 0;</span><br><span class="line">    ListNode sum &#x3D; new ListNode(0);</span><br><span class="line">    ListNode cur &#x3D; sum;</span><br><span class="line">    while(l1 !&#x3D; null ||  l2 !&#x3D; null || carry !&#x3D; 0)&#123;</span><br><span class="line">        int l1val &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">        int l2val &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">        int temp &#x3D; l1val + l2val + carry;</span><br><span class="line">        carry &#x3D; temp &#x2F; 10;</span><br><span class="line">        cur.next &#x3D; new ListNode(temp%10);</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">        if(l1 !&#x3D; null) l1 &#x3D; l1.next;</span><br><span class="line">        if(l2 !&#x3D; null) l2 &#x3D; l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return reverse(sum.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不采用翻转的话，就使用数据结构来帮助，栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode addTwoNumbersII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">   Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">   while(l1 !&#x3D; null)&#123;</span><br><span class="line">       stack1.push(l1.val);</span><br><span class="line">       l1 &#x3D; l1.next;</span><br><span class="line">   &#125;</span><br><span class="line">   while(l2 !&#x3D; null)&#123;</span><br><span class="line">       stack2.push(l2.val);</span><br><span class="line">       l2 &#x3D; l2.next;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode sum &#x3D; null; &#x2F;&#x2F; 将结果翻转</span><br><span class="line">   int carry &#x3D; 0;</span><br><span class="line">   while(!stack1.isEmpty() || !stack2.isEmpty() || carry !&#x3D; 0)&#123;</span><br><span class="line">       int s1 &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">       int s2 &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">       int temp &#x3D; s1 + s2 + carry;</span><br><span class="line">       carry &#x3D; temp &#x2F; 10;</span><br><span class="line">       ListNode tmp &#x3D; new ListNode(temp % 10);</span><br><span class="line">       &#x2F;&#x2F; 这要一直插在sum与cur之间</span><br><span class="line">       tmp.next &#x3D; sum;</span><br><span class="line">       sum &#x3D; tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br><span class="line">private ListNode reverse(ListNode head)&#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    while(head !&#x3D; null)&#123;</span><br><span class="line">        ListNode temp &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设立链表虚拟头节点"><a href="#设立链表虚拟头节点" class="headerlink" title="设立链表虚拟头节点"></a>设立链表虚拟头节点</h3><h4 id="Leetcode-203-Remove-Linked-List-Elements"><a href="#Leetcode-203-Remove-Linked-List-Elements" class="headerlink" title="Leetcode 203 Remove Linked List Elements"></a>Leetcode 203 Remove Linked List Elements</h4><blockquote>
<p>移除链表元素</p>
<p>删除链表中等于给定值 <strong>*val</strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 移除元素，使用虚拟头结点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(-1);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode cur &#x3D; dummyNode;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        if (head.val &#x3D;&#x3D; val) &#123;</span><br><span class="line">            ListNode temp &#x3D; head.next;&#x2F;&#x2F; 保存当前节点的下一个节点</span><br><span class="line">            head.next &#x3D; null;&#x2F;&#x2F; 解除当前节点与下一个节点的联系</span><br><span class="line">            head &#x3D; temp;&#x2F;&#x2F; 当前节点向前移动</span><br><span class="line">            cur.next &#x3D; head;&#x2F;&#x2F; 改变cur下一个节点指向</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur &#x3D; head;</span><br><span class="line">            head &#x3D; head.next;&#x2F;&#x2F; 一起向后挪一个位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-82-Remove-Linked-List-Elements-II"><a href="#Leetcode-82-Remove-Linked-List-Elements-II" class="headerlink" title="Leetcode 82 Remove Linked List Elements II"></a>Leetcode 82 Remove Linked List Elements II</h4><blockquote>
<p>移除排序链表中的重复元素</p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br> 输出: 1-&gt;2-&gt;5<br> 示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br> 输出: 2-&gt;3</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 移除重复出现的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode deleteDuplicatesII(ListNode head) &#123;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(-1);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode cur &#x3D; dummyNode;</span><br><span class="line">    &#x2F;&#x2F; 首先保证当前元素和当前下一个元素补位null</span><br><span class="line">    while(head !&#x3D; null &amp;&amp; head.next !&#x3D; null)&#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不等，一起向前</span><br><span class="line">        if(head.val !&#x3D; head.next.val)&#123;</span><br><span class="line">            cur &#x3D; head;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果相等，则head一个人向前，cur等待连接到不等的节点即可</span><br><span class="line">            while(head.next !&#x3D; null &amp;&amp; head.val &#x3D;&#x3D; head.next.val)&#123;</span><br><span class="line">                head &#x3D; head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 到了这里可以表明到了不等的一点或者尾部节点，记住下一个节点</span><br><span class="line">            ListNode temp &#x3D; head.next;</span><br><span class="line">            head.next &#x3D; null;&#x2F;&#x2F; 自己是相等的最后一个节点，断开连接</span><br><span class="line">            head &#x3D; temp;&#x2F;&#x2F; 向前挪至自己的下一个节点</span><br><span class="line">            cur.next &#x3D; head;&#x2F;&#x2F; 将cur.next连接过来即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoListsII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; dummyNode;</span><br><span class="line">        while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if (l1.val &gt;&#x3D; l2.val) &#123;</span><br><span class="line">                cur.next &#x3D; new ListNode(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur.next &#x3D; new ListNode(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1 !&#x3D; null) &#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 !&#x3D; null) &#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode mergeTwoListsIII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; dummyNode;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null)&#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">                cur.next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur.next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        dummyNode.next &#x3D; head;</span><br><span class="line">        ListNode res &#x3D; dummyNode;&#x2F;&#x2F; 记录整条链表衔接</span><br><span class="line">        ListNode cur &#x3D; head;&#x2F;&#x2F; 后节点</span><br><span class="line">        ListNode pre &#x3D; cur.next;&#x2F;&#x2F; 前节点</span><br><span class="line">        while (pre !&#x3D; null) &#123; &#x2F;&#x2F; 前节点不能为null</span><br><span class="line">            ListNode temp &#x3D; pre.next; &#x2F;&#x2F; 前节点前面做临时节点保留</span><br><span class="line">            pre.next &#x3D; cur;&#x2F;&#x2F; 前节点翻转</span><br><span class="line">            cur.next &#x3D; temp;&#x2F;&#x2F; 后节点翻转</span><br><span class="line">            res.next &#x3D; pre;&#x2F;&#x2F; 链表节点下一个衔接翻转之后的</span><br><span class="line">            res &#x3D; pre.next;&#x2F;&#x2F; 链表节点移动到翻转之后的后一个节点</span><br><span class="line">            cur &#x3D; cur.next;&#x2F;&#x2F; 后节点向后走，这里最多为null</span><br><span class="line">            if(cur &#x3D;&#x3D; null)&#123;&#x2F;&#x2F; 后节点如果为null，表示没得走了</span><br><span class="line">                break;&#x2F;&#x2F; 终止</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; cur.next;&#x2F;&#x2F; 否则前节点向前走</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-25-Reverse-Nodes-in-K-Group"><a href="#Leetcode-25-Reverse-Nodes-in-K-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in K-Group"></a>Leetcode 25 Reverse Nodes in K-Group</h4><h4 id="Leetcode-147-Insertion-Sort-List"><a href="#Leetcode-147-Insertion-Sort-List" class="headerlink" title="Leetcode 147 Insertion Sort List"></a>Leetcode 147 Insertion Sort List</h4><h4 id="Leetcode-148-Sort-List"><a href="#Leetcode-148-Sort-List" class="headerlink" title="Leetcode 148 Sort List"></a>Leetcode 148 Sort List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 排序链表，要求时间复杂度为o(nlogn)</span><br><span class="line">     * @param head 头节点</span><br><span class="line">     * @return 排序好的链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">        &#x2F;&#x2F; logn的算法就是二分法</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        while(fast.next !&#x3D; null &amp;&amp; fast.next.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; slow抵达终点，fast抵达终点</span><br><span class="line">        fast &#x3D; slow.next;&#x2F;&#x2F; fast作为后半段的头节点</span><br><span class="line">        slow.next &#x3D; null;&#x2F;&#x2F; 截断</span><br><span class="line">        slow &#x3D; head;&#x2F;&#x2F; slow作为首节点</span><br><span class="line">        ListNode l1 &#x3D; sortList(slow);</span><br><span class="line">        ListNode l2 &#x3D; sortList(fast);</span><br><span class="line">        return merge(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 链表的merge合并过程</span><br><span class="line">    public ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        ListNode res &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; res;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null)&#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">                cur.next &#x3D; l1;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur.next &#x3D; l2;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>插入排序和归并排序</p>
</blockquote>
<h4 id="Leetcode-237-Delete-Node-in-a-Linked-List"><a href="#Leetcode-237-Delete-Node-in-a-Linked-List" class="headerlink" title="Leetcode 237 Delete Node in a Linked List"></a>Leetcode 237 Delete Node in a Linked List</h4><h3 id="链表与双指针"><a href="#链表与双指针" class="headerlink" title="链表与双指针"></a>链表与双指针</h3><h4 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h4><blockquote>
<p>一趟遍历，双指针，指针之间相差n</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 节点之间相差n个，但是注意需要使用一个虚拟节点</span><br><span class="line"> * 防止删除的就是当前的p节点，不然会导致错误</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null) return null;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode p &#x3D; dummyNode;</span><br><span class="line">    ListNode q &#x3D; p;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        n--;&#x2F;&#x2F; 注意在后面的话会多走一个，这样的话越过dummyNode</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两者之间差距为n个节点</span><br><span class="line">    while (q.next !&#x3D; null) &#123;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 一旦为null，表示到了终点</span><br><span class="line">    ListNode temp &#x3D; p.next.next;</span><br><span class="line">    p.next.next &#x3D; null;</span><br><span class="line">    p.next &#x3D; temp;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * k次，时间复杂度O(nk)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null) return null;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        dummyNode.next &#x3D; head;</span><br><span class="line">        ListNode p &#x3D; dummyNode.next;</span><br><span class="line">        ListNode q &#x3D; p.next;</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        k %&#x3D; cnt;</span><br><span class="line">        while(k !&#x3D; 0)&#123;</span><br><span class="line">            while(q.next !&#x3D; null)&#123;</span><br><span class="line">                p&#x3D;p.next;</span><br><span class="line">                q&#x3D;q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next &#x3D; null;</span><br><span class="line">            q.next &#x3D; dummyNode.next;</span><br><span class="line">            dummyNode.next &#x3D; q;</span><br><span class="line">            p &#x3D; q;</span><br><span class="line">            q &#x3D; q.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143 Reorder List"></a>Leetcode 143 Reorder List</h4><p>这个也是找出后半部分的，然后对后半部分的进行翻转，然后插入前一个链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void reorderList(ListNode head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return;</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 此时slow到了中点，fast到了末尾节点</span><br><span class="line">        fast &#x3D; slow.next;</span><br><span class="line">        fast &#x3D; reverse(fast);</span><br><span class="line">        slow.next &#x3D; null;</span><br><span class="line">        slow &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F; 上面的动作正式切换为两个链表了</span><br><span class="line">        &#x2F;&#x2F; 1 2 3 | 4</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        while(slow !&#x3D; null &amp;&amp; fast !&#x3D; null)&#123;</span><br><span class="line">            ListNode temp &#x3D; slow.next;</span><br><span class="line">            ListNode tmp &#x3D; fast.next;</span><br><span class="line">            slow.next &#x3D; fast;</span><br><span class="line">            fast.next &#x3D; temp;</span><br><span class="line">            slow &#x3D; temp;</span><br><span class="line">            fast &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-234-Palindrome-Linked-List"><a href="#Leetcode-234-Palindrome-Linked-List" class="headerlink" title="Leetcode 234 Palindrome Linked List"></a>Leetcode 234 Palindrome Linked List</h4><p>快慢指针，然后翻转后半部分，一个一个对，只要出现不相等就false，否则到最后返回true</p>
<blockquote>
<p>O(1)的时间复杂度解决</p>
</blockquote>
<h2 id="栈和队列的使用"><a href="#栈和队列的使用" class="headerlink" title="栈和队列的使用"></a>栈和队列的使用</h2><h3 id="基础的栈在算法中的使用"><a href="#基础的栈在算法中的使用" class="headerlink" title="基础的栈在算法中的使用"></a>基础的栈在算法中的使用</h3><h4 id="Leetcode-20-Valid-Parentheses"><a href="#Leetcode-20-Valid-Parentheses" class="headerlink" title="Leetcode 20 Valid Parentheses"></a>Leetcode 20 Valid Parentheses</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;if(s.isEmpty()) return true;</span><br><span class="line">        &#x2F;&#x2F; []&#123;&#125;()</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        char[] chars &#x3D; s.toCharArray();</span><br><span class="line">        &#x2F;&#x2F;stack.push(chars[0]);</span><br><span class="line">        &#x2F;&#x2F;for (int i &#x3D; 1; i &lt; chars.length; i++) &#123;</span><br><span class="line">                for (int i &#x3D; 1; i &lt; chars.length; i++) &#123;</span><br><span class="line">            if(!stack.isEmpty() &amp;&amp; pair(stack.peek(),chars[i]))&#123;</span><br><span class="line">                stack.pop();&#x2F;&#x2F; 如果相同就弹出，前提是有元素</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.push(chars[i]);&#x2F;&#x2F; 否则插入元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();&#x2F;&#x2F; 返回是否为空</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean pair(char a, char b)&#123;</span><br><span class="line">        return ((a &#x3D;&#x3D; &#39;(&#39; &amp;&amp; b &#x3D;&#x3D; &#39;)&#39;) || (a &#x3D;&#x3D; &#39;)&#39; &amp;&amp; b &#x3D;&#x3D; &#39;(&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; b &#x3D;&#x3D; &#39;&#125;&#39;) || (a &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; b &#x3D;&#x3D; &#39;&#123;&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39;[&#39; &amp;&amp; b &#x3D;&#x3D; &#39;]&#39;) || (a &#x3D;&#x3D; &#39;]&#39; &amp;&amp; b &#x3D;&#x3D; &#39;[&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39; &#39; &amp;&amp; b &#x3D;&#x3D; &#39; &#39;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-150-Evaluate-Reverse-Polish-Notation"><a href="#Leetcode-150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="Leetcode 150 Evaluate Reverse Polish Notation"></a>Leetcode 150 Evaluate Reverse Polish Notation</h4><blockquote>
<p>逆波兰表达式</p>
</blockquote>
<h4 id="Leetcode-71-Simplify-Path"><a href="#Leetcode-71-Simplify-Path" class="headerlink" title="Leetcode 71 Simplify Path"></a>Leetcode 71 Simplify Path</h4><blockquote>
<p>简化路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 71 简化路径</span><br><span class="line">public String simplifyPath(String path) &#123;</span><br><span class="line">    if(path.isEmpty()) return null;</span><br><span class="line">    String[] split &#x3D; path.split(&quot;&#x2F;&quot;);</span><br><span class="line">    Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 利用&#x2F;分割，遇到..就去除上一个元素</span><br><span class="line">    for (String s : split) &#123;</span><br><span class="line">        if(!stack.isEmpty() &amp;&amp; s.equals(&quot;..&quot;))&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            &#x2F;&#x2F; 否则的话如果不是&quot;&quot;，&quot;.&quot;，或者&quot;..&quot;都添加即可</span><br><span class="line">        &#125;else if(!s.equals(&quot;&quot;) &amp;&amp; !s.equals(&quot;.&quot;) &amp;&amp; !s.equals(&quot;..&quot;))&#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stack.isEmpty())&#123;</span><br><span class="line">        return &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; stack.size(); i++) &#123;</span><br><span class="line">        sb.append(&quot;&#x2F;&quot;).append(stack.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈与递归的紧密关系"><a href="#栈与递归的紧密关系" class="headerlink" title="栈与递归的紧密关系"></a>栈与递归的紧密关系</h3><blockquote>
<p>二叉树的递归处理</p>
</blockquote>
<h4 id="Leetcode-144-Binary-Tree-Preorder-Taversal"><a href="#Leetcode-144-Binary-Tree-Preorder-Taversal" class="headerlink" title="Leetcode 144 Binary Tree Preorder Taversal"></a>Leetcode 144 Binary Tree Preorder Taversal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 144. 二叉树的前序遍历</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归实现</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    executePreorder(root,res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void executePreorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">    if(root &#x3D;&#x3D; null) return;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    executePreorder(root.left,res);</span><br><span class="line">    executePreorder(root.right,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 迭代实现 &#x3D;&#x3D;&gt; 用stack实现啊</span><br><span class="line">public List&lt;Integer&gt; preorderTraversalII(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    TreeNode pool;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        pool &#x3D; stack.pop();</span><br><span class="line">        res.add(pool.val);</span><br><span class="line">        if(pool.right !&#x3D; null)&#123;</span><br><span class="line">            stack.add(pool.right);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pool.left !&#x3D; null)&#123;</span><br><span class="line">            stack.add(pool.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-94-Binary-Tree-Inorder-Traversal"><a href="#Leetcode-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="Leetcode 94 Binary Tree Inorder Traversal"></a>Leetcode 94 Binary Tree Inorder Traversal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 94. 二叉树的中序遍历</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode peek;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        &#x2F;&#x2F; 怎么把左边的值去掉呢</span><br><span class="line">        peek &#x3D; stack.peek();</span><br><span class="line">        if(peek.left !&#x3D; null)&#123;</span><br><span class="line">            stack.push(peek.left);</span><br><span class="line">            peek.left &#x3D; null;&#x2F;&#x2F; 一定要注意将左边的值去掉</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node &#x3D; stack.pop();</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        if(peek.right !&#x3D; null)&#123;</span><br><span class="line">            stack.push(peek.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-145-Binary-Tree-Postorder-Traversal"><a href="#Leetcode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="Leetcode 145 Binary Tree Postorder Traversal"></a>Leetcode 145 Binary Tree Postorder Traversal</h4><blockquote>
<p>可以自定义栈操作来实现非递归实现二叉树的三种遍历形式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 145. 二叉树的后序遍历</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            if (peek.left !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek.left);</span><br><span class="line">                peek.left &#x3D; null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 现在到了中间节点-需要看是是否有右节点。</span><br><span class="line">            if (peek.right !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek.right);</span><br><span class="line">                peek.right &#x3D; null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 否则就到了中间节点，此时必须加入</span><br><span class="line">            TreeNode pop &#x3D; stack.pop();</span><br><span class="line">            res.add(pop.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 面对一切需要面对的！战胜一切需要面对的！</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;Integer&gt; postOrderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            if (peek !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek);</span><br><span class="line">                stack.push(null);&#x2F;&#x2F; 用null值来确保没有处理</span><br><span class="line">                if (peek.right !&#x3D; null) stack.push(peek.right);</span><br><span class="line">                if (peek.left !&#x3D; null) stack.push(peek.left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.add(stack.pop().val);&#x2F;&#x2F; 遇到null，把null下面一个取出即可</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; postOrderTraversalII(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode pre &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 秒啊，利用pre做指针，每次都去判断是否是处理过的点，pre的作用就是是否是处理过的点！</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            &#x2F;&#x2F; 这里的判断条件是看当前的peek是否是到了最后一个点，也就是第一个添加的点</span><br><span class="line">            &#x2F;&#x2F; 或者说是pre不为null，处理过，且此时位置为未处理的，才添加</span><br><span class="line">            if ((peek.left &#x3D;&#x3D; null &amp;&amp; peek.right &#x3D;&#x3D; null)</span><br><span class="line">                    || (pre !&#x3D; null &amp;&amp; (pre &#x3D;&#x3D; peek.right || pre &#x3D;&#x3D; peek.left))) &#123;</span><br><span class="line">                res.add(peek.val);</span><br><span class="line">                pre &#x3D; peek;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (peek.right !&#x3D; null) stack.add(peek.right);</span><br><span class="line">                if (peek.left !&#x3D; null) stack.add(peek.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-341-Flatten-Nested-List-Iterator"><a href="#Leetcode-341-Flatten-Nested-List-Iterator" class="headerlink" title="Leetcode 341 Flatten Nested List Iterator"></a>Leetcode 341 Flatten Nested List Iterator</h4><blockquote>
<p>递归添加就好，可以使用栈和list解决</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">    add(nestedList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void add(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">    for (NestedInteger nestedInteger : nestedList) &#123;</span><br><span class="line">        if(nestedInteger.isInteger())&#123;</span><br><span class="line">            res.add(nestedInteger.getInteger());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list &#x3D; nestedInteger.getList();</span><br><span class="line">            add(list);&#x2F;&#x2F; 递归添加</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return res.size() !&#x3D; index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Integer next() &#123;</span><br><span class="line">    return res.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="Leetcode-102-Binary-Tree-Level-Order-Traversal"><a href="#Leetcode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="Leetcode 102 Binary Tree Level Order Traversal"></a>Leetcode 102 Binary Tree Level Order Traversal</h4><blockquote>
<p>层序遍历</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 层序遍历</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll &#x3D; queue.poll();</span><br><span class="line">                if(poll.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(poll.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(poll.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-107-Binary-Tree-Level-Order-Traversal-II"><a href="#Leetcode-107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Leetcode 107 Binary Tree Level Order Traversal II"></a>Leetcode 107 Binary Tree Level Order Traversal II</h4><blockquote>
<p>层序遍历，反过来插</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll &#x3D; queue.poll();</span><br><span class="line">                if(poll.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(poll.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(poll.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(0,list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Leetcode 103 Binary Tree Zigzag Level Order Traversal"></a>Leetcode 103 Binary Tree Zigzag Level Order Traversal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Z字形打印</span><br><span class="line">    &#x2F;&#x2F; 使用flag作为分界，先进先出只改变插入顺序</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        boolean flag &#x3D; true;&#x2F;&#x2F; 表名偶数</span><br><span class="line">        TreeNode temp &#x3D; null;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                temp &#x3D; queue.poll();</span><br><span class="line">                &#x2F;&#x2F; 根据flag判断为正序还是逆序插入</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    list.add(temp.val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    list.add(0,temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            flag&#x3D;!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双栈策略：是指就是模拟了一个队列而已</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrderII(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack1.push(root);</span><br><span class="line">        boolean flag &#x3D; true;</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                while (!stack1.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop &#x3D; stack1.pop();</span><br><span class="line">                    if(pop.left !&#x3D; null)&#123;</span><br><span class="line">                        stack2.push(pop.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(pop.right !&#x3D; null)&#123;</span><br><span class="line">                        stack2.push(pop.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(pop.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(!stack2.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop &#x3D; stack2.pop();</span><br><span class="line">                    if(pop.right !&#x3D; null)&#123;</span><br><span class="line">                        stack1.push(pop.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(pop.left !&#x3D; null)&#123;</span><br><span class="line">                        stack1.push(pop.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(pop.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            flag &#x3D; !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-199-Binary-Tree-Right-Side-View"><a href="#Leetcode-199-Binary-Tree-Right-Side-View" class="headerlink" title="Leetcode 199 Binary Tree Right Side View"></a>Leetcode 199 Binary Tree Right Side View</h4><blockquote>
<p>二叉树的右视图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 199 二叉树的右视图</span><br><span class="line">    &#x2F;&#x2F; 广度优先遍历</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        &#x2F;&#x2F; 只存最右的节点即可</span><br><span class="line">        TreeNode poll;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                poll &#x3D; queue.poll();</span><br><span class="line">                if (i &#x3D;&#x3D; size - 1) &#123;</span><br><span class="line">                    res.add(poll.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll.left !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll.right !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 深度优先遍历解决</span><br><span class="line">    public List&lt;Integer&gt; rightSideViewII(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        executeRight(root, 0, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void executeRight(TreeNode root, int depth, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据list的size来的，一层只能有一个</span><br><span class="line">        if (root &#x3D;&#x3D; null) return;</span><br><span class="line">        if (depth &#x3D;&#x3D; res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        executeRight(root.right, depth + 1, res);</span><br><span class="line">        executeRight(root.left, depth + 1, res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="BFS和图的最短路径"><a href="#BFS和图的最短路径" class="headerlink" title="BFS和图的最短路径"></a>BFS和图的最短路径</h3><h4 id="Leetcode-279-Perfect-Squares"><a href="#Leetcode-279-Perfect-Squares" class="headerlink" title="Leetcode 279 Perfect Squares"></a>Leetcode 279 Perfect Squares</h4><blockquote>
<p>完全平方数</p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n = 12<br> 输出: 3<br> 解释: 12 = 4 + 4 + 4.</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：类似于寻找最短路径，放入第一次的路径长度，步数。每次寻找的时候，将相应的可以获取到平方数的计算路径与步数放入其中，一旦路径为0，表明此时步数是最短的。输出即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 放入当前数与当前数走的步数，也就是最短路径问题</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> Pair(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 为避免重复计算</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        visited[n] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair poll = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> num = poll.first;</span><br><span class="line">            <span class="keyword">int</span> step = poll.second;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则的话</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; num - i * i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = num - i * i;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果之前没有计算过</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[a]) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Pair(a, step + <span class="number">1</span>));</span><br><span class="line">                    visited[a] = <span class="keyword">true</span>; <span class="comment">// 已访问过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用动态规划的方式来做</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquaresII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 12 = 4 + 4 + 4  =3</span></span><br><span class="line">        <span class="comment">// 13 = 4 + 9 =2</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i;<span class="comment">// 所有的都用1表示的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="keyword">int</span>) Math.sqrt(i); j++) &#123;</span><br><span class="line">                <span class="comment">// 4的话，1 1 1 4,这是一轮算下来，当前数最小表示的是多少</span></span><br><span class="line">                <span class="comment">// 利用用1表示的所有，与自己之前j平方大小的数+1(即j)这个数相比较谁小取谁</span></span><br><span class="line">                r = Math.min(r, res[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-127-Word-Ladder"><a href="#Leetcode-127-Word-Ladder" class="headerlink" title="Leetcode 127 Word Ladder"></a>Leetcode 127 Word Ladder</h4><blockquote>
<p>单词接龙</p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br> 转换过程中的中间单词必须是字典中的单词。<br> 说明:</p>
<p>如果不存在这样的转换序列，返回 0。<br> 所有单词具有相同的长度。<br> 所有单词只由小写字母组成。<br> 字典中不存在重复的单词。<br> 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br> 示例 1:</p>
<p>输入:<br> beginWord = “hit”,<br> endWord = “cog”,<br> wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出: 5</p>
<p>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br> 返回它的长度 5。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/word-ladder" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>这一题整体的思路是：通过set数据结构去重复，然后通过遍历来获取，如果变换所有的都不再wordlist中只能说明当前的元素不可通过中间值转换，如果可以转换的话，依次替换字符串每个位置的元素进行替换，判断是否能够存在于end中，不存在继续往后走，每次的start都选择少的哪一个！有利于减少判断次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 127 单词接龙</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 不存在的话直接为0</span></span><br><span class="line">       <span class="keyword">if</span> (!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Set&lt;String&gt; start = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; word = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">       String template = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">       <span class="keyword">char</span>[] array = template.toCharArray();</span><br><span class="line">       <span class="comment">// 有一个终止条件是什么呢？</span></span><br><span class="line">       start.add(beginWord);</span><br><span class="line">       end.add(endWord);</span><br><span class="line">       <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!start.isEmpty()) &#123;</span><br><span class="line">           step++;</span><br><span class="line">           Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           word.removeAll(start);<span class="comment">// 移除所有使用过的元素</span></span><br><span class="line">           <span class="keyword">for</span> (String s : start) &#123;</span><br><span class="line">               <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">char</span> tmp = chars[i];</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                       <span class="comment">// 相等直接跳过</span></span><br><span class="line">                       <span class="keyword">if</span> (tmp == array[j]) <span class="keyword">continue</span>;</span><br><span class="line">                       <span class="comment">// 否则交换</span></span><br><span class="line">                       chars[i] = array[j];</span><br><span class="line">                       String tempStr = <span class="keyword">new</span> String(chars);</span><br><span class="line">                       <span class="keyword">if</span> (word.contains(tempStr)) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (end.contains(tempStr)) &#123;</span><br><span class="line">                               <span class="keyword">return</span> step;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 这里面存放的表示当前可以作为中转的字符</span></span><br><span class="line">                               tempSet.add(tempStr);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   chars[i] = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 从少的那边开始计算</span></span><br><span class="line">           <span class="keyword">if</span> (tempSet.size() &lt; end.size()) &#123;</span><br><span class="line">               start = tempSet;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               start = end;</span><br><span class="line">               end = tempSet;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用递归来处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLengthII</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Set&lt;String&gt; start = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; word = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">       start.add(beginWord);</span><br><span class="line">       end.add(endWord);</span><br><span class="line">       <span class="keyword">return</span> executeLadder(start, end, word, <span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeLadder</span><span class="params">(Set&lt;String&gt; start, Set&lt;String&gt; end, Set&lt;String&gt; word, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 这个就是终止条件，一旦为0，表示所有替换的都不再word中，即不可转换</span></span><br><span class="line">       <span class="keyword">if</span> (start.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (start.size() &gt; end.size()) &#123; <span class="comment">// 永远以小端查询大端，减少比对次数</span></span><br><span class="line">           <span class="keyword">return</span> executeLadder(end, start, word, res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果不小于0的话继续</span></span><br><span class="line">       word.removeAll(start);<span class="comment">// 移除使用过的</span></span><br><span class="line">       Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String s : start) &#123; <span class="comment">// 遍历所有的</span></span><br><span class="line">           <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">               <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (temp == c) <span class="keyword">continue</span>;</span><br><span class="line">                   chars[i] = c;</span><br><span class="line">                   String tempStr = <span class="keyword">new</span> String(chars);</span><br><span class="line">                   <span class="comment">// 一定要在word中才有机会往下走</span></span><br><span class="line">                   <span class="keyword">if</span> (word.contains(tempStr)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (end.contains(tempStr)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> res;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           tempSet.add(tempStr);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               chars[i] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 默认把tempSet当做start，因为前面已经有做判断</span></span><br><span class="line">       <span class="keyword">return</span> executeLadder(tempSet, end, word, res + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-126-Word-Ladder-II"><a href="#Leetcode-126-Word-Ladder-II" class="headerlink" title="Leetcode 126 Word Ladder II"></a>Leetcode 126 Word Ladder II</h4><blockquote>
<p>单词接龙II</p>
</blockquote>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="Leetcode-347-Top-K-Frequent-Elements"><a href="#Leetcode-347-Top-K-Frequent-Elements" class="headerlink" title="Leetcode 347 Top K Frequent Elements"></a>Leetcode 347 Top K Frequent Elements</h4><blockquote>
<p>使用优先队列来维护</p>
<p>1.排序取前k个，时间复杂度O(nlogn)</p>
<p>2.维护优先队列，时间复杂度O(nlogk)</p>
<p>3.维护优先队列，时间复杂度O(nlog(n-k))</p>
</blockquote>
<h4 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h4><h2 id="二叉树和递归"><a href="#二叉树和递归" class="headerlink" title="二叉树和递归"></a>二叉树和递归</h2><blockquote>
<p>递归两部分：</p>
<ol>
<li><p>递归终止条件</p>
</li>
<li><p>递归的运算过程</p>
</li>
</ol>
</blockquote>
<h4 id="Leetcode-104-Maximum-Depth-of-Binary-Tree"><a href="#Leetcode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 104 Maximum Depth of Binary Tree"></a>Leetcode 104 Maximum Depth of Binary Tree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> executeMaxDepth(root, depth);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeMaxDepth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 左边一直向下知道最后，依次+1，右边一直向下，依次+1</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(executeMaxDepth(root.left, depth), executeMaxDepth(root.right, depth)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-111-Minimum-Depth-of-Binary-Tree"><a href="#Leetcode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 111 Minimum Depth of Binary Tree"></a>Leetcode 111 Minimum Depth of Binary Tree</h4><blockquote>
<p>求的最短的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> executeMinDepth(root, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeMinDepth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要保证一定是叶子节点，如果不是叶子节点也不可行</span></span><br><span class="line">        <span class="comment">// 只管一边即可如果有不为null的,只需要考虑一边即可</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + executeMinDepth(root.right, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + executeMinDepth(root.left, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两边同时不为null，才有资格往下走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(executeMinDepth(root.left, depth), executeMinDepth(root.right, depth));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-226-Invert-Binary-Tree"><a href="#Leetcode-226-Invert-Binary-Tree" class="headerlink" title="Leetcode 226 Invert Binary Tree"></a>Leetcode 226 Invert Binary Tree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 否则进行左右交换</span></span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = temp;</span><br><span class="line">        root.left = invertTree(root.left);</span><br><span class="line">        root.right = invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-100-Same-Tree"><a href="#Leetcode-100-Same-Tree" class="headerlink" title="Leetcode 100 Same Tree"></a>Leetcode 100 Same Tree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断两棵树是否相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 开始比较,从头开始，延伸到左右节点</span></span><br><span class="line">       <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-101-Symmetric-Tree"><a href="#Leetcode-101-Symmetric-Tree" class="headerlink" title="Leetcode 101 Symmetric Tree"></a>Leetcode 101 Symmetric Tree</h4><blockquote>
<p>对称二叉树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前数是否是对称树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">return</span> judgementSymmetric(root.left, root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgementSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 判断当前是否相等，然后判断左边的左是否等于右边的右，反之亦然</span></span><br><span class="line">       <span class="keyword">return</span> left.val == right.val &amp;&amp; judgementSymmetric(left.left, right.right)</span><br><span class="line">               &amp;&amp; judgementSymmetric(left.right, right.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-222-Count-Complete-Tree-Nodes"><a href="#Leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="Leetcode 222 Count Complete Tree Nodes"></a>Leetcode 222 Count Complete Tree Nodes</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 完全二叉树的节点个数</span></span><br><span class="line"><span class="comment">    * 第一种方法如下，但是这种做法没有利用到完全二叉树的性质</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       count += <span class="number">1</span>;</span><br><span class="line">       count += countNodes(root.left);</span><br><span class="line">       count += countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第二种方法就是借助左右子树的高度来判断</span></span><br><span class="line"><span class="comment">    * 借助计算公式(2^h-1)来判断当前的节点个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes_II</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> l = getDepth(root.left);</span><br><span class="line">       <span class="keyword">int</span> r = getDepth(root.right);</span><br><span class="line">       <span class="comment">// 这边表示，如果左边大于右边，表示右边一定是满的，所以去查找左边</span></span><br><span class="line">       <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; r) - <span class="number">1</span> + countNodes(root.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 否则只能相等了，以为不可能右边大于左边的,相等的情况，左边一定是满的</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; l) - <span class="number">1</span> + countNodes(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 由于是完全二叉树，高度完全取决于左边节点</span></span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">           res++;</span><br><span class="line">           root = root.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-110-Balanced-Binary-Tree"><a href="#Leetcode-110-Balanced-Binary-Tree" class="headerlink" title="Leetcode 110 Balanced Binary Tree"></a>Leetcode 110 Balanced Binary Tree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 判断左右高度，然后分别判断左右高度就好了</span></span><br><span class="line">       <span class="keyword">return</span> Math.abs(getDepthII(root.left) - getDepthII(root.right)) &lt;= <span class="number">1</span></span><br><span class="line">               &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepthII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(getDepthII(root.left), getDepthII(root.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-112-Path-Sum"><a href="#Leetcode-112-Path-Sum" class="headerlink" title="Leetcode 112 Path Sum"></a>Leetcode 112 Path Sum</h4><blockquote>
<p>二叉树和为Sum的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 路径总和就是判断是否有当前路径+起来的等于指定和的分支</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果往后一直都没有为0的话，而root又到了null，此时直接返回false</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 但凡能满足的都会在这里被拦截</span></span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> sum - root.val == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向左向右走</span></span><br><span class="line">      <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-404-Sum-of-Left-Leaves"><a href="#Leetcode-404-Sum-of-Left-Leaves" class="headerlink" title="Leetcode 404 Sum of Left Leaves"></a>Leetcode 404 Sum of Left Leaves</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 404. 计算左叶子的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> execute(root, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边表示是左树即true，如果是右边的话使用false</span></span><br><span class="line">        sum += execute(root.left, <span class="keyword">true</span>);</span><br><span class="line">        sum += execute(root.right, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 看评论别人的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeavesII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += sumOfLeftLeaves(root.left);</span><br><span class="line">        sum += sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-257-Binary-Tree-Paths"><a href="#Leetcode-257-Binary-Tree-Paths" class="headerlink" title="Leetcode 257 Binary Tree Paths"></a>Leetcode 257 Binary Tree Paths</h4><blockquote>
<p>二叉树的所有路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树的所有路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">       executeBinaryTreePaths(root, res, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeBinaryTreePaths</span><span class="params">(TreeNode root, List&lt;String&gt; res, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       sb.append(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           res.add(sb.toString());<span class="comment">// 这是最终的归宿</span></span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder append = sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">       <span class="comment">// 否则的话，依旧要继续衔接下去，要回到最初始的状态,所以构造新的对象，否则对象sb会被复用</span></span><br><span class="line">       executeBinaryTreePaths(root.left,res,<span class="keyword">new</span> StringBuilder(append));</span><br><span class="line">       executeBinaryTreePaths(root.right,res,<span class="keyword">new</span> StringBuilder(append));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-113-Path-Sum-II"><a href="#Leetcode-113-Path-Sum-II" class="headerlink" title="Leetcode 113 Path Sum II"></a>Leetcode 113 Path Sum II</h4><h4 id="Leetcode-129-Sum-Root-to-Leaf-Numbers"><a href="#Leetcode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="Leetcode 129 Sum Root to Leaf Numbers"></a>Leetcode 129 Sum Root to Leaf Numbers</h4><h3 id="更加复杂的递归逻辑"><a href="#更加复杂的递归逻辑" class="headerlink" title="更加复杂的递归逻辑"></a>更加复杂的递归逻辑</h3><h4 id="Leetcode-437-Path-Sum-III"><a href="#Leetcode-437-Path-Sum-III" class="headerlink" title="Leetcode 437 Path Sum III"></a>Leetcode 437 Path Sum III</h4><blockquote>
<p>含有子递归</p>
</blockquote>
<h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><h4 id="Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Leetcode 235 Lowest Common Ancestor of a Binary Search Tree"></a>Leetcode 235 Lowest Common Ancestor of a Binary Search Tree</h4><blockquote>
<p>二分搜索树的最近公共祖先</p>
</blockquote>
<h4 id="Leetcode-98-Validate-Binary-Search-Tree"><a href="#Leetcode-98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode 98 Validate Binary Search Tree"></a>Leetcode 98 Validate Binary Search Tree</h4><h4 id="Leetcode-450-Delete-Node-in-a-BST"><a href="#Leetcode-450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode 450 Delete Node in a BST"></a>Leetcode 450 Delete Node in a BST</h4><blockquote>
<p>删除二分搜索树的节点</p>
</blockquote>
<h4 id="Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Leetcode 108 Convert Sorted Array to Binary Search Tree"></a>Leetcode 108 Convert Sorted Array to Binary Search Tree</h4><h4 id="Leetcode-230-Kth-Smallest-Element-in-a-BST"><a href="#Leetcode-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="Leetcode 230 Kth Smallest Element in a BST"></a>Leetcode 230 Kth Smallest Element in a BST</h4><h4 id="Leetcode-236-Lowest-Common-Ancestor-of-a-Search-Tree（LCA问题）"><a href="#Leetcode-236-Lowest-Common-Ancestor-of-a-Search-Tree（LCA问题）" class="headerlink" title="Leetcode 236 Lowest Common Ancestor of a Search Tree（LCA问题）"></a>Leetcode 236 Lowest Common Ancestor of a Search Tree（LCA问题）</h4><blockquote>
<p>二叉树的最近公共祖先</p>
</blockquote>
<h2 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h2><h3 id="回溯法解决排列问题"><a href="#回溯法解决排列问题" class="headerlink" title="回溯法解决排列问题"></a>回溯法解决排列问题</h3><h4 id="Leetcode-17-Letter-Combinations-of-a-Phone-Number"><a href="#Leetcode-17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Leetcode 17 Letter Combinations of a Phone Number"></a>Leetcode 17 Letter Combinations of a Phone Number</h4><blockquote>
<p>电话号码的字母组合</p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<p>输入：”23”<br> 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>利用递归进行处理，在遍历过程中采用递归，即可，因为是需要多重组合，只需要依次遍历即可获取到多重组合。终止条件需要判断拼凑的s是否与原字符的长度相等，相等即终止！可以将其画成树，会更好理解。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private String[] letters &#x3D; new String[]&#123;&quot; &quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">private List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">  res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (digits.length() &lt; 1) &#123;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  findCombinations(digits, 0, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void findCombinations(String digits, int index, String s) &#123;</span><br><span class="line">  &#x2F;&#x2F; s的长度一定是要与digits长度相同</span><br><span class="line">  if (s.length() &#x3D;&#x3D; digits.length()) &#123;</span><br><span class="line">    res.add(s);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  char c &#x3D; digits.charAt(index);</span><br><span class="line">  String letter &#x3D; letters[c - &#39;0&#39;];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; letter.length(); i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归下去</span><br><span class="line">    findCombinations(digits, index + 1, s + letter.charAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-93-Restore-IP-Addresses"><a href="#Leetcode-93-Restore-IP-Addresses" class="headerlink" title="Leetcode 93 Restore IP Addresses"></a>Leetcode 93 Restore IP Addresses</h4><h4 id="Leetcode-131-Palindrome-Partitioning"><a href="#Leetcode-131-Palindrome-Partitioning" class="headerlink" title="Leetcode 131 Palindrome Partitioning"></a>Leetcode 131 Palindrome Partitioning</h4><h4 id="Leetcode-46-Permutations"><a href="#Leetcode-46-Permutations" class="headerlink" title="Leetcode 46 Permutations"></a>Leetcode 46 Permutations</h4><blockquote>
<p>全排列</p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路：</p>
<p>一般回溯法都是结合递归，最好使用树的形式来画出递归的情况，很容易就出来了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; perRes;</span><br><span class="line">private boolean[] used;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">  perRes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  used &#x3D; new boolean[nums.length];</span><br><span class="line">  if (nums.length &lt; 1) return perRes;</span><br><span class="line">  generatePermute(nums, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line">  return perRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generatePermute(int[] nums, int index, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  &#x2F;&#x2F; 终止条件也就是当前的list入结果集</span><br><span class="line">  if (list.size() &#x3D;&#x3D; nums.length) &#123;</span><br><span class="line">    perRes.add(new ArrayList&lt;&gt;(list));&#x2F;&#x2F; 注意这里的添加需要将其组合为list，否则会为null</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话需要继续进行递归操作</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证每一次递归的每一个变量的唯一性</span><br><span class="line">    if (!used[i]) &#123;</span><br><span class="line">      list.add(nums[i]);</span><br><span class="line">      used[i] &#x3D; true;</span><br><span class="line">      generatePermute(nums, index, list);</span><br><span class="line">      &#x2F;&#x2F; 递归调用完毕之后需要回溯</span><br><span class="line">      list.remove(list.size() - 1);</span><br><span class="line">      used[i] &#x3D; false; &#x2F;&#x2F; 释放为可用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-47-Permutations-II"><a href="#Leetcode-47-Permutations-II" class="headerlink" title="Leetcode 47 Permutations II"></a>Leetcode 47 Permutations II</h4><h3 id="回溯法解决组合问题"><a href="#回溯法解决组合问题" class="headerlink" title="回溯法解决组合问题"></a>回溯法解决组合问题</h3><h4 id="Leetcode-77-Combinations"><a href="#Leetcode-77-Combinations" class="headerlink" title="Leetcode 77 Combinations"></a>Leetcode 77 Combinations</h4><blockquote>
<p>组合</p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>组合与排列不同，但是底层都是递归结合回溯操作来使得递归持续进行下去。还是画图比较可靠。</p>
<p>时间复杂度：O(kCkn)，空间复杂度：O(Ckn)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; resCombine;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组合</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">  resCombine &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (n &lt;&#x3D; 0 || k &lt;&#x3D; 0 || k &gt; n) return resCombine;</span><br><span class="line">  &#x2F;&#x2F; 注意index从1开始</span><br><span class="line">  generateCombine(n, 1, k, new ArrayList&lt;Integer&gt;());</span><br><span class="line">  return resCombine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generateCombine(int n, int index, int k, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  if (list.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">    resCombine.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话需要进行递归操作</span><br><span class="line">  &#x2F;&#x2F; 由于到了最后的元素地方，可以不用计算，俗称剪枝操作</span><br><span class="line">  &#x2F;&#x2F; 到了这里需要填补的数据个数为k-list.size()，即[i...n]还缺k-list.size个元素</span><br><span class="line">  &#x2F;&#x2F; 此时总数为n，则可以得到i的范围为n-(k-list.size)+1</span><br><span class="line">  for (int i &#x3D; index; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">    generateCombine(n, i + 1, k, list);</span><br><span class="line">    &#x2F;&#x2F; 进行回溯操作</span><br><span class="line">    list.remove(list.size() - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回溯法的剪枝"><a href="#回溯法的剪枝" class="headerlink" title="回溯法的剪枝"></a>回溯法的剪枝</h3><blockquote>
<p>剪枝就是剪去无意义的那些处理数据。</p>
<p>上述组合问题，剪枝操作之后，击败99.48%，优化了时间</p>
</blockquote>
<h4 id="Leetcode-39-Combination-Sum"><a href="#Leetcode-39-Combination-Sum" class="headerlink" title="Leetcode 39 Combination Sum"></a>Leetcode 39 Combination Sum</h4><h4 id="Leetcode-40-Combination-Sum-II"><a href="#Leetcode-40-Combination-Sum-II" class="headerlink" title="Leetcode 40 Combination Sum II"></a>Leetcode 40 Combination Sum II</h4><h4 id="Leetcode-216-Combination-Sum-III"><a href="#Leetcode-216-Combination-Sum-III" class="headerlink" title="Leetcode 216 Combination Sum III"></a>Leetcode 216 Combination Sum III</h4><h4 id="Leetcode-78-Subsets"><a href="#Leetcode-78-Subsets" class="headerlink" title="Leetcode 78 Subsets"></a>Leetcode 78 Subsets</h4><h4 id="Leetcode-90-Subsets-II"><a href="#Leetcode-90-Subsets-II" class="headerlink" title="Leetcode 90 Subsets II"></a>Leetcode 90 Subsets II</h4><h4 id="Leetcode-401-Binary-Watch"><a href="#Leetcode-401-Binary-Watch" class="headerlink" title="Leetcode 401 Binary Watch"></a>Leetcode 401 Binary Watch</h4><h3 id="二维平面上使用回溯法"><a href="#二维平面上使用回溯法" class="headerlink" title="二维平面上使用回溯法"></a>二维平面上使用回溯法</h3><h4 id="Leetcode-79-Word-Search"><a href="#Leetcode-79-Word-Search" class="headerlink" title="Leetcode 79 Word Search"></a>Leetcode 79 Word Search</h4><blockquote>
<p>单词搜索</p>
<p>利用偏移量数组来处理二维平面中的算法题</p>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<p>给定 word = “ABCCED”, 返回 true<br> 给定 word = “SEE”, 返回 true<br> 给定 word = “ABCB”, 返回 false</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/word-search" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先明确此题是需要进行递归回溯操作的，但是注意，由于起始点并不一定是初始点，此时需要根据状态的信息进行一个遍历，对所有的起始点进行一个遍历操作，看看是否能获取答案。其次，由于路径不可复用，此时需要设置一个访问visited的全局变量，控制同一位置的二次访问。注意由于需要保持回溯的性质，当返回false的时候，需要将当前访问状态置为false（visited是全局变量）。</p>
<p>递归的终止条件即当index为单词最后一个字符的下标时，此时返回是否找到。执行过程的话，首先需要判断有没有满足初始入口，如果不满足，直接返回false。满足的话，此时就拥有了四种属性，上下左右查找，看看四个方向是否有满足的。此时一般使用偏移量数组来表示上下左右的相对关系。遍历四个方向，每一个方向使用递归。边界条件是不能够越界(行列)且没有访问过。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private int m;</span><br><span class="line">private int n;</span><br><span class="line">private int[][] offset &#x3D; new int[][]&#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">private boolean[][] visited;</span><br><span class="line"></span><br><span class="line">public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">  &#x2F;&#x2F; 行列</span><br><span class="line">  m &#x3D; board.length;</span><br><span class="line">  n &#x3D; board[0].length;</span><br><span class="line">  visited &#x3D; new boolean[m][n];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 进入递归过程</span><br><span class="line">      if (searchWord(board, word, 0, i, j)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean searchWord(char[][] board, String word, int index, int startx, int starty) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if (index &#x3D;&#x3D; word.length() - 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要判断最后的字符是否相等</span><br><span class="line">    return board[startx][starty] &#x3D;&#x3D; word.charAt(index);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话此时需要判断上下左右，但是判断之前需要看当前的startx与starty是否满足条件</span><br><span class="line">  &#x2F;&#x2F; 且需要排除访问过的字符</span><br><span class="line">  &#x2F;&#x2F; 此时需要对上下左右进行查找</span><br><span class="line">  &#x2F;&#x2F; 相等的时候才进来，否则直接返回false，证明当前字母不符合条件</span><br><span class="line">  if (word.charAt(index) &#x3D;&#x3D; board[startx][starty]) &#123;</span><br><span class="line">    visited[startx][starty] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里的startx与starty应该保持不变，否则回来的时候值就发生了辩护有</span><br><span class="line">      int x &#x3D; startx + offset[i][0];</span><br><span class="line">      int y &#x3D; starty + offset[i][1];</span><br><span class="line">      &#x2F;&#x2F; 在其中进行查找</span><br><span class="line">      &#x2F;&#x2F; 如果在其中，且没有访问过，且能够找到一条路径，返回true</span><br><span class="line">      &#x2F;&#x2F; 如果在其中，且没有访问过，不能够找到一条路径，此时需要回溯</span><br><span class="line">      if (inArea(x, y) &amp;&amp; !visited[x][y]) &#123;</span><br><span class="line">        if (searchWord(board, word, index + 1, x, y)) &#123;</span><br><span class="line">          &#x2F;&#x2F; 成功才有机会进入，返回true</span><br><span class="line">          return true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  visited[startx][starty] &#x3D; false;&#x2F;&#x2F; 返回false的话就需要释放</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean inArea(int x, int y) &#123;</span><br><span class="line">  return x &gt;&#x3D; 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floodfill算法-经典问题"><a href="#floodfill算法-经典问题" class="headerlink" title="floodfill算法-经典问题"></a>floodfill算法-经典问题</h3><blockquote>
<p>寓意洪水泛滥，即水的漫延</p>
</blockquote>
<h4 id="Leecode-200-Number-of-Islands"><a href="#Leecode-200-Number-of-Islands" class="headerlink" title="Leecode 200 Number of Islands"></a>Leecode 200 Number of Islands</h4><blockquote>
<p>岛屿数量</p>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br> 11110<br> 11010<br> 11000<br> 00000</p>
<p>输出: 1<br> 示例 2:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>凡递归必有终止条件，只是终止条件与执行过程中的判断会有重复，可以省略终止条件。</p>
<p>这里的思路就是只要是有效的1，就算作岛屿。然后将其连接的所有1都做上标记。此时就类似于洪水漫延的感觉，转换思路，只留下有效的1作为岛屿数量！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 为1则为岛屿</span><br><span class="line">private int row;</span><br><span class="line">private int col;</span><br><span class="line">private int[][] d &#x3D; new int[][]&#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">  row &#x3D; grid.length;</span><br><span class="line">  if (row &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有元素</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  col &#x3D; grid[0].length;</span><br><span class="line">  visit &#x3D; new boolean[row][col];</span><br><span class="line">  int num &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; col; j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有访问过，且最后找到了岛屿，则数量加一</span><br><span class="line">      &#x2F;&#x2F; 这里转换思路，只需要将递归的过程设置为标记的过程即可。</span><br><span class="line">      if (!visit[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        findIslands(grid, i, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void findIslands(char[][] grid, int row, int col) &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里的递归终止条件，当前点四个方向都被访问了，或者四周都已经被使用了</span><br><span class="line">  visit[row][col] &#x3D; true;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">    int x &#x3D; row + d[i][0];</span><br><span class="line">    int y &#x3D; col + d[i][1];</span><br><span class="line">    &#x2F;&#x2F; 递归终止条件-&gt;包含在当前的判断条件中了</span><br><span class="line">    if (inLandArea(x, y) &amp;&amp; !visit[x][y] &amp;&amp; grid[row][col] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">      findIslands(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean inLandArea(int x, int y) &#123;</span><br><span class="line">  return x &gt;&#x3D; 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-130-Surrounded-Regions"><a href="#Leetcode-130-Surrounded-Regions" class="headerlink" title="Leetcode 130 Surrounded Regions"></a>Leetcode 130 Surrounded Regions</h4><h4 id="Leetcode-417-Pacific-Atlantic-Water-Flow"><a href="#Leetcode-417-Pacific-Atlantic-Water-Flow" class="headerlink" title="Leetcode 417 Pacific Atlantic Water Flow"></a>Leetcode 417 Pacific Atlantic Water Flow</h4><h3 id="回溯法是经典人工智能的基础"><a href="#回溯法是经典人工智能的基础" class="headerlink" title="回溯法是经典人工智能的基础"></a>回溯法是经典人工智能的基础</h3><h4 id="Leetcode-52-N-Queens"><a href="#Leetcode-52-N-Queens" class="headerlink" title="Leetcode 52 N-Queens"></a>Leetcode 52 N-Queens</h4><blockquote>
<p>递归+回溯+剪枝+相关优化思路</p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<p>输入: 4<br> 输出: [<br> [“.Q..”,  // 解法 1<br> “…Q”,<br> “Q…”,<br> “..Q.”],</p>
<p>[“..Q.”,  // 解法 2<br> “Q…”,<br> “…Q”,<br> “.Q..”]<br> ]<br> 解释: 4 皇后问题存在两个不同的解法。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>也是利用递归回溯进行相应的查找，每次查找需要避开同一行，同一列的相同。同一行的相同再遍历过程中可以避免，同一列的话使用全局变量保存是否已经放置了元素。对角线的话，根据给出的00 01 02 03可以发现有两种对角线，一种自上而下，一种自下而上，都有规律，一种x+y都相同，一种x-y都相同，以此避免在对角线上取到相同的。最后每次到最后，就将当前的位置信息变换为String的list结构存入即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每一行每一列都不能有相同的</span><br><span class="line">private boolean[] col;</span><br><span class="line">&#x2F;&#x2F; 两个对角线</span><br><span class="line">private boolean[] dia1;</span><br><span class="line">private boolean[] dia2;</span><br><span class="line">private List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">  col &#x3D; new boolean[n];</span><br><span class="line">  &#x2F;&#x2F; 总共有七条对角线</span><br><span class="line">  dia1 &#x3D; new boolean[2 * n - 1];</span><br><span class="line">  dia2 &#x3D; new boolean[2 * n - 1];</span><br><span class="line">  res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  putNQueen(n, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void putNQueen(int n, int index, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  if (index &#x3D;&#x3D; n) &#123;</span><br><span class="line">    List&lt;String&gt; strings &#x3D; generateString(n,new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">    res.add(strings);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 开始遍历</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 一行一列是false，两条对角线都是false即可</span><br><span class="line">    &#x2F;&#x2F; index-i本来是表示斜对角线上的点，但是由于index-i可能会出现负数的情况</span><br><span class="line">    &#x2F;&#x2F; 可以得到index-i+n-1可以保证没有负数</span><br><span class="line">    if (!col[i] &amp;&amp; !dia1[index + i] &amp;&amp; !dia2[index - i + n - 1]) &#123;</span><br><span class="line">      &#x2F;&#x2F; 变化为已经被占用</span><br><span class="line">      col[i] &#x3D; true;</span><br><span class="line">      dia1[index + i] &#x3D; true;</span><br><span class="line">      dia2[index - i + n - 1] &#x3D; true;</span><br><span class="line">      list.add(i);</span><br><span class="line">      &#x2F;&#x2F; 继续递归查找下一行</span><br><span class="line">      putNQueen(n, index + 1, list);</span><br><span class="line">      &#x2F;&#x2F; 回溯，需要恢复以及list需要删除最后元素</span><br><span class="line">      col[i] &#x3D; false;</span><br><span class="line">      dia1[index + i] &#x3D; false;</span><br><span class="line">      dia2[index - i + n - 1] &#x3D; false;</span><br><span class="line">      list.remove(list.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; list中存放的是每一行可以放的坐标</span><br><span class="line">private List&lt;String&gt; generateString(int n,ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  List&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    sb.append(&quot;.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    strings.add(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    String s &#x3D; strings.get(i);</span><br><span class="line">    StringBuilder stringBuilder &#x3D; new StringBuilder(s);</span><br><span class="line">    stringBuilder.setCharAt(list.get(i),&#39;Q&#39;);</span><br><span class="line">    strings.remove(i);</span><br><span class="line">    strings.add(i,stringBuilder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  return strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-52-N-Queens-II"><a href="#Leetcode-52-N-Queens-II" class="headerlink" title="Leetcode 52 N-Queens II"></a>Leetcode 52 N-Queens II</h4><h4 id="Leetcode-37-Sudoku-Solver"><a href="#Leetcode-37-Sudoku-Solver" class="headerlink" title="Leetcode 37 Sudoku Solver"></a>Leetcode 37 Sudoku Solver</h4><blockquote>
<p>数独问题+相关优化思路</p>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>记忆化搜索：自上而下的方法</p>
<p>动态规划：直接使用循环，使用的是自下而上的方法，一般可以使用自上而下解决的问题都可以使用自下而上的方法解决</p>
<p>一般先使用自上而下思考，最后使用动态规划自下而上编码解决问题</p>
</blockquote>
<h4 id="Leetcode-70-Climbing-Stairs"><a href="#Leetcode-70-Climbing-Stairs" class="headerlink" title="Leetcode 70 Climbing Stairs"></a>Leetcode 70 Climbing Stairs</h4><h4 id="Leetcode-120-Triangle"><a href="#Leetcode-120-Triangle" class="headerlink" title="Leetcode 120 Triangle"></a>Leetcode 120 Triangle</h4><blockquote>
<p>又是一次失败的尝试！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过了，时间复杂度：O(n^2) 空间复杂度：O(n^2)</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">  &#x2F;&#x2F; 层数</span><br><span class="line">  int size &#x3D; triangle.size();</span><br><span class="line">  &#x2F;&#x2F; 上一个元素可以获得的下面元素为</span><br><span class="line">  &#x2F;&#x2F; 记录上一个元素的</span><br><span class="line">  int[][] dp &#x3D; new int[size][size];</span><br><span class="line">  dp[0][0] &#x3D; triangle.get(0).get(0);</span><br><span class="line">  int res &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; size; i++) &#123;</span><br><span class="line">    List&lt;Integer&gt; tempList &#x3D; triangle.get(i);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; tempList.size(); j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 第一个数的时候</span><br><span class="line">      if (j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将其直接与上一排第一个相加</span><br><span class="line">        dp[i][j] &#x3D; dp[i - 1][j] + tempList.get(j);</span><br><span class="line">      &#125; else if (j &#x3D;&#x3D; i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则将其与上排前一个相加，同等位置，下一排会往后延伸一位，所以往上需要j-1</span><br><span class="line">        dp[i][j] &#x3D; dp[i - 1][j - 1] + tempList.get(j);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则的话，则是处于中间段,此时计算上面相邻的两个即可</span><br><span class="line">        dp[i][j] &#x3D; Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + tempList.get(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 最后所有的结果都在二维数组最后一组数据中</span><br><span class="line">  for (int i &#x3D; 0; i &lt; dp[size - 1].length; i++) &#123;</span><br><span class="line">    res &#x3D; Math.min(dp[size - 1][i], res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于上述只与dp[i-1][j] dp【i-1][j-1]有关</span><br><span class="line">&#x2F;&#x2F; 用两个变量来存储上面的这两个变量</span><br><span class="line">public int minimumTotal1(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">  &#x2F;&#x2F; 层数</span><br><span class="line">  int size &#x3D; triangle.size();</span><br><span class="line">  &#x2F;&#x2F; 上一个元素可以获得的下面元素为</span><br><span class="line">  &#x2F;&#x2F; 记录上一个元素的</span><br><span class="line">  int[] dp &#x3D; new int[size];</span><br><span class="line">  dp[0] &#x3D; triangle.get(0).get(0);</span><br><span class="line">  int res &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  int prev &#x3D; 0;&#x2F;&#x2F; dp[i-1][j]</span><br><span class="line">  int cur &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; size; i++) &#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; triangle.get(i);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; list.size(); j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 表示向右移动</span><br><span class="line">      prev &#x3D; dp[j];</span><br><span class="line">      &#x2F;&#x2F; 每一个dp[j]记录的都是一个元素。总共有四层</span><br><span class="line">      if(j &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        dp[j] &#x3D; prev + list.get(j);</span><br><span class="line">      &#125;else if(j &#x3D;&#x3D; i)&#123;</span><br><span class="line">        dp[j] &#x3D; cur + list.get(j);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        dp[j] &#x3D; Math.min(prev,cur)+list.get(j);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 注意prev和cur需要向右移动</span><br><span class="line">      cur &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">    res &#x3D; Math.min(res, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-64-Minimum-Path-Sum"><a href="#Leetcode-64-Minimum-Path-Sum" class="headerlink" title="Leetcode 64 Minimum Path Sum"></a>Leetcode 64 Minimum Path Sum</h4><h4 id="Leetcode-343-Integer-Break"><a href="#Leetcode-343-Integer-Break" class="headerlink" title="Leetcode 343 Integer Break"></a>Leetcode 343 Integer Break</h4><h4 id="Leetcode-279-Perfect-Squares-1"><a href="#Leetcode-279-Perfect-Squares-1" class="headerlink" title="Leetcode 279 Perfect Squares"></a>Leetcode 279 Perfect Squares</h4><blockquote>
<p>使用动态规划解决</p>
</blockquote>
<h4 id="Leetcode-91-Decode-Ways"><a href="#Leetcode-91-Decode-Ways" class="headerlink" title="Leetcode 91 Decode Ways"></a>Leetcode 91 Decode Ways</h4><h4 id="Leetcode-62-Unique-Paths"><a href="#Leetcode-62-Unique-Paths" class="headerlink" title="Leetcode 62 Unique Paths"></a>Leetcode 62 Unique Paths</h4><h4 id="Leetcode-63-Unique-Paths-II"><a href="#Leetcode-63-Unique-Paths-II" class="headerlink" title="Leetcode 63 Unique Paths II"></a>Leetcode 63 Unique Paths II</h4><h3 id="状态及状态转移"><a href="#状态及状态转移" class="headerlink" title="状态及状态转移"></a>状态及状态转移</h3><h4 id="Leetcode-198-House-Robber"><a href="#Leetcode-198-House-Robber" class="headerlink" title="Leetcode 198 House Robber"></a>Leetcode 198 House Robber</h4><h4 id="Leetcode-213-House-Robber-II"><a href="#Leetcode-213-House-Robber-II" class="headerlink" title="Leetcode 213 House Robber II"></a>Leetcode 213 House Robber II</h4><h4 id="Leetcode-337-House-Robber-III"><a href="#Leetcode-337-House-Robber-III" class="headerlink" title="Leetcode 337 House Robber III"></a>Leetcode 337 House Robber III</h4><h4 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Leetcode 309 Best Time to Buy and Sell Stock with Cooldown"></a>Leetcode 309 Best Time to Buy and Sell Stock with Cooldown</h4><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><blockquote>
<p>记忆化搜索与动态规划来实现</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Id</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">weight</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">value</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">12</td>
</tr>
</tbody></table>
<blockquote>
<p>背包容量为5的背包，可以获取最大的价值为22</p>
</blockquote>
<blockquote>
<p>时间复杂度：O(n<em>C)  空间复杂度：O(n</em>C)</p>
</blockquote>
<h3 id="0-1背包问题的优化"><a href="#0-1背包问题的优化" class="headerlink" title="0-1背包问题的优化"></a>0-1背包问题的优化</h3><blockquote>
<p>主要是针对空间的优化</p>
</blockquote>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><blockquote>
<p>每个物体可以无限使用</p>
<p>多重背包问题：每个物品不止1个</p>
<p>多维费用背包问题：考虑物品的体积和重量两个维度</p>
<p>物品之间的相互约束；相互依赖</p>
</blockquote>
<h4 id="Leetcode-416-Partition-Equal-Subset-Sum"><a href="#Leetcode-416-Partition-Equal-Subset-Sum" class="headerlink" title="Leetcode 416 Partition Equal Subset Sum"></a>Leetcode 416 Partition Equal Subset Sum</h4><h4 id="Leetcoce-322-Coin-Change"><a href="#Leetcoce-322-Coin-Change" class="headerlink" title="Leetcoce 322 Coin Change"></a>Leetcoce 322 Coin Change</h4><h4 id="Leetcode-377-Combination-Sum-IV"><a href="#Leetcode-377-Combination-Sum-IV" class="headerlink" title="Leetcode 377 Combination Sum IV"></a>Leetcode 377 Combination Sum IV</h4><h4 id="Leetcode-474-Ones-and-Zeros"><a href="#Leetcode-474-Ones-and-Zeros" class="headerlink" title="Leetcode 474 Ones and Zeros"></a>Leetcode 474 Ones and Zeros</h4><h4 id="Leetcode-139-Word-Break"><a href="#Leetcode-139-Word-Break" class="headerlink" title="Leetcode 139 Word Break"></a>Leetcode 139 Word Break</h4><h4 id="Leetcode-494-Target-Sum"><a href="#Leetcode-494-Target-Sum" class="headerlink" title="Leetcode 494 Target Sum"></a>Leetcode 494 Target Sum</h4><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h4 id="Leetcode-300-Longest-Increasing-Subsequence"><a href="#Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode 300 Longest Increasing Subsequence"></a>Leetcode 300 Longest Increasing Subsequence</h4><h4 id="Leetcode-376-Wiggle-Subsequence"><a href="#Leetcode-376-Wiggle-Subsequence" class="headerlink" title="Leetcode 376 Wiggle Subsequence"></a>Leetcode 376 Wiggle Subsequence</h4><h3 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h3><h4 id="Leetcode-300-Longest-Common-Subsequence"><a href="#Leetcode-300-Longest-Common-Subsequence" class="headerlink" title="Leetcode 300 Longest Common Subsequence"></a>Leetcode 300 Longest Common Subsequence</h4><h3 id="Dijkstra单源最短路径算法也是动态规划"><a href="#Dijkstra单源最短路径算法也是动态规划" class="headerlink" title="Dijkstra单源最短路径算法也是动态规划"></a>Dijkstra单源最短路径算法也是动态规划</h3><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="简单贪心算法"><a href="#简单贪心算法" class="headerlink" title="简单贪心算法"></a>简单贪心算法</h3><blockquote>
<p>一般贪心算法与排序算法是紧密联系</p>
</blockquote>
<h4 id="Leetcode-455-Assign-Cookies"><a href="#Leetcode-455-Assign-Cookies" class="headerlink" title="Leetcode 455 Assign Cookies"></a>Leetcode 455 Assign Cookies</h4><h4 id="Leetcode-392-Is-Subsequence"><a href="#Leetcode-392-Is-Subsequence" class="headerlink" title="Leetcode 392 Is Subsequence"></a>Leetcode 392 Is Subsequence</h4><blockquote>
<p>思考解法与贪心算法那之间的联系</p>
</blockquote>
<h3 id="贪心算法与动态规划之间的关系"><a href="#贪心算法与动态规划之间的关系" class="headerlink" title="贪心算法与动态规划之间的关系"></a>贪心算法与动态规划之间的关系</h3><h4 id="Leetcode-435-Non-overlapping-Intervals"><a href="#Leetcode-435-Non-overlapping-Intervals" class="headerlink" title="Leetcode 435 Non-overlapping Intervals"></a>Leetcode 435 Non-overlapping Intervals</h4><h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><blockquote>
<p>如果不能使用贪心算法，只需要举出反例即可</p>
</blockquote>
<blockquote>
<p>如果无法举出反例，如何证明贪心算法的正确性？</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>课程是结束了，但是自己的练习之路还是没有结束，自己的练习可能才刚开始，这次算法视频是看完了，就如算法视频课程的老师所说，不能一味的追求Accepted的快感而忽视了自己的思考过程，确实是这样，但是很多时候自己确实是想不到这些东西该如何解决，加上自己性子比较急，但是我知道这些都不是理由和借口，真正的智商差距真的很小，但是每个人都事物追求的兴趣真的差距很大。</p>
<p>对于算法这件事情，之前的不自信都是因为算法感觉不太稳导致的不自信，美团的面试真的是让自己的不自信到达了一个低谷，所以算法在自己的心目中很重要的一个部分。现阶段，先解决这个课程的算法题，自己的Leetcode上刷的题目，大多数都是没有什么水平的，或者说是自己没有思考就直接看答案的，导致自己是速成了一些算法思想，但是没有实际的解决算法的能力与思考的维度有所差距。还是存在很大的问题的，现阶段的事情，需要自己慢慢的去思考，我希望的是具有一种融入思想中的融入骨子里的那种算法的感觉，而不是每一次都挠头然后一脸懵逼，看着答案才豁然开朗。每一个人来这个世界，都是为了实现自己的人生价值，没有上限，只有下限！</p>
<p>加油！</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/05/RocketMQ/" rel="prev" title="RocketMQ学习">
      <i class="fa fa-chevron-left"></i> RocketMQ学习
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NTExNi8yMTYzMw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法视频学习"><span class="nav-number">1.</span> <span class="nav-text">算法视频学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分法学习"><span class="nav-number">1.1.</span> <span class="nav-text">二分法学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Search"><span class="nav-number">1.1.1.</span> <span class="nav-text">Binary Search</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-283-Move-Zeros"><span class="nav-number">2.0.1.</span> <span class="nav-text">Leetcode 283 Move Zeros</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-27-Remove-Element"><span class="nav-number">2.0.2.</span> <span class="nav-text">Leetcode 27 Remove Element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-26-Remove-Duplicated-from-Sorted-Array"><span class="nav-number">2.0.3.</span> <span class="nav-text">Leetcode 26 Remove Duplicated from Sorted Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-80-Remove-Duplicated-frim-Sorted-Array-II"><span class="nav-number">2.0.4.</span> <span class="nav-text">Leetcode 80 Remove Duplicated frim Sorted Array II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-75-Sort-Colors"><span class="nav-number">2.0.5.</span> <span class="nav-text">Leetcode 75 Sort Colors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-88-Merge-Sorted-Array"><span class="nav-number">2.0.6.</span> <span class="nav-text">Leetcode 88 Merge Sorted Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-215-Kth-Largest-Element-in-an-Array"><span class="nav-number">2.0.7.</span> <span class="nav-text">Leetcode 215 Kth Largest Element in an Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双索引技术-对撞指针"><span class="nav-number">2.1.</span> <span class="nav-text">双索引技术-对撞指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-167-Two-Sum-II-Input-array-is-Sorted"><span class="nav-number">2.1.1.</span> <span class="nav-text">Leetcode 167 Two Sum II - Input array is Sorted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-125-Valid-Palindrome"><span class="nav-number">2.1.2.</span> <span class="nav-text">Leetcode 125 Valid Palindrome</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-344-Reverse-String"><span class="nav-number">2.1.3.</span> <span class="nav-text">Leetcode 344 Reverse String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-345-Reverse-Vowels-of-a-String"><span class="nav-number">2.1.4.</span> <span class="nav-text">Leetcode 345 Reverse Vowels of a String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-11-Container-With-Most-Water"><span class="nav-number">2.1.5.</span> <span class="nav-text">Leetcode 11 Container With Most Water</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双索引技术-滑动窗口"><span class="nav-number">2.2.</span> <span class="nav-text">双索引技术-滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-209-Minimum-Size-Subarray-Sum"><span class="nav-number">2.2.1.</span> <span class="nav-text">Leetcode 209 Minimum Size Subarray Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-3-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">2.2.2.</span> <span class="nav-text">Leetcode 3 Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-438-Find-All-Anagrams-in-a-String"><span class="nav-number">2.2.3.</span> <span class="nav-text">Leetcode 438 Find All Anagrams in a String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-76-Minimum-Window-Substring"><span class="nav-number">2.2.4.</span> <span class="nav-text">Leetcode 76 Minimum Window Substring</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找问题"><span class="nav-number">3.</span> <span class="nav-text">查找问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set和Map数据结构的使用"><span class="nav-number">3.1.</span> <span class="nav-text">Set和Map数据结构的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-349-Intersection-of-Two-Arrays"><span class="nav-number">3.1.1.</span> <span class="nav-text">Leetcode 349 Intersection of Two Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-350-Intersection-of-Two-Arrays"><span class="nav-number">3.1.2.</span> <span class="nav-text">Leetcode 350 Intersection of Two Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-242-Valid-Anagram"><span class="nav-number">3.1.3.</span> <span class="nav-text">Leetcode 242 Valid Anagram</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-202-Happy-Number"><span class="nav-number">3.1.4.</span> <span class="nav-text">Leetcode 202 Happy Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-290-Word-Pattern"><span class="nav-number">3.1.5.</span> <span class="nav-text">Leetcode 290 Word Pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-205-Isomorphic-Strings"><span class="nav-number">3.1.6.</span> <span class="nav-text">Leetcode 205 Isomorphic Strings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-451-Sort-Characters-By-Frequency"><span class="nav-number">3.1.7.</span> <span class="nav-text">Leetcode 451 Sort Characters By Frequency</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找表"><span class="nav-number">3.2.</span> <span class="nav-text">查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-1-Two-Sum"><span class="nav-number">3.2.1.</span> <span class="nav-text">Leetcode 1 Two Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-15-3Sum"><span class="nav-number">3.2.2.</span> <span class="nav-text">Leetcode 15 3Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-18-4Sum"><span class="nav-number">3.2.3.</span> <span class="nav-text">Leetcode 18 4Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-16-3Sum-Closet"><span class="nav-number">3.2.4.</span> <span class="nav-text">Leetcode 16 3Sum Closet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-454-4Sum-II"><span class="nav-number">3.2.5.</span> <span class="nav-text">Leetcode 454 4Sum II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-49-Group-Anagrams"><span class="nav-number">3.2.6.</span> <span class="nav-text">Leetcode 49 Group Anagrams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-447-Number-of-Boomerangs"><span class="nav-number">3.2.7.</span> <span class="nav-text">Leetcode 447 Number of Boomerangs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-149-Max-Points-on-a-Line"><span class="nav-number">3.2.8.</span> <span class="nav-text">Leetcode 149 Max Points on a Line</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口-查找表"><span class="nav-number">3.3.</span> <span class="nav-text">滑动窗口+查找表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-219-Contains-Duplicate-II"><span class="nav-number">3.3.1.</span> <span class="nav-text">Leetcode 219 Contains Duplicate II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-217-Contains-Duplicate"><span class="nav-number">3.3.2.</span> <span class="nav-text">Leetcode 217 Contains Duplicate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-220-Contains-Duplicate-III"><span class="nav-number">3.3.3.</span> <span class="nav-text">Leetcode 220 Contains Duplicate III</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">4.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-206-Reverse-Linked-List"><span class="nav-number">4.0.1.</span> <span class="nav-text">Leetcode 206 Reverse Linked List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-92-Reverse-Linked-List-II"><span class="nav-number">4.0.2.</span> <span class="nav-text">Leetcode 92 Reverse Linked List II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-83-Remove-Duplicates-from-Sorted-List"><span class="nav-number">4.0.3.</span> <span class="nav-text">Leetcode 83 Remove Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-86-Partition-List"><span class="nav-number">4.0.4.</span> <span class="nav-text">Leetcode 86 Partition List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-328-Odd-Even-Linked-List"><span class="nav-number">4.0.5.</span> <span class="nav-text">Leetcode 328 Odd Even Linked List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-2-Add-Two-Numbers"><span class="nav-number">4.0.6.</span> <span class="nav-text">Leetcode 2 Add Two Numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-445-Add-Two-Numbers-II"><span class="nav-number">4.0.7.</span> <span class="nav-text">Leetcode 445 Add Two Numbers II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设立链表虚拟头节点"><span class="nav-number">4.1.</span> <span class="nav-text">设立链表虚拟头节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-203-Remove-Linked-List-Elements"><span class="nav-number">4.1.1.</span> <span class="nav-text">Leetcode 203 Remove Linked List Elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-82-Remove-Linked-List-Elements-II"><span class="nav-number">4.1.2.</span> <span class="nav-text">Leetcode 82 Remove Linked List Elements II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-21-Merge-Two-Sorted-Lists"><span class="nav-number">4.1.3.</span> <span class="nav-text">Leetcode 21 Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-24-Swap-Nodes-in-Pairs"><span class="nav-number">4.1.4.</span> <span class="nav-text">Leetcode 24 Swap Nodes in Pairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-25-Reverse-Nodes-in-K-Group"><span class="nav-number">4.1.5.</span> <span class="nav-text">Leetcode 25 Reverse Nodes in K-Group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-147-Insertion-Sort-List"><span class="nav-number">4.1.6.</span> <span class="nav-text">Leetcode 147 Insertion Sort List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-148-Sort-List"><span class="nav-number">4.1.7.</span> <span class="nav-text">Leetcode 148 Sort List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-237-Delete-Node-in-a-Linked-List"><span class="nav-number">4.1.8.</span> <span class="nav-text">Leetcode 237 Delete Node in a Linked List</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表与双指针"><span class="nav-number">4.2.</span> <span class="nav-text">链表与双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">4.2.1.</span> <span class="nav-text">Leetcode 19 Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-61-Rotate-List"><span class="nav-number">4.2.2.</span> <span class="nav-text">Leetcode 61 Rotate List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-143-Reorder-List"><span class="nav-number">4.2.3.</span> <span class="nav-text">Leetcode 143 Reorder List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-234-Palindrome-Linked-List"><span class="nav-number">4.2.4.</span> <span class="nav-text">Leetcode 234 Palindrome Linked List</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列的使用"><span class="nav-number">5.</span> <span class="nav-text">栈和队列的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础的栈在算法中的使用"><span class="nav-number">5.1.</span> <span class="nav-text">基础的栈在算法中的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-20-Valid-Parentheses"><span class="nav-number">5.1.1.</span> <span class="nav-text">Leetcode 20 Valid Parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-150-Evaluate-Reverse-Polish-Notation"><span class="nav-number">5.1.2.</span> <span class="nav-text">Leetcode 150 Evaluate Reverse Polish Notation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-71-Simplify-Path"><span class="nav-number">5.1.3.</span> <span class="nav-text">Leetcode 71 Simplify Path</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈与递归的紧密关系"><span class="nav-number">5.2.</span> <span class="nav-text">栈与递归的紧密关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-144-Binary-Tree-Preorder-Taversal"><span class="nav-number">5.2.1.</span> <span class="nav-text">Leetcode 144 Binary Tree Preorder Taversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-94-Binary-Tree-Inorder-Traversal"><span class="nav-number">5.2.2.</span> <span class="nav-text">Leetcode 94 Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-145-Binary-Tree-Postorder-Traversal"><span class="nav-number">5.2.3.</span> <span class="nav-text">Leetcode 145 Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-341-Flatten-Nested-List-Iterator"><span class="nav-number">5.2.4.</span> <span class="nav-text">Leetcode 341 Flatten Nested List Iterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">5.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-102-Binary-Tree-Level-Order-Traversal"><span class="nav-number">5.3.1.</span> <span class="nav-text">Leetcode 102 Binary Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-107-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">5.3.2.</span> <span class="nav-text">Leetcode 107 Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="nav-number">5.3.3.</span> <span class="nav-text">Leetcode 103 Binary Tree Zigzag Level Order Traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-199-Binary-Tree-Right-Side-View"><span class="nav-number">5.3.4.</span> <span class="nav-text">Leetcode 199 Binary Tree Right Side View</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS和图的最短路径"><span class="nav-number">5.4.</span> <span class="nav-text">BFS和图的最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-279-Perfect-Squares"><span class="nav-number">5.4.1.</span> <span class="nav-text">Leetcode 279 Perfect Squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-127-Word-Ladder"><span class="nav-number">5.4.2.</span> <span class="nav-text">Leetcode 127 Word Ladder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-126-Word-Ladder-II"><span class="nav-number">5.4.3.</span> <span class="nav-text">Leetcode 126 Word Ladder II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先队列"><span class="nav-number">5.5.</span> <span class="nav-text">优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-347-Top-K-Frequent-Elements"><span class="nav-number">5.5.1.</span> <span class="nav-text">Leetcode 347 Top K Frequent Elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-23-Merge-k-Sorted-Lists"><span class="nav-number">5.5.2.</span> <span class="nav-text">Leetcode 23 Merge k Sorted Lists</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树和递归"><span class="nav-number">6.</span> <span class="nav-text">二叉树和递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">6.0.1.</span> <span class="nav-text">Leetcode 104 Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">6.0.2.</span> <span class="nav-text">Leetcode 111 Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-226-Invert-Binary-Tree"><span class="nav-number">6.0.3.</span> <span class="nav-text">Leetcode 226 Invert Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-100-Same-Tree"><span class="nav-number">6.0.4.</span> <span class="nav-text">Leetcode 100 Same Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-101-Symmetric-Tree"><span class="nav-number">6.0.5.</span> <span class="nav-text">Leetcode 101 Symmetric Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-222-Count-Complete-Tree-Nodes"><span class="nav-number">6.0.6.</span> <span class="nav-text">Leetcode 222 Count Complete Tree Nodes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-110-Balanced-Binary-Tree"><span class="nav-number">6.0.7.</span> <span class="nav-text">Leetcode 110 Balanced Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-112-Path-Sum"><span class="nav-number">6.0.8.</span> <span class="nav-text">Leetcode 112 Path Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-404-Sum-of-Left-Leaves"><span class="nav-number">6.0.9.</span> <span class="nav-text">Leetcode 404 Sum of Left Leaves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-257-Binary-Tree-Paths"><span class="nav-number">6.0.10.</span> <span class="nav-text">Leetcode 257 Binary Tree Paths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-113-Path-Sum-II"><span class="nav-number">6.0.11.</span> <span class="nav-text">Leetcode 113 Path Sum II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-129-Sum-Root-to-Leaf-Numbers"><span class="nav-number">6.0.12.</span> <span class="nav-text">Leetcode 129 Sum Root to Leaf Numbers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更加复杂的递归逻辑"><span class="nav-number">6.1.</span> <span class="nav-text">更加复杂的递归逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-437-Path-Sum-III"><span class="nav-number">6.1.1.</span> <span class="nav-text">Leetcode 437 Path Sum III</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分搜索树"><span class="nav-number">6.2.</span> <span class="nav-text">二分搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">6.2.1.</span> <span class="nav-text">Leetcode 235 Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-98-Validate-Binary-Search-Tree"><span class="nav-number">6.2.2.</span> <span class="nav-text">Leetcode 98 Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-450-Delete-Node-in-a-BST"><span class="nav-number">6.2.3.</span> <span class="nav-text">Leetcode 450 Delete Node in a BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-number">6.2.4.</span> <span class="nav-text">Leetcode 108 Convert Sorted Array to Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-230-Kth-Smallest-Element-in-a-BST"><span class="nav-number">6.2.5.</span> <span class="nav-text">Leetcode 230 Kth Smallest Element in a BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-236-Lowest-Common-Ancestor-of-a-Search-Tree（LCA问题）"><span class="nav-number">6.2.6.</span> <span class="nav-text">Leetcode 236 Lowest Common Ancestor of a Search Tree（LCA问题）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归与回溯"><span class="nav-number">7.</span> <span class="nav-text">递归与回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法解决排列问题"><span class="nav-number">7.1.</span> <span class="nav-text">回溯法解决排列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-17-Letter-Combinations-of-a-Phone-Number"><span class="nav-number">7.1.1.</span> <span class="nav-text">Leetcode 17 Letter Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-93-Restore-IP-Addresses"><span class="nav-number">7.1.2.</span> <span class="nav-text">Leetcode 93 Restore IP Addresses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-131-Palindrome-Partitioning"><span class="nav-number">7.1.3.</span> <span class="nav-text">Leetcode 131 Palindrome Partitioning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-46-Permutations"><span class="nav-number">7.1.4.</span> <span class="nav-text">Leetcode 46 Permutations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-47-Permutations-II"><span class="nav-number">7.1.5.</span> <span class="nav-text">Leetcode 47 Permutations II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法解决组合问题"><span class="nav-number">7.2.</span> <span class="nav-text">回溯法解决组合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-77-Combinations"><span class="nav-number">7.2.1.</span> <span class="nav-text">Leetcode 77 Combinations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法的剪枝"><span class="nav-number">7.3.</span> <span class="nav-text">回溯法的剪枝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-39-Combination-Sum"><span class="nav-number">7.3.1.</span> <span class="nav-text">Leetcode 39 Combination Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-40-Combination-Sum-II"><span class="nav-number">7.3.2.</span> <span class="nav-text">Leetcode 40 Combination Sum II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-216-Combination-Sum-III"><span class="nav-number">7.3.3.</span> <span class="nav-text">Leetcode 216 Combination Sum III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-78-Subsets"><span class="nav-number">7.3.4.</span> <span class="nav-text">Leetcode 78 Subsets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-90-Subsets-II"><span class="nav-number">7.3.5.</span> <span class="nav-text">Leetcode 90 Subsets II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-401-Binary-Watch"><span class="nav-number">7.3.6.</span> <span class="nav-text">Leetcode 401 Binary Watch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维平面上使用回溯法"><span class="nav-number">7.4.</span> <span class="nav-text">二维平面上使用回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-79-Word-Search"><span class="nav-number">7.4.1.</span> <span class="nav-text">Leetcode 79 Word Search</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floodfill算法-经典问题"><span class="nav-number">7.5.</span> <span class="nav-text">floodfill算法-经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leecode-200-Number-of-Islands"><span class="nav-number">7.5.1.</span> <span class="nav-text">Leecode 200 Number of Islands</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-130-Surrounded-Regions"><span class="nav-number">7.5.2.</span> <span class="nav-text">Leetcode 130 Surrounded Regions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-417-Pacific-Atlantic-Water-Flow"><span class="nav-number">7.5.3.</span> <span class="nav-text">Leetcode 417 Pacific Atlantic Water Flow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯法是经典人工智能的基础"><span class="nav-number">7.6.</span> <span class="nav-text">回溯法是经典人工智能的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-52-N-Queens"><span class="nav-number">7.6.1.</span> <span class="nav-text">Leetcode 52 N-Queens</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-52-N-Queens-II"><span class="nav-number">7.6.2.</span> <span class="nav-text">Leetcode 52 N-Queens II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-37-Sudoku-Solver"><span class="nav-number">7.6.3.</span> <span class="nav-text">Leetcode 37 Sudoku Solver</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">8.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-70-Climbing-Stairs"><span class="nav-number">8.0.1.</span> <span class="nav-text">Leetcode 70 Climbing Stairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-120-Triangle"><span class="nav-number">8.0.2.</span> <span class="nav-text">Leetcode 120 Triangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-64-Minimum-Path-Sum"><span class="nav-number">8.0.3.</span> <span class="nav-text">Leetcode 64 Minimum Path Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-343-Integer-Break"><span class="nav-number">8.0.4.</span> <span class="nav-text">Leetcode 343 Integer Break</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-279-Perfect-Squares-1"><span class="nav-number">8.0.5.</span> <span class="nav-text">Leetcode 279 Perfect Squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-91-Decode-Ways"><span class="nav-number">8.0.6.</span> <span class="nav-text">Leetcode 91 Decode Ways</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-62-Unique-Paths"><span class="nav-number">8.0.7.</span> <span class="nav-text">Leetcode 62 Unique Paths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-63-Unique-Paths-II"><span class="nav-number">8.0.8.</span> <span class="nav-text">Leetcode 63 Unique Paths II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态及状态转移"><span class="nav-number">8.1.</span> <span class="nav-text">状态及状态转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-198-House-Robber"><span class="nav-number">8.1.1.</span> <span class="nav-text">Leetcode 198 House Robber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-213-House-Robber-II"><span class="nav-number">8.1.2.</span> <span class="nav-text">Leetcode 213 House Robber II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-337-House-Robber-III"><span class="nav-number">8.1.3.</span> <span class="nav-text">Leetcode 337 House Robber III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">8.1.4.</span> <span class="nav-text">Leetcode 309 Best Time to Buy and Sell Stock with Cooldown</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1背包问题"><span class="nav-number">8.2.</span> <span class="nav-text">0-1背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1背包问题的优化"><span class="nav-number">8.3.</span> <span class="nav-text">0-1背包问题的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全背包问题"><span class="nav-number">8.4.</span> <span class="nav-text">完全背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-416-Partition-Equal-Subset-Sum"><span class="nav-number">8.4.1.</span> <span class="nav-text">Leetcode 416 Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcoce-322-Coin-Change"><span class="nav-number">8.4.2.</span> <span class="nav-text">Leetcoce 322 Coin Change</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-377-Combination-Sum-IV"><span class="nav-number">8.4.3.</span> <span class="nav-text">Leetcode 377 Combination Sum IV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-474-Ones-and-Zeros"><span class="nav-number">8.4.4.</span> <span class="nav-text">Leetcode 474 Ones and Zeros</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-139-Word-Break"><span class="nav-number">8.4.5.</span> <span class="nav-text">Leetcode 139 Word Break</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-494-Target-Sum"><span class="nav-number">8.4.6.</span> <span class="nav-text">Leetcode 494 Target Sum</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长上升子序列"><span class="nav-number">8.5.</span> <span class="nav-text">最长上升子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-300-Longest-Increasing-Subsequence"><span class="nav-number">8.5.1.</span> <span class="nav-text">Leetcode 300 Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-376-Wiggle-Subsequence"><span class="nav-number">8.5.2.</span> <span class="nav-text">Leetcode 376 Wiggle Subsequence</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列-LCS"><span class="nav-number">8.6.</span> <span class="nav-text">最长公共子序列(LCS)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-300-Longest-Common-Subsequence"><span class="nav-number">8.6.1.</span> <span class="nav-text">Leetcode 300 Longest Common Subsequence</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra单源最短路径算法也是动态规划"><span class="nav-number">8.7.</span> <span class="nav-text">Dijkstra单源最短路径算法也是动态规划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心算法"><span class="nav-number">9.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单贪心算法"><span class="nav-number">9.1.</span> <span class="nav-text">简单贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-455-Assign-Cookies"><span class="nav-number">9.1.1.</span> <span class="nav-text">Leetcode 455 Assign Cookies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-392-Is-Subsequence"><span class="nav-number">9.1.2.</span> <span class="nav-text">Leetcode 392 Is Subsequence</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心算法与动态规划之间的关系"><span class="nav-number">9.2.</span> <span class="nav-text">贪心算法与动态规划之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-435-Non-overlapping-Intervals"><span class="nav-number">9.2.1.</span> <span class="nav-text">Leetcode 435 Non-overlapping Intervals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心选择性质"><span class="nav-number">9.3.</span> <span class="nav-text">贪心选择性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cao Duanxi"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Cao Duanxi</p>
  <div class="site-description" itemprop="description">静心，摒弃表面的浮华，多思考内在的深度!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aaron-cdx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aaron-cdx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cao1315020626" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;cao1315020626" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cao Duanxi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">259k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
