<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法视频学习</title>
    <url>/2020/06/01/%E7%AE%97%E6%B3%95%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="算法视频学习"><a href="#算法视频学习" class="headerlink" title="算法视频学习"></a>算法视频学习</h2><h3 id="二分法学习"><a href="#二分法学习" class="headerlink" title="二分法学习"></a>二分法学习</h3><h4 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="Leetcode-283-Move-Zeros"><a href="#Leetcode-283-Move-Zeros" class="headerlink" title="Leetcode 283 Move Zeros"></a>Leetcode 283 Move Zeros</h4><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br> 输出: [1,3,12,0,0]<br> 说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br> 尽量减少操作次数。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>使用双指针，当遇到0的时候就交换，此时k一定是在非0的元素上面，一直向后遍历，直到结束</p>
<p>时间复杂度：O(n)    空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">  if (nums &#x3D;&#x3D; null) return;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    if (nums[i] !&#x3D; 0) &#123;</span><br><span class="line">      swap(nums,i,k);</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] nums, int a, int b) &#123;</span><br><span class="line">  int temp &#x3D; nums[a];</span><br><span class="line">  nums[a] &#x3D; nums[b];</span><br><span class="line">  nums[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-27-Remove-Element"><a href="#Leetcode-27-Remove-Element" class="headerlink" title="Leetcode 27 Remove Element"></a>Leetcode 27 Remove Element</h4><h4 id="Leetcode-26-Remove-Duplicated-from-Sorted-Array"><a href="#Leetcode-26-Remove-Duplicated-from-Sorted-Array" class="headerlink" title="Leetcode 26 Remove Duplicated from Sorted Array"></a>Leetcode 26 Remove Duplicated from Sorted Array</h4><h4 id="Leetcode-80-Remove-Duplicated-frim-Sorted-Array-II"><a href="#Leetcode-80-Remove-Duplicated-frim-Sorted-Array-II" class="headerlink" title="Leetcode 80 Remove Duplicated frim Sorted Array II"></a>Leetcode 80 Remove Duplicated frim Sorted Array II</h4><h4 id="Leetcode-75-Sort-Colors"><a href="#Leetcode-75-Sort-Colors" class="headerlink" title="Leetcode 75 Sort Colors"></a>Leetcode 75 Sort Colors</h4><h4 id="Leetcode-88-Merge-Sorted-Array"><a href="#Leetcode-88-Merge-Sorted-Array" class="headerlink" title="Leetcode 88 Merge Sorted Array"></a>Leetcode 88 Merge Sorted Array</h4><h4 id="Leetcode-215-Kth-Largest-Element-in-an-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="Leetcode 215 Kth Largest Element in an Array"></a>Leetcode 215 Kth Largest Element in an Array</h4><h3 id="双索引技术-对撞指针"><a href="#双索引技术-对撞指针" class="headerlink" title="双索引技术-对撞指针"></a><strong>双索引技术-对撞指针</strong></h3><h4 id="Leetcode-167-Two-Sum-II-Input-array-is-Sorted"><a href="#Leetcode-167-Two-Sum-II-Input-array-is-Sorted" class="headerlink" title="Leetcode 167 Two Sum II - Input array is Sorted"></a>Leetcode 167 Two Sum II - Input array is Sorted</h4><blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br> 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br> 示例:</p>
<p>输入: numbers = [2, 7, 11, 15], target = 9<br> 输出: [1,2]<br> 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>双指针技术，利用头尾两个指针向中间夹逼。值等于就停止。取出下标即可，注意题目是有序。</p>
<p>时间复杂度：O(n)  空间复杂度：O(1)</p>
</blockquote>
<h4 id="Leetcode-125-Valid-Palindrome"><a href="#Leetcode-125-Valid-Palindrome" class="headerlink" title="Leetcode 125 Valid Palindrome"></a>Leetcode 125 Valid Palindrome</h4><blockquote>
<p>前后双指针夹逼，遇到非字母直接跳过。</p>
</blockquote>
<h4 id="Leetcode-344-Reverse-String"><a href="#Leetcode-344-Reverse-String" class="headerlink" title="Leetcode 344 Reverse String"></a>Leetcode 344 Reverse String</h4><blockquote>
<p>前后双指针，交换即可</p>
</blockquote>
<h4 id="Leetcode-345-Reverse-Vowels-of-a-String"><a href="#Leetcode-345-Reverse-Vowels-of-a-String" class="headerlink" title="Leetcode 345 Reverse Vowels of a String"></a>Leetcode 345 Reverse Vowels of a String</h4><blockquote>
<p>前后双指针，两者都遇到元音字母才交换</p>
</blockquote>
<h4 id="Leetcode-11-Container-With-Most-Water"><a href="#Leetcode-11-Container-With-Most-Water" class="headerlink" title="Leetcode 11 Container With Most Water"></a>Leetcode 11 Container With Most Water</h4><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<blockquote>
<p>双指针前后，小的前面才可能遇到更大的。所以移动小的一端，向中间夹逼即可。</p>
</blockquote>
<h3 id="双索引技术-滑动窗口"><a href="#双索引技术-滑动窗口" class="headerlink" title="双索引技术-滑动窗口"></a>双索引技术-滑动窗口</h3><h4 id="Leetcode-209-Minimum-Size-Subarray-Sum"><a href="#Leetcode-209-Minimum-Size-Subarray-Sum" class="headerlink" title="Leetcode 209 Minimum Size Subarray Sum"></a>Leetcode 209 Minimum Size Subarray Sum</h4><blockquote>
<p>长度最小的子数组</p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例:</p>
<p>输入: s = 7, nums = [2,3,1,2,4,3]<br> 输出: 2<br> 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。<br> 进阶:</p>
<p>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先滑动窗口，需要保持窗口前侧不越界，其次保持窗口后侧的跟随移动即可。</p>
<p>时间复杂度：O(n)  空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">  if (nums.length &lt; 1) return 0;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  int j &#x3D; -1;</span><br><span class="line">  int res &#x3D; 0;</span><br><span class="line">  int len &#x3D; nums.length + 1;</span><br><span class="line">  &#x2F;&#x2F; 滑动窗口的终止条件</span><br><span class="line">  while (i &lt; nums.length) &#123;</span><br><span class="line">    if (res &lt; s) &#123;</span><br><span class="line">      &#x2F;&#x2F; 需要确保j+1不能越界</span><br><span class="line">      if(j+1 &gt;&#x3D; nums.length) break;</span><br><span class="line">      res +&#x3D; nums[++j];</span><br><span class="line">    &#125; else if (res &gt;&#x3D; s) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果大于等于，此时计算长度，i向前进</span><br><span class="line">      len &#x3D; Math.min(len, j - i + 1);</span><br><span class="line">      res -&#x3D; nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len &#x3D;&#x3D; nums.length+1 ? 0 : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-3-Longest-Substring-Without-Repeating-Characters"><a href="#Leetcode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Leetcode 3 Longest Substring Without Repeating Characters"></a>Leetcode 3 Longest Substring Without Repeating Characters</h4><blockquote>
<p>双指针，可以利用一个数据存储，遇到重复的则将窗口向前移动即可。每次不重复的话则计算长度即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">  int l &#x3D; 0;</span><br><span class="line">  int r &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 要应对全部的字符</span><br><span class="line">  int[] nums &#x3D; new int[256];</span><br><span class="line">  int res &#x3D; Integer.MIN_VALUE;</span><br><span class="line">  while (r &lt; s.length()) &#123;</span><br><span class="line">    char c &#x3D; s.charAt(r);</span><br><span class="line">    &#x2F;&#x2F; 表示不重复，继续向前</span><br><span class="line">    if (nums[c] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      nums[c]++;</span><br><span class="line">      r++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 此时遇到重复，取长度，然后窗口向前移动，当前字符--</span><br><span class="line">      res &#x3D; Math.max(r - l, res);</span><br><span class="line">      nums[s.charAt(l++)]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Math.max(r - l, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-438-Find-All-Anagrams-in-a-String"><a href="#Leetcode-438-Find-All-Anagrams-in-a-String" class="headerlink" title="Leetcode 438 Find All Anagrams in a String"></a>Leetcode 438 Find All Anagrams in a String</h4><blockquote>
<p>找到字符串中的所有字母异位词</p>
<p>思路：按照双指针，数组，使用数组的性质来删除不符合条件的，从左到右，左边的不符合需要删除，右边一直前进，直到到达终点位置为止。</p>
<p>如果是找对应的字符或者是字符串，一定要知道，有进有出才是可以保证整个窗口持续前进的基础，否则一切都白搭，不会得到结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (p.length() &lt; 1) return res;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        int[] nums &#x3D; new int[26];</span><br><span class="line">        int[] nump &#x3D; new int[26];</span><br><span class="line">        for (int l &#x3D; 0; l &lt; p.length(); l++) &#123;</span><br><span class="line">            nums[p.charAt(l) - &#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt; s.length()) &#123;</span><br><span class="line">            int temp &#x3D; s.charAt(j) - &#39;a&#39;;</span><br><span class="line">            nump[temp]++;</span><br><span class="line">            &#x2F;&#x2F; 如果有相同的</span><br><span class="line">            while (nump[temp] &gt; nums[temp]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 算出左边当前的，移除左边的</span><br><span class="line">                int cnt &#x3D; s.charAt(i) - &#39;a&#39;;</span><br><span class="line">                i++;&#x2F;&#x2F; 左边前进</span><br><span class="line">                nump[cnt]--;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((j - i + 1) &#x3D;&#x3D; p.length()) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-76-Minimum-Window-Substring"><a href="#Leetcode-76-Minimum-Window-Substring" class="headerlink" title="Leetcode 76 Minimum Window Substring"></a>Leetcode 76 Minimum Window Substring</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 最小覆盖字串问题</span><br><span class="line"> *&#x2F;</span><br><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一定要保证进来多少就要出去多少！</span><br><span class="line">  Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  Map&lt;Character, Integer&gt; resMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; t.length(); i++) &#123;</span><br><span class="line">    char c &#x3D; t.charAt(i);</span><br><span class="line">    map.put(c, map.getOrDefault(c, 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  int l &#x3D; 0;</span><br><span class="line">  int r &#x3D; 0;</span><br><span class="line">  int match &#x3D; 0;&#x2F;&#x2F; 匹配的个数，只关心字符，出现次数也需要一样</span><br><span class="line">  String res &#x3D; &quot;&quot;;</span><br><span class="line">  int len &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  while (r &lt; s.length()) &#123;</span><br><span class="line">    char temp &#x3D; s.charAt(r);</span><br><span class="line">    if (map.containsKey(temp)) &#123;</span><br><span class="line">      resMap.put(temp, resMap.getOrDefault(temp, 0) + 1);</span><br><span class="line">      if (map.get(temp).equals(resMap.get(temp))) &#123;</span><br><span class="line">        match++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r++; &#x2F;&#x2F; 向前进</span><br><span class="line">    &#x2F;&#x2F; 匹配到需要的长度，也就是map中的元素个数长度</span><br><span class="line">    while (match &#x3D;&#x3D; map.size()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果长度小的话，则截取</span><br><span class="line">      if ((r - l) &lt; len) &#123;</span><br><span class="line">        res &#x3D; s.substring(l, r);</span><br><span class="line">        len &#x3D; res.length();</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 此时需要向右移动</span><br><span class="line">      char t1 &#x3D; s.charAt(l);</span><br><span class="line">      if (map.containsKey(t1)) &#123;</span><br><span class="line">        resMap.put(t1, resMap.get(t1) - 1);</span><br><span class="line">        &#x2F;&#x2F; 不匹配的话，是因为resMap中的当前字母个数小于map中的</span><br><span class="line">        if (map.get(t1) &gt; resMap.getOrDefault(t1, 0)) &#123;</span><br><span class="line">          match--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return res.length() &lt; Integer.MAX_VALUE ? res : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><h3 id="Set和Map数据结构的使用"><a href="#Set和Map数据结构的使用" class="headerlink" title="Set和Map数据结构的使用"></a>Set和Map数据结构的使用</h3><h4 id="Leetcode-349-Intersection-of-Two-Arrays"><a href="#Leetcode-349-Intersection-of-Two-Arrays" class="headerlink" title="Leetcode 349 Intersection of Two Arrays"></a>Leetcode 349 Intersection of Two Arrays</h4><h4 id="Leetcode-350-Intersection-of-Two-Arrays"><a href="#Leetcode-350-Intersection-of-Two-Arrays" class="headerlink" title="Leetcode 350 Intersection of Two Arrays"></a>Leetcode 350 Intersection of Two Arrays</h4><blockquote>
<p>如果上述的数组是有序该如何解决？可以不借助map和set的数据结构</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>

<p>思路：排序或者使用map表来记录响应的数据出现次数，排序是最稳妥的，前后遍历即可。每次遇到比自己大的自己向后走，小则对方向后走，等则加入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 时间复杂度:O(nlogn+mlogm)主要是两趟排序的时间，遍历的可以忽略  空间复杂度:O(1)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int[] intersect_1(int[] nums1, int[] nums2) &#123;</span><br><span class="line">  if (nums1 &#x3D;&#x3D; null || nums2 &#x3D;&#x3D; null) return null;</span><br><span class="line">  Arrays.sort(nums1);</span><br><span class="line">  Arrays.sort(nums2);</span><br><span class="line">  int len1 &#x3D; nums1.length;</span><br><span class="line">  int len2 &#x3D; nums2.length;</span><br><span class="line">  int l1 &#x3D; 0;</span><br><span class="line">  int l2 &#x3D; 0;</span><br><span class="line">  List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  while (l1 &lt; len1 &amp;&amp; l2 &lt; len2) &#123;</span><br><span class="line">    if (nums1[l1] &gt; nums2[l2]) &#123;</span><br><span class="line">      l2++;</span><br><span class="line">    &#125; else if (nums1[l1] &lt; nums2[l2]) &#123;</span><br><span class="line">      l1++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      list.add(nums1[l1]);</span><br><span class="line">      l1++;</span><br><span class="line">      l2++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  int[] res &#x3D; new int[list.size()];</span><br><span class="line">  l1 &#x3D; 0;</span><br><span class="line">  for (Integer num : list) &#123;</span><br><span class="line">    res[l1++] &#x3D; num;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 另外一种方法用map记录此时去重复</span><br><span class="line"> * 时间复杂度:O(m+n) 空间复杂度:O(min(m,n))</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">  if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    return intersect(nums2, nums1); &#x2F;&#x2F; 选出短的</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int num : nums1) &#123;</span><br><span class="line">    map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  int k &#x3D; 0;</span><br><span class="line">  for (int num : nums2) &#123;</span><br><span class="line">    int cnt &#x3D; map.getOrDefault(num, 0);</span><br><span class="line">    if (cnt &gt; 0) &#123;</span><br><span class="line">      nums1[k++] &#x3D; num;</span><br><span class="line">      map.put(num, cnt - 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Arrays.copyOfRange(nums1,0,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-242-Valid-Anagram"><a href="#Leetcode-242-Valid-Anagram" class="headerlink" title="Leetcode 242 Valid Anagram"></a>Leetcode 242 Valid Anagram</h4><blockquote>
<p>转变为字符char类型数组，排序，判断是否相等</p>
<p>使用数组加减，看最后所有的是否为0</p>
</blockquote>
<h4 id="Leetcode-202-Happy-Number"><a href="#Leetcode-202-Happy-Number" class="headerlink" title="Leetcode 202 Happy Number"></a>Leetcode 202 Happy Number</h4><blockquote>
<p>快乐数</p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<p>输入：19<br> 输出：true<br> 解释：<br> 12 + 92 = 82<br> 82 + 22 = 68<br> 62 + 82 = 100<br> 12 + 02 + 02 = 1</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>1.如果不是快乐数，最终是会经历等于4的状态</p>
<p>2.如果不是快乐数，最终是会经历相等的状态，且不为1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不是快乐数最终会变为4</span><br><span class="line">public boolean isHappy1(int n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 也就是最后需要为100，值为1</span><br><span class="line">  if(n &#x3D;&#x3D; 4) return false;</span><br><span class="line">  if(n &#x3D;&#x3D; 1) return true;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  while(n !&#x3D; 0)&#123;</span><br><span class="line">    sum +&#x3D; (n%10)*(n%10);</span><br><span class="line">    n &#x2F;&#x3D; 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return isHappy1(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用快慢指针的思路</span><br><span class="line">     *&#x2F;</span><br><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">  int fast &#x3D; n;</span><br><span class="line">  int slow &#x3D; n;</span><br><span class="line">  &#x2F;&#x2F; 不是快乐数最终是会相遇的</span><br><span class="line">  do&#123;</span><br><span class="line">    slow &#x3D; getSum(slow);</span><br><span class="line">    fast &#x3D; getSum(fast);</span><br><span class="line">    fast &#x3D; getSum(fast);</span><br><span class="line">  &#125;while(slow !&#x3D; fast);</span><br><span class="line">  return slow &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSum(int n)&#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  while(n !&#x3D; 0)&#123;</span><br><span class="line">    sum +&#x3D; (n%10)*(n%10);</span><br><span class="line">    n &#x2F;&#x3D; 10;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-290-Word-Pattern"><a href="#Leetcode-290-Word-Pattern" class="headerlink" title="Leetcode 290 Word Pattern"></a>Leetcode 290 Word Pattern</h4><blockquote>
<p>单词匹配问题</p>
<p>“abba” =&gt; “dog cat cat dog”  true</p>
<p>“abba” =&gt; “dog dog dog dog” false</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 空间复杂度：O(n)  时间复杂度：O(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean wordPattern1(String pattern, String str) &#123;</span><br><span class="line">  char[] chars &#x3D; pattern.toCharArray();</span><br><span class="line">  String[] s &#x3D; str.split(&quot; &quot;);</span><br><span class="line">  int l1 &#x3D; chars.length;</span><br><span class="line">  int l2 &#x3D; s.length;</span><br><span class="line">  if (l1 !&#x3D; l2) return false;</span><br><span class="line">  &#x2F;&#x2F; abba    dog dog dog dog  &#x3D;&#x3D;&gt; false</span><br><span class="line">  Map&lt;Character, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">  int index &#x3D; 0;</span><br><span class="line">  while (index &lt; l1) &#123;</span><br><span class="line">    if (!map.containsKey(chars[index])) &#123;</span><br><span class="line">      map.put(chars[index], s[index]);</span><br><span class="line">      boolean add &#x3D; set.add(s[index]);  &#x2F;&#x2F; set添加</span><br><span class="line">      if (!add) &#123; &#x2F;&#x2F; 如果set失败的话，就遇到了键不同，值相同的情况</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 否则就是包含</span><br><span class="line">      if (!map.get(chars[index]).equals(s[index])) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">  String[] s &#x3D; str.split(&quot; &quot;); &#x2F;&#x2F; 主要是pattern为&quot;&quot; str为&quot;beef&quot;类似这种</span><br><span class="line">  if (s.length !&#x3D; pattern.length()) return false;</span><br><span class="line">  String[] p &#x3D; pattern.split(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return judgement(p, s) &amp;&amp; judgement(s, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean judgement(String[] p, String[] s) &#123;</span><br><span class="line">  int len &#x3D; p.length;</span><br><span class="line">  Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    if (map.containsKey(p[i])) &#123;</span><br><span class="line">      if (!map.get(p[i]).equals(s[i])) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F; 不包含</span><br><span class="line">      map.put(p[i], s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-205-Isomorphic-Strings"><a href="#Leetcode-205-Isomorphic-Strings" class="headerlink" title="Leetcode 205 Isomorphic Strings"></a>Leetcode 205 Isomorphic Strings</h4><blockquote>
<p>思路与上面一题几乎一致</p>
</blockquote>
<h4 id="Leetcode-451-Sort-Characters-By-Frequency"><a href="#Leetcode-451-Sort-Characters-By-Frequency" class="headerlink" title="Leetcode 451 Sort Characters By Frequency"></a>Leetcode 451 Sort Characters By Frequency</h4><blockquote>
<p>根据字符出现频率排序</p>
<p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例 1:</p>
<p>输入:<br> “tree”</p>
<p>输出:<br> “eert”</p>
<p>解释:<br> ‘e’出现两次，’r’和’t’都只出现一次。<br> 因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/sort-characters-by-frequency" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-characters-by-frequency</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>这一题再面试中见过，使用堆对字符串出现次数排序，自己构造对象，重写比较方法即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 通过HashMap获取值，然后排序获得</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort1(String s) &#123;</span><br><span class="line">  if (s &#x3D;&#x3D; null) return s;</span><br><span class="line">  Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  String[] split &#x3D; s.split(&quot;&quot;);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; split.length; i++) &#123;</span><br><span class="line">    map.put(split[i], map.getOrDefault(split[i], 0) + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt; entries &#x3D; new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">  Collections.sort(entries, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123;</span><br><span class="line">      return o1.getValue().compareTo(o2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">    int cnt &#x3D; entry.getValue();</span><br><span class="line">    String key &#x3D; entry.getKey();</span><br><span class="line">    while (cnt !&#x3D; 0) &#123;</span><br><span class="line">      sb.append(key);</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用map和结构化数组来实现</span><br><span class="line">     * 数组中放入list，其中数组大小由最大次数决定即数组中有list</span><br><span class="line">     * 次数是list的下标，而这么多次数的字母在list中</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort2(String s) &#123;</span><br><span class="line">  if(s &#x3D;&#x3D; null) return s;</span><br><span class="line">  Map&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  int maxTimes &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">    map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);</span><br><span class="line">    maxTimes &#x3D; Math.max(maxTimes,map.get(s.charAt(i)));</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Character&gt;[] arrayLists &#x3D; new ArrayList[maxTimes+1];</span><br><span class="line">  for (Character c : map.keySet()) &#123;</span><br><span class="line">    int f &#x3D; map.get(c);</span><br><span class="line">    if(arrayLists[f] &#x3D;&#x3D; null)&#123;</span><br><span class="line">      arrayLists[f] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    arrayLists[f].add(c);</span><br><span class="line">  &#125;</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (int i &#x3D; maxTimes; i &gt;&#x3D; 0 ; i--) &#123;</span><br><span class="line">    if(arrayLists[i] !&#x3D; null)&#123;</span><br><span class="line">      for (Character c : arrayLists[i]) &#123;</span><br><span class="line">        while(i !&#x3D; 0)&#123;</span><br><span class="line">          sb.append(c);</span><br><span class="line">          i--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 学了面向对象，居然不会用面向对象，可笑</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 使用大顶堆，自己构建一个对象，对象实现comparator接口</span><br><span class="line">     * 重写比较方法即可维护一个属于自己的判断的大顶堆</span><br><span class="line">     * 最后根据大顶堆输出字符的次数，StringBuilder拼接即可</span><br><span class="line">     *&#x2F;</span><br><span class="line">public String frequencySort(String s) &#123;</span><br><span class="line">  int[] tab &#x3D; new int[256];</span><br><span class="line">  char[] chars &#x3D; s.toCharArray();</span><br><span class="line">  for (char c : chars) &#123;</span><br><span class="line">    tab[c]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PriorityQueue&lt;Latter&gt; queue &#x3D; new PriorityQueue&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; tab.length; i++) &#123;</span><br><span class="line">    if(tab[i] !&#x3D; 0)&#123;</span><br><span class="line">      queue.add(new Latter((char) i, tab[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  while (!queue.isEmpty())&#123;</span><br><span class="line">    Latter poll &#x3D; queue.poll();</span><br><span class="line">    int cnt &#x3D; poll.cnt;</span><br><span class="line">    while (cnt !&#x3D; 0)&#123;</span><br><span class="line">      sb.append(poll.c);</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造对象</span><br><span class="line">class Latter implements Comparable&#123;</span><br><span class="line">  char c;</span><br><span class="line">  int cnt;</span><br><span class="line"></span><br><span class="line">  public Latter(char c, int cnt) &#123;</span><br><span class="line">    this.c &#x3D; c;</span><br><span class="line">    this.cnt &#x3D; cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int compareTo(Object o) &#123;</span><br><span class="line">    return ((Latter) o).cnt - this.cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><h4 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode 1 Two Sum"></a>Leetcode 1 Two Sum</h4><h4 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode 15 3Sum"></a>Leetcode 15 3Sum</h4><blockquote>
<p>三数之和</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br> [<br> [-1, 0, 1],<br> [-1, -1, 2]<br> ]</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先需要遍历一次，暴力解法的话O(n^3)，时间复杂度过高。采用遍历一次，其中使用二分法夹逼。但是注意需要去重复逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (nums.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">    if (i - 1 &gt;&#x3D; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">    for (int j &#x3D; i + 1; j &lt; nums.length - 1; j++) &#123;</span><br><span class="line">      if (j - 1 &gt; i &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">      for (int k &#x3D; j + 1; k &lt; nums.length; k++) &#123;</span><br><span class="line">        if (k - 1 &gt; j &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;&#x2F;&#x2F; 相同的元素需要略过</span><br><span class="line">        if (nums[j] + nums[k] + nums[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          res.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum_1(int[] nums) &#123;</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (nums.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">  Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 二分法</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">    if(i - 1 &gt;&#x3D; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1]) continue;</span><br><span class="line">    int l &#x3D; i+1;</span><br><span class="line">    int r &#x3D; nums.length-1;</span><br><span class="line">    int temp &#x3D; -nums[i];</span><br><span class="line">    &#x2F;&#x2F; 大于0的话，由于排序了，后面的数不可能为负数</span><br><span class="line">    if(nums[i] &gt; 0)&#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(l &lt; r)&#123;</span><br><span class="line">      &#x2F;&#x2F; [-2,0,0,2,2]</span><br><span class="line">      &#x2F;&#x2F; 内部也要去重复</span><br><span class="line">      int tmp &#x3D; nums[l]+nums[r];</span><br><span class="line">      if(tmp &gt; temp)&#123;</span><br><span class="line">        r--; &#x2F;&#x2F; 先想前走，如果还是等于后面的，继续走，去重逻辑</span><br><span class="line">        while (r &gt; l &amp;&amp; nums[r] &#x3D;&#x3D; nums[r+1])&#123;</span><br><span class="line">          r--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else if(tmp &lt; temp)&#123;</span><br><span class="line">        l++; &#x2F;&#x2F; 先向后走，如果还是等于前面的，继续走，去重逻辑</span><br><span class="line">        while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l-1])&#123;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        res.add(Arrays.asList(nums[i],nums[l],nums[r]));</span><br><span class="line">        r--; &#x2F;&#x2F; 先前后都走，如果两个还是等于，继续一起走</span><br><span class="line">        l++;</span><br><span class="line">        while( l &lt; r &amp;&amp; nums[r+1] &#x3D;&#x3D; nums[r] &amp;&amp; nums[l] &#x3D;&#x3D; nums[l-1])&#123;</span><br><span class="line">          r--;</span><br><span class="line">          l++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode 18 4Sum"></a>Leetcode 18 4Sum</h4><blockquote>
<p>四数之和</p>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：第一种四层循环，注意去重，第二种两重循环，外加双指针，注意去重即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 利用四重循环的思路可以解决，时间复杂度O(n^4)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum1(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 4) return res;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 3; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; len - 2; j++) &#123;</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j - 1] &#x3D;&#x3D; nums[j]) continue;</span><br><span class="line">            int temp &#x3D; nums[i] + nums[j];</span><br><span class="line">            for (int k &#x3D; j + 1; k &lt; len - 1; k++) &#123;</span><br><span class="line">                if (k &gt; j + 1 &amp;&amp; nums[k - 1] &#x3D;&#x3D; nums[k]) continue;</span><br><span class="line">                for (int l &#x3D; k + 1; l &lt; len; l++) &#123;</span><br><span class="line">                    if (l &gt; k + 1 &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) continue;</span><br><span class="line">                    if (temp + nums[k] + nums[l] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用双指针的方式</span><br><span class="line"> * 排序O(nlogn) 双重遍历O(n^2) 其中双指针操作O(n&#x2F;2)</span><br><span class="line"> * 总的时间复杂度O(n^3)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 4) return res;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 3; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; len - 2; j++) &#123;</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j - 1] &#x3D;&#x3D; nums[j]) continue;</span><br><span class="line">            &#x2F;&#x2F; 嵌套双指针</span><br><span class="line">            int l &#x3D; j + 1;</span><br><span class="line">            int r &#x3D; nums.length - 1;</span><br><span class="line">            int temp &#x3D; nums[i] + nums[j];</span><br><span class="line">            while (l &lt; r) &#123;</span><br><span class="line">                int t &#x3D; nums[l] + nums[r];</span><br><span class="line">                if (temp + t &lt; target) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) &#123;</span><br><span class="line">                        l++;&#x2F;&#x2F; 这里l已经+1所以是和自己前面的对比</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (temp + t &gt; target) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[r + 1] &#x3D;&#x3D; nums[r]) &#123;</span><br><span class="line">                        r--;&#x2F;&#x2F; 这里r已经-1，所以是和自己后面的对比</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));</span><br><span class="line">                    r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l - 1] &amp;&amp; nums[r] &#x3D;&#x3D; nums[r + 1]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-16-3Sum-Closet"><a href="#Leetcode-16-3Sum-Closet" class="headerlink" title="Leetcode 16 3Sum Closet"></a>Leetcode 16 3Sum Closet</h4><blockquote>
<p>最接近三数之和</p>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：与三数之和基本一致，只是多了个比较绝对值的操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 时间复杂度O(n^2) 外层循环+内层双指针</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    int res &#x3D; 1000000;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    &#x2F;&#x2F; 怎么最接近，就是剪去target，看谁绝对值更小</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;</span><br><span class="line">        int l &#x3D; i + 1;</span><br><span class="line">        int r &#x3D; len - 1;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int temp &#x3D; nums[l] + nums[r]; &#x2F;&#x2F; 注意这里需要比较绝对值更小的才是最接近</span><br><span class="line">            res &#x3D; Math.abs(res - target) &gt; Math.abs(temp + nums[i] - target) ? temp+nums[i] : res;</span><br><span class="line">            if (temp + nums[i] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return target;</span><br><span class="line">            &#125; else if (temp + nums[i] &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[r + 1] &#x3D;&#x3D; nums[r]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l++;</span><br><span class="line">                while (l &lt; r &amp;&amp; nums[l - 1] &#x3D;&#x3D; nums[l]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-454-4Sum-II"><a href="#Leetcode-454-4Sum-II" class="headerlink" title="Leetcode 454 4Sum II"></a>Leetcode 454 4Sum II</h4><blockquote>
<p>四数之和II</p>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p>例如:</p>
<p>输入:<br> A = [ 1, 2]<br> B = [-2,-1]<br> C = [-1, 2]<br> D = [ 0, 2]</p>
<p>输出:<br> 2</p>
<p>解释:<br> 两个元组如下:</p>
<ol>
<li><p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</p>
</li>
<li><p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</p>
</li>
</ol>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/4sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：四重循环也可。或者使用map将其变换为两数之和</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 使用map获取两个，然后通过组合</span><br><span class="line"> * 时间复杂度O(n^2) 空间复杂度(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (A.length &#x3D;&#x3D; 0 || B.length &#x3D;&#x3D; 0</span><br><span class="line">            || C.length &#x3D;&#x3D; 0 || D.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; A.length;</span><br><span class="line">    &#x2F;&#x2F; 时间复杂度按照n^2来走</span><br><span class="line">    Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">            int t &#x3D; A[i] + B[j];</span><br><span class="line">            map.put(t, map.getOrDefault(t, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">            int t &#x3D; C[i] + D[j];</span><br><span class="line">            map2.put(t, map2.getOrDefault(t, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set &#x3D; map.keySet();</span><br><span class="line">    for (int a : set) &#123;</span><br><span class="line">        res +&#x3D; map.get(a) * map2.getOrDefault(-a, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-49-Group-Anagrams"><a href="#Leetcode-49-Group-Anagrams" class="headerlink" title="Leetcode 49 Group Anagrams"></a>Leetcode 49 Group Anagrams</h4><blockquote>
<p>字母异位词分组</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>所有输入均为小写字母。<br> 不考虑答案输出的顺序。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/group-anagrams" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>遍历排序用map记录相同的string，内部维护list记录，最后遍历取出list即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 遍历内部排序</span><br><span class="line"> * 时间复杂度:O(nklogk) n表示strs长度，k表示字符串长度</span><br><span class="line"> * 空间复杂度:O(n)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (strs.length &#x3D;&#x3D; 0) return res;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (String str : strs) &#123;</span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        ;</span><br><span class="line">        String temp &#x3D; String.valueOf(chars);</span><br><span class="line">        if (!map.containsKey(temp)) &#123;</span><br><span class="line">            map.put(temp, new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(temp).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    for (String s : map.keySet()) &#123;</span><br><span class="line">        res.add(map.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-447-Number-of-Boomerangs"><a href="#Leetcode-447-Number-of-Boomerangs" class="headerlink" title="Leetcode 447 Number of Boomerangs"></a>Leetcode 447 Number of Boomerangs</h4><blockquote>
<p>回旋镖的数量</p>
<p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</p>
<p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p>
<p>示例:</p>
<p>输入:<br> [[0,0],[1,0],[2,0]]</p>
<p>输出:<br> 2</p>
<p>解释:<br> 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/number-of-boomerangs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-boomerangs</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>计算距离，总数目为n(n-1)，考虑到下一次再出现数目为(n+1)n，地增量为2*n，所以每次只要有超过1个以上的就计算数目即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public int numberOfBoomerangs(int[][] points) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (points &#x3D;&#x3D; null) return 0;</span><br><span class="line"></span><br><span class="line">    int m &#x3D; points.length;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">           int sum &#x3D; getSum(i,j,points);</span><br><span class="line">           if(!map.containsKey(sum))&#123;</span><br><span class="line">               map.put(sum,1);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               int n &#x3D; map.get(sum);</span><br><span class="line">               res +&#x3D; 2 * n;</span><br><span class="line">               map.put(sum,n+1);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">    public int getSum(int i, int j, int[][] points)&#123;</span><br><span class="line">    return (points[i][0]-points[j][0])*(points[i][0]-points[j][0])</span><br><span class="line">            + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-149-Max-Points-on-a-Line"><a href="#Leetcode-149-Max-Points-on-a-Line" class="headerlink" title="Leetcode 149 Max Points on a Line"></a>Leetcode 149 Max Points on a Line</h4><blockquote>
<p>直线上最多的点数</p>
<p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p>
<p>示例 1:</p>
<p>输入: [[1,1],[2,2],[3,3]]<br> 输出: 3<br> 解释:<br> ^<br> |<br> |        o<br> |     o<br> |  o<br> +————-&gt;<br> 0  1  2  3  4<br> 示例 2:</p>
<p>输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br> 输出: 4<br> 解释:<br> ^<br> |<br> |  o<br> |     o        o<br> |        o<br> |  o        o<br> +——————-&gt;<br> 0  1  2  3  4  5  6</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/max-points-on-a-line" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-points-on-a-line</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：使用map记录，由于出现的数可能会非常大，此时就获取最大公约数来获取同样的值，同时自定义键，注意有重复的使用duplicate记录下来即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public int maxPoints(int[][] points) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算斜率，正负都要考虑</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    int l &#x3D; points.length;</span><br><span class="line">    if (l &lt; 2) return l;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">        int duplicate &#x3D; 0; &#x2F;&#x2F; 计算重复的元素</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; l; j++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; j) continue;</span><br><span class="line">            &#x2F;&#x2F; 需要计算入一个重复的元素</span><br><span class="line">            &#x2F;&#x2F; 否则计算斜率</span><br><span class="line">            int x &#x3D; (points[i][0] - points[j][0]);</span><br><span class="line">            int y &#x3D; (points[i][1] - points[j][1]);</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                duplicate++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 辗转相除获取最大公约数</span><br><span class="line">            int a &#x3D; gcdII(x, y);</span><br><span class="line">            x &#x3D; x &#x2F; a;</span><br><span class="line">            y &#x3D; y &#x2F; a;</span><br><span class="line">            &#x2F;&#x2F; 获取最大公约数</span><br><span class="line">            String key &#x3D; x + &quot;-&quot; + y;</span><br><span class="line">            map.put(key, map.getOrDefault(key, 0) + 1);</span><br><span class="line">            max &#x3D; Math.max(max, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        res &#x3D; Math.max(res, max + duplicate + 1);</span><br><span class="line">        map.clear();&#x2F;&#x2F; 注意清除</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int gcdII(int a, int b) &#123;</span><br><span class="line">    while(b !&#x3D; 0)&#123;</span><br><span class="line">        int temp &#x3D; a % b;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口-查找表"><a href="#滑动窗口-查找表" class="headerlink" title="滑动窗口+查找表"></a>滑动窗口+查找表</h3><h4 id="Leetcode-219-Contains-Duplicate-II"><a href="#Leetcode-219-Contains-Duplicate-II" class="headerlink" title="Leetcode 219 Contains Duplicate II"></a>Leetcode 219 Contains Duplicate II</h4><blockquote>
<p>存在重复元素II</p>
<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3<br> 输出: true<br> 示例 2:</p>
<p>输入: nums = [1,0,1,1], k = 1<br> 输出: true<br> 示例 3:</p>
<p>输入: nums = [1,2,3,1,2,3], k = 2<br> 输出: false</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：利用set维护相同的情况，一旦插入失败，判断间距大小是否符合，符合true，不符合移除元素。如果能够插入，需要保持间距k，所以需要适当移除元素。</p>
<p>时间复杂度：O(n)；空间复杂度：O(k)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">    if (nums.length &lt;&#x3D; 1 || k &lt; 0) return false;</span><br><span class="line">    int l &#x3D; 0;</span><br><span class="line">    int r &#x3D; 0;</span><br><span class="line">    Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 窗口大小维持k大小</span><br><span class="line">    while (r &lt; nums.length) &#123;</span><br><span class="line">        if (!set.add(nums[r])) &#123;</span><br><span class="line">            if (r - l &lt;&#x3D; k) return true;</span><br><span class="line">            else set.remove(nums[l++]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 因为如果等于k的话，此时也要移除</span><br><span class="line">            if (r - l &gt;&#x3D; k) set.remove(nums[l++]);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-217-Contains-Duplicate"><a href="#Leetcode-217-Contains-Duplicate" class="headerlink" title="Leetcode 217 Contains Duplicate"></a>Leetcode 217 Contains Duplicate</h4><h4 id="Leetcode-220-Contains-Duplicate-III"><a href="#Leetcode-220-Contains-Duplicate-III" class="headerlink" title="Leetcode 220 Contains Duplicate III"></a>Leetcode 220 Contains Duplicate III</h4><blockquote>
<p>存在重复元素III</p>
<p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,1], k = 3, t = 0<br> 输出: true</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-iii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：利用TreeMap底层是红黑树实现的特性，且有序的特性，动态获取大于当前值的值，然后通过大小为k的窗口获取</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 利用TreeMap获取自己上半部分的值</span><br><span class="line"> * 利用判断获取自己下半部分的值</span><br><span class="line"> *    nums[i]-t  &lt;&#x3D; temp &lt;&#x3D; nums[i]+t ，则证明有效</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">    if (nums.length &lt; 2 || k &lt; 0) return false;</span><br><span class="line">    &#x2F;&#x2F; 利用查找表结合滑动窗口来实现啊</span><br><span class="line">   TreeSet&lt;Long&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 给出一个大于当前给的值的值</span><br><span class="line">        Long temp &#x3D; set.ceiling((long)nums[i]-(long)t);</span><br><span class="line">        if(temp !&#x3D; null &amp;&amp; temp &lt;&#x3D; (long)nums[i]+(long)t)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((long)nums[i]);</span><br><span class="line">        if(set.size() &#x3D;&#x3D; k+1)&#123;</span><br><span class="line">            set.remove((long)nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="Leetcode-206-Reverse-Linked-List"><a href="#Leetcode-206-Reverse-Linked-List" class="headerlink" title="Leetcode 206 Reverse Linked List"></a>Leetcode 206 Reverse Linked List</h4><blockquote>
<p>反转链表</p>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br> 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br> 进阶:<br> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：遍历一遍还是很简单，如果使用递归的话一定要注意到了最后的节点，要注意衔接前和后的关系。head.next.next=head;head.next=null;主要就在这了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 直接利用走一趟的方式解决</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseList1(ListNode head) &#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    while(head.next !&#x3D; null)&#123;</span><br><span class="line">        ListNode temp &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 利用递归的方式解决链表反转</span><br><span class="line"> * 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"> * 首先到5，然后pre&#x3D;5      head</span><br><span class="line"> * head.next.next&#x3D;head,即  4 -&gt; 5 -&gt; 4 然后head.next切断4-&gt;5</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; reverseList(head.next);</span><br><span class="line">    &#x2F;&#x2F; 此处反转</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 释放当前的head</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92 Reverse Linked List II"></a>Leetcode 92 Reverse Linked List II</h4><blockquote>
<p>反转链表II</p>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br> 1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br> 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>第一种方法：遍历实现，找到初始标记点，往后所有的点往这个点后面插即可，开始的第一个点一直向后走直到到达最后一个点为止。</p>
<p>第二种方法：利用递归实现，利用前n个翻转实现，前n个翻转记住后面的后继节点即可，然后翻转前半部分，而翻转区间如果m为1的话等同于翻转前n个，如果不为1的话，表名当前节点的下一个节点可能为需要翻转的部分，但是翻转n个从1开始，所以相对而言，区间需要保持同时减一，向后移动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 使用一遍遍历，首先找到一个基准位节点，最后每次将第一个节点</span><br><span class="line"> * 的后面的节点插入到当前基准位节点之后就好。一直遍历到n节点即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseBetween1(ListNode head, int m, int n) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    int res &#x3D; 0; &#x2F;&#x2F; 用来记录遍历到的位置</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode pre &#x3D; dummyNode;</span><br><span class="line">    ListNode cur &#x3D; dummyNode.next;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m - 1; i++) &#123;</span><br><span class="line">        pre &#x3D; pre.next;</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; pre保持不变，第一个节点一直向后走，其余遇到的节点向第一个节点后面插就好</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n - m; i++) &#123;</span><br><span class="line">        ListNode temp &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; cur.next.next;&#x2F;&#x2F; 交换当前节点与后面节点的指向</span><br><span class="line">        &#x2F;&#x2F; 解除之前的连接</span><br><span class="line">        temp.next &#x3D; pre.next;</span><br><span class="line">        pre.next &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 翻转前n个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">private ListNode successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">public ListNode reverseN(ListNode head, int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        successor &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 成环了</span><br><span class="line">    ListNode res &#x3D; reverseN(head.next, n - 1);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line"></span><br><span class="line">    head.next &#x3D; successor;&#x2F;&#x2F; 每一个的尾部都指向successor也就是尾端</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 递归实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class="line">    if (m &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则的需要向后走，由于m与n是相对位置，所以需要一起减少</span><br><span class="line">    head.next &#x3D; reverseBetween(head.next, m - 1, n - 1);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h4><blockquote>
<p>删除排序链表中的重复元素</p>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br> 输出: 1-&gt;2<br> 示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br> 输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：第一种思路：双指针，不同一起走，相同的话找到后面的不同，然后改变指针指向。第二种思路：单指针，如果下一个与自己相同，改变指向，改变指向比较频繁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到不同的那个点，然后改变指针指向</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode q = p.next;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span> &amp;&amp; q.val == p.val)&#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = q;</span><br><span class="line">        <span class="keyword">if</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要相同一直改变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">            <span class="comment">// 改变指针指向</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = temp.next;</span><br><span class="line">            temp.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 利用虚拟头节点是一个方法，每次都新建一个节点拼接</span><br><span class="line"> * 最后将两条链表组合即可</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode partition(ListNode head, int x) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode small &#x3D; new ListNode(0);</span><br><span class="line">    ListNode s &#x3D; small;</span><br><span class="line">    ListNode big &#x3D; new ListNode(0);</span><br><span class="line">    ListNode b &#x3D; big;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        if (head.val &lt; x) &#123;</span><br><span class="line">            s.next &#x3D; new ListNode(head.val);</span><br><span class="line">            s &#x3D; s.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            b.next &#x3D; new ListNode(head.val);</span><br><span class="line">            b &#x3D; b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    s.next &#x3D; big.next;</span><br><span class="line">    return small.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-328-Odd-Even-Linked-List"><a href="#Leetcode-328-Odd-Even-Linked-List" class="headerlink" title="Leetcode 328 Odd Even Linked List"></a>Leetcode 328 Odd Even Linked List</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public ListNode oddEvenList(ListNode head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode even &#x3D; head.next;</span><br><span class="line">    ListNode o &#x3D; head;&#x2F;&#x2F; 奇数节点</span><br><span class="line">    ListNode e &#x3D; even;&#x2F;&#x2F; 偶数节点</span><br><span class="line">    while (e !&#x3D; null &amp;&amp; e.next !&#x3D; null) &#123;</span><br><span class="line">        o.next &#x3D; e.next;</span><br><span class="line">        o &#x3D; e.next;&#x2F;&#x2F; 奇数节点到偶数节点的下一个节点</span><br><span class="line">        e.next &#x3D; o.next;</span><br><span class="line">        e &#x3D; o.next;&#x2F;&#x2F; 偶数节点到奇数节点的下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    o.next &#x3D; even;&#x2F;&#x2F; 奇数节点的下一个节点连接到偶数节点的头节点</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h4><blockquote>
<p>两数相加</p>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br> 输出：7 -&gt; 0 -&gt; 8<br> 原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：官方给的这个例子不好，其实因为正反都是807。24+56=701，可以看到进位在往后走，只需要依据链表不为null，且进位不等于0，就结束计算，任有一项不满足结束计算，否则继续拼接。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode sum &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; sum;</span><br><span class="line">        &#x2F;&#x2F; 是否有进位</span><br><span class="line">        int carry &#x3D; 0;</span><br><span class="line">        while(l1 !&#x3D; null || l2 !&#x3D; null || carry !&#x3D; 0)&#123;</span><br><span class="line">            int l1val &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">            int l2val &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">            int temp &#x3D; l1val + l2val + carry;</span><br><span class="line">            carry &#x3D; temp &#x2F; 10; &#x2F;&#x2F; 获取余数即进位至下一环节,是将余数进位！</span><br><span class="line">            cur.next &#x3D; new ListNode(temp % 10); &#x2F;&#x2F; 获取十位上作为节点填充</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            if(l1 !&#x3D; null) l1 &#x3D; l1.next;</span><br><span class="line">            if(l2 !&#x3D; null) l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-445-Add-Two-Numbers-II"><a href="#Leetcode-445-Add-Two-Numbers-II" class="headerlink" title="Leetcode 445 Add Two Numbers II"></a>Leetcode 445 Add Two Numbers II</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    l1 &#x3D; reverse(l1);</span><br><span class="line">    l2 &#x3D; reverse(l2);</span><br><span class="line">    int carry &#x3D; 0;</span><br><span class="line">    ListNode sum &#x3D; new ListNode(0);</span><br><span class="line">    ListNode cur &#x3D; sum;</span><br><span class="line">    while(l1 !&#x3D; null ||  l2 !&#x3D; null || carry !&#x3D; 0)&#123;</span><br><span class="line">        int l1val &#x3D; l1 &#x3D;&#x3D; null ? 0 : l1.val;</span><br><span class="line">        int l2val &#x3D; l2 &#x3D;&#x3D; null ? 0 : l2.val;</span><br><span class="line">        int temp &#x3D; l1val + l2val + carry;</span><br><span class="line">        carry &#x3D; temp &#x2F; 10;</span><br><span class="line">        cur.next &#x3D; new ListNode(temp%10);</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">        if(l1 !&#x3D; null) l1 &#x3D; l1.next;</span><br><span class="line">        if(l2 !&#x3D; null) l2 &#x3D; l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return reverse(sum.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不采用翻转的话，就使用数据结构来帮助，栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode addTwoNumbersII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">   Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">   while(l1 !&#x3D; null)&#123;</span><br><span class="line">       stack1.push(l1.val);</span><br><span class="line">       l1 &#x3D; l1.next;</span><br><span class="line">   &#125;</span><br><span class="line">   while(l2 !&#x3D; null)&#123;</span><br><span class="line">       stack2.push(l2.val);</span><br><span class="line">       l2 &#x3D; l2.next;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode sum &#x3D; null; &#x2F;&#x2F; 将结果翻转</span><br><span class="line">   int carry &#x3D; 0;</span><br><span class="line">   while(!stack1.isEmpty() || !stack2.isEmpty() || carry !&#x3D; 0)&#123;</span><br><span class="line">       int s1 &#x3D; stack1.isEmpty() ? 0 : stack1.pop();</span><br><span class="line">       int s2 &#x3D; stack2.isEmpty() ? 0 : stack2.pop();</span><br><span class="line">       int temp &#x3D; s1 + s2 + carry;</span><br><span class="line">       carry &#x3D; temp &#x2F; 10;</span><br><span class="line">       ListNode tmp &#x3D; new ListNode(temp % 10);</span><br><span class="line">       &#x2F;&#x2F; 这要一直插在sum与cur之间</span><br><span class="line">       tmp.next &#x3D; sum;</span><br><span class="line">       sum &#x3D; tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br><span class="line">private ListNode reverse(ListNode head)&#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    while(head !&#x3D; null)&#123;</span><br><span class="line">        ListNode temp &#x3D; head.next;</span><br><span class="line">        head.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; head;</span><br><span class="line">        head &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="设立链表虚拟头节点"><a href="#设立链表虚拟头节点" class="headerlink" title="设立链表虚拟头节点"></a>设立链表虚拟头节点</h3><h4 id="Leetcode-203-Remove-Linked-List-Elements"><a href="#Leetcode-203-Remove-Linked-List-Elements" class="headerlink" title="Leetcode 203 Remove Linked List Elements"></a>Leetcode 203 Remove Linked List Elements</h4><blockquote>
<p>移除链表元素</p>
<p>删除链表中等于给定值 <strong>*val</strong> 的所有节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 移除元素，使用虚拟头结点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(-1);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode cur &#x3D; dummyNode;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        if (head.val &#x3D;&#x3D; val) &#123;</span><br><span class="line">            ListNode temp &#x3D; head.next;&#x2F;&#x2F; 保存当前节点的下一个节点</span><br><span class="line">            head.next &#x3D; null;&#x2F;&#x2F; 解除当前节点与下一个节点的联系</span><br><span class="line">            head &#x3D; temp;&#x2F;&#x2F; 当前节点向前移动</span><br><span class="line">            cur.next &#x3D; head;&#x2F;&#x2F; 改变cur下一个节点指向</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur &#x3D; head;</span><br><span class="line">            head &#x3D; head.next;&#x2F;&#x2F; 一起向后挪一个位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-82-Remove-Linked-List-Elements-II"><a href="#Leetcode-82-Remove-Linked-List-Elements-II" class="headerlink" title="Leetcode 82 Remove Linked List Elements II"></a>Leetcode 82 Remove Linked List Elements II</h4><blockquote>
<p>移除排序链表中的重复元素</p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br> 输出: 1-&gt;2-&gt;5<br> 示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br> 输出: 2-&gt;3</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 移除重复出现的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode deleteDuplicatesII(ListNode head) &#123;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(-1);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode cur &#x3D; dummyNode;</span><br><span class="line">    &#x2F;&#x2F; 首先保证当前元素和当前下一个元素补位null</span><br><span class="line">    while(head !&#x3D; null &amp;&amp; head.next !&#x3D; null)&#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不等，一起向前</span><br><span class="line">        if(head.val !&#x3D; head.next.val)&#123;</span><br><span class="line">            cur &#x3D; head;</span><br><span class="line">            head &#x3D; head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果相等，则head一个人向前，cur等待连接到不等的节点即可</span><br><span class="line">            while(head.next !&#x3D; null &amp;&amp; head.val &#x3D;&#x3D; head.next.val)&#123;</span><br><span class="line">                head &#x3D; head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 到了这里可以表明到了不等的一点或者尾部节点，记住下一个节点</span><br><span class="line">            ListNode temp &#x3D; head.next;</span><br><span class="line">            head.next &#x3D; null;&#x2F;&#x2F; 自己是相等的最后一个节点，断开连接</span><br><span class="line">            head &#x3D; temp;&#x2F;&#x2F; 向前挪至自己的下一个节点</span><br><span class="line">            cur.next &#x3D; head;&#x2F;&#x2F; 将cur.next连接过来即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoListsII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; dummyNode;</span><br><span class="line">        while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if (l1.val &gt;&#x3D; l2.val) &#123;</span><br><span class="line">                cur.next &#x3D; new ListNode(l2.val);</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur.next &#x3D; new ListNode(l1.val);</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1 !&#x3D; null) &#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 !&#x3D; null) &#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ListNode mergeTwoListsIII(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; dummyNode;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null)&#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">                cur.next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur.next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        dummyNode.next &#x3D; head;</span><br><span class="line">        ListNode res &#x3D; dummyNode;&#x2F;&#x2F; 记录整条链表衔接</span><br><span class="line">        ListNode cur &#x3D; head;&#x2F;&#x2F; 后节点</span><br><span class="line">        ListNode pre &#x3D; cur.next;&#x2F;&#x2F; 前节点</span><br><span class="line">        while (pre !&#x3D; null) &#123; &#x2F;&#x2F; 前节点不能为null</span><br><span class="line">            ListNode temp &#x3D; pre.next; &#x2F;&#x2F; 前节点前面做临时节点保留</span><br><span class="line">            pre.next &#x3D; cur;&#x2F;&#x2F; 前节点翻转</span><br><span class="line">            cur.next &#x3D; temp;&#x2F;&#x2F; 后节点翻转</span><br><span class="line">            res.next &#x3D; pre;&#x2F;&#x2F; 链表节点下一个衔接翻转之后的</span><br><span class="line">            res &#x3D; pre.next;&#x2F;&#x2F; 链表节点移动到翻转之后的后一个节点</span><br><span class="line">            cur &#x3D; cur.next;&#x2F;&#x2F; 后节点向后走，这里最多为null</span><br><span class="line">            if(cur &#x3D;&#x3D; null)&#123;&#x2F;&#x2F; 后节点如果为null，表示没得走了</span><br><span class="line">                break;&#x2F;&#x2F; 终止</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; cur.next;&#x2F;&#x2F; 否则前节点向前走</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-25-Reverse-Nodes-in-K-Group"><a href="#Leetcode-25-Reverse-Nodes-in-K-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in K-Group"></a>Leetcode 25 Reverse Nodes in K-Group</h4><h4 id="Leetcode-147-Insertion-Sort-List"><a href="#Leetcode-147-Insertion-Sort-List" class="headerlink" title="Leetcode 147 Insertion Sort List"></a>Leetcode 147 Insertion Sort List</h4><h4 id="Leetcode-148-Sort-List"><a href="#Leetcode-148-Sort-List" class="headerlink" title="Leetcode 148 Sort List"></a>Leetcode 148 Sort List</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 排序链表，要求时间复杂度为o(nlogn)</span><br><span class="line">     * @param head 头节点</span><br><span class="line">     * @return 排序好的链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">        &#x2F;&#x2F; logn的算法就是二分法</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        while(fast.next !&#x3D; null &amp;&amp; fast.next.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; slow抵达终点，fast抵达终点</span><br><span class="line">        fast &#x3D; slow.next;&#x2F;&#x2F; fast作为后半段的头节点</span><br><span class="line">        slow.next &#x3D; null;&#x2F;&#x2F; 截断</span><br><span class="line">        slow &#x3D; head;&#x2F;&#x2F; slow作为首节点</span><br><span class="line">        ListNode l1 &#x3D; sortList(slow);</span><br><span class="line">        ListNode l2 &#x3D; sortList(fast);</span><br><span class="line">        return merge(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 链表的merge合并过程</span><br><span class="line">    public ListNode merge(ListNode l1, ListNode l2)&#123;</span><br><span class="line">        ListNode res &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; res;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null)&#123;</span><br><span class="line">            if(l1.val &lt;&#x3D; l2.val)&#123;</span><br><span class="line">                cur.next &#x3D; l1;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur.next &#x3D; l2;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2 !&#x3D; null)&#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>插入排序和归并排序</p>
</blockquote>
<h4 id="Leetcode-237-Delete-Node-in-a-Linked-List"><a href="#Leetcode-237-Delete-Node-in-a-Linked-List" class="headerlink" title="Leetcode 237 Delete Node in a Linked List"></a>Leetcode 237 Delete Node in a Linked List</h4><h3 id="链表与双指针"><a href="#链表与双指针" class="headerlink" title="链表与双指针"></a>链表与双指针</h3><h4 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h4><blockquote>
<p>一趟遍历，双指针，指针之间相差n</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line"> * 节点之间相差n个，但是注意需要使用一个虚拟节点</span><br><span class="line"> * 防止删除的就是当前的p节点，不然会导致错误</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null) return null;</span><br><span class="line">    ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">    dummyNode.next &#x3D; head;</span><br><span class="line">    ListNode p &#x3D; dummyNode;</span><br><span class="line">    ListNode q &#x3D; p;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        n--;&#x2F;&#x2F; 注意在后面的话会多走一个，这样的话越过dummyNode</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两者之间差距为n个节点</span><br><span class="line">    while (q.next !&#x3D; null) &#123;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 一旦为null，表示到了终点</span><br><span class="line">    ListNode temp &#x3D; p.next.next;</span><br><span class="line">    p.next.next &#x3D; null;</span><br><span class="line">    p.next &#x3D; temp;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * k次，时间复杂度O(nk)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null) return null;</span><br><span class="line">        ListNode dummyNode &#x3D; new ListNode(0);</span><br><span class="line">        dummyNode.next &#x3D; head;</span><br><span class="line">        ListNode p &#x3D; dummyNode.next;</span><br><span class="line">        ListNode q &#x3D; p.next;</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        k %&#x3D; cnt;</span><br><span class="line">        while(k !&#x3D; 0)&#123;</span><br><span class="line">            while(q.next !&#x3D; null)&#123;</span><br><span class="line">                p&#x3D;p.next;</span><br><span class="line">                q&#x3D;q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next &#x3D; null;</span><br><span class="line">            q.next &#x3D; dummyNode.next;</span><br><span class="line">            dummyNode.next &#x3D; q;</span><br><span class="line">            p &#x3D; q;</span><br><span class="line">            q &#x3D; q.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143 Reorder List"></a>Leetcode 143 Reorder List</h4><p>这个也是找出后半部分的，然后对后半部分的进行翻转，然后插入前一个链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reorderList(ListNode head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return;</span><br><span class="line">        ListNode slow &#x3D; head;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 此时slow到了中点，fast到了末尾节点</span><br><span class="line">        fast &#x3D; slow.next;</span><br><span class="line">        fast &#x3D; reverse(fast);</span><br><span class="line">        slow.next &#x3D; null;</span><br><span class="line">        slow &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F; 上面的动作正式切换为两个链表了</span><br><span class="line">        &#x2F;&#x2F; 1 2 3 | 4</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        while(slow !&#x3D; null &amp;&amp; fast !&#x3D; null)&#123;</span><br><span class="line">            ListNode temp &#x3D; slow.next;</span><br><span class="line">            ListNode tmp &#x3D; fast.next;</span><br><span class="line">            slow.next &#x3D; fast;</span><br><span class="line">            fast.next &#x3D; temp;</span><br><span class="line">            slow &#x3D; temp;</span><br><span class="line">            fast &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-234-Palindrome-Linked-List"><a href="#Leetcode-234-Palindrome-Linked-List" class="headerlink" title="Leetcode 234 Palindrome Linked List"></a>Leetcode 234 Palindrome Linked List</h4><p>快慢指针，然后翻转后半部分，一个一个对，只要出现不相等就false，否则到最后返回true</p>
<blockquote>
<p>O(1)的时间复杂度解决</p>
</blockquote>
<h2 id="栈和队列的使用"><a href="#栈和队列的使用" class="headerlink" title="栈和队列的使用"></a>栈和队列的使用</h2><h3 id="基础的栈在算法中的使用"><a href="#基础的栈在算法中的使用" class="headerlink" title="基础的栈在算法中的使用"></a>基础的栈在算法中的使用</h3><h4 id="Leetcode-20-Valid-Parentheses"><a href="#Leetcode-20-Valid-Parentheses" class="headerlink" title="Leetcode 20 Valid Parentheses"></a>Leetcode 20 Valid Parentheses</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;if(s.isEmpty()) return true;</span><br><span class="line">        &#x2F;&#x2F; []&#123;&#125;()</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        char[] chars &#x3D; s.toCharArray();</span><br><span class="line">        &#x2F;&#x2F;stack.push(chars[0]);</span><br><span class="line">        &#x2F;&#x2F;for (int i &#x3D; 1; i &lt; chars.length; i++) &#123;</span><br><span class="line">                for (int i &#x3D; 1; i &lt; chars.length; i++) &#123;</span><br><span class="line">            if(!stack.isEmpty() &amp;&amp; pair(stack.peek(),chars[i]))&#123;</span><br><span class="line">                stack.pop();&#x2F;&#x2F; 如果相同就弹出，前提是有元素</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.push(chars[i]);&#x2F;&#x2F; 否则插入元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();&#x2F;&#x2F; 返回是否为空</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean pair(char a, char b)&#123;</span><br><span class="line">        return ((a &#x3D;&#x3D; &#39;(&#39; &amp;&amp; b &#x3D;&#x3D; &#39;)&#39;) || (a &#x3D;&#x3D; &#39;)&#39; &amp;&amp; b &#x3D;&#x3D; &#39;(&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; b &#x3D;&#x3D; &#39;&#125;&#39;) || (a &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; b &#x3D;&#x3D; &#39;&#123;&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39;[&#39; &amp;&amp; b &#x3D;&#x3D; &#39;]&#39;) || (a &#x3D;&#x3D; &#39;]&#39; &amp;&amp; b &#x3D;&#x3D; &#39;[&#39;))</span><br><span class="line">                || ((a &#x3D;&#x3D; &#39; &#39; &amp;&amp; b &#x3D;&#x3D; &#39; &#39;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-150-Evaluate-Reverse-Polish-Notation"><a href="#Leetcode-150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="Leetcode 150 Evaluate Reverse Polish Notation"></a>Leetcode 150 Evaluate Reverse Polish Notation</h4><blockquote>
<p>逆波兰表达式</p>
</blockquote>
<h4 id="Leetcode-71-Simplify-Path"><a href="#Leetcode-71-Simplify-Path" class="headerlink" title="Leetcode 71 Simplify Path"></a>Leetcode 71 Simplify Path</h4><blockquote>
<p>简化路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 71 简化路径</span><br><span class="line">public String simplifyPath(String path) &#123;</span><br><span class="line">    if(path.isEmpty()) return null;</span><br><span class="line">    String[] split &#x3D; path.split(&quot;&#x2F;&quot;);</span><br><span class="line">    Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 利用&#x2F;分割，遇到..就去除上一个元素</span><br><span class="line">    for (String s : split) &#123;</span><br><span class="line">        if(!stack.isEmpty() &amp;&amp; s.equals(&quot;..&quot;))&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            &#x2F;&#x2F; 否则的话如果不是&quot;&quot;，&quot;.&quot;，或者&quot;..&quot;都添加即可</span><br><span class="line">        &#125;else if(!s.equals(&quot;&quot;) &amp;&amp; !s.equals(&quot;.&quot;) &amp;&amp; !s.equals(&quot;..&quot;))&#123;</span><br><span class="line">            stack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stack.isEmpty())&#123;</span><br><span class="line">        return &quot;&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; stack.size(); i++) &#123;</span><br><span class="line">        sb.append(&quot;&#x2F;&quot;).append(stack.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈与递归的紧密关系"><a href="#栈与递归的紧密关系" class="headerlink" title="栈与递归的紧密关系"></a>栈与递归的紧密关系</h3><blockquote>
<p>二叉树的递归处理</p>
</blockquote>
<h4 id="Leetcode-144-Binary-Tree-Preorder-Taversal"><a href="#Leetcode-144-Binary-Tree-Preorder-Taversal" class="headerlink" title="Leetcode 144 Binary Tree Preorder Taversal"></a>Leetcode 144 Binary Tree Preorder Taversal</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 144. 二叉树的前序遍历</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归实现</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    executePreorder(root,res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void executePreorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">    if(root &#x3D;&#x3D; null) return;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    executePreorder(root.left,res);</span><br><span class="line">    executePreorder(root.right,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 迭代实现 &#x3D;&#x3D;&gt; 用stack实现啊</span><br><span class="line">public List&lt;Integer&gt; preorderTraversalII(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    TreeNode pool;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        pool &#x3D; stack.pop();</span><br><span class="line">        res.add(pool.val);</span><br><span class="line">        if(pool.right !&#x3D; null)&#123;</span><br><span class="line">            stack.add(pool.right);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pool.left !&#x3D; null)&#123;</span><br><span class="line">            stack.add(pool.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-94-Binary-Tree-Inorder-Traversal"><a href="#Leetcode-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="Leetcode 94 Binary Tree Inorder Traversal"></a>Leetcode 94 Binary Tree Inorder Traversal</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 94. 二叉树的中序遍历</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode peek;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        &#x2F;&#x2F; 怎么把左边的值去掉呢</span><br><span class="line">        peek &#x3D; stack.peek();</span><br><span class="line">        if(peek.left !&#x3D; null)&#123;</span><br><span class="line">            stack.push(peek.left);</span><br><span class="line">            peek.left &#x3D; null;&#x2F;&#x2F; 一定要注意将左边的值去掉</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node &#x3D; stack.pop();</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        if(peek.right !&#x3D; null)&#123;</span><br><span class="line">            stack.push(peek.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-145-Binary-Tree-Postorder-Traversal"><a href="#Leetcode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="Leetcode 145 Binary Tree Postorder Traversal"></a>Leetcode 145 Binary Tree Postorder Traversal</h4><blockquote>
<p>可以自定义栈操作来实现非递归实现二叉树的三种遍历形式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 145. 二叉树的后序遍历</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            if (peek.left !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek.left);</span><br><span class="line">                peek.left &#x3D; null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 现在到了中间节点-需要看是是否有右节点。</span><br><span class="line">            if (peek.right !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek.right);</span><br><span class="line">                peek.right &#x3D; null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 否则就到了中间节点，此时必须加入</span><br><span class="line">            TreeNode pop &#x3D; stack.pop();</span><br><span class="line">            res.add(pop.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 面对一切需要面对的！战胜一切需要面对的！</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;Integer&gt; postOrderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            if (peek !&#x3D; null) &#123;</span><br><span class="line">                stack.push(peek);</span><br><span class="line">                stack.push(null);&#x2F;&#x2F; 用null值来确保没有处理</span><br><span class="line">                if (peek.right !&#x3D; null) stack.push(peek.right);</span><br><span class="line">                if (peek.left !&#x3D; null) stack.push(peek.left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.add(stack.pop().val);&#x2F;&#x2F; 遇到null，把null下面一个取出即可</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; postOrderTraversalII(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode pre &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 秒啊，利用pre做指针，每次都去判断是否是处理过的点，pre的作用就是是否是处理过的点！</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode peek &#x3D; stack.peek();</span><br><span class="line">            &#x2F;&#x2F; 这里的判断条件是看当前的peek是否是到了最后一个点，也就是第一个添加的点</span><br><span class="line">            &#x2F;&#x2F; 或者说是pre不为null，处理过，且此时位置为未处理的，才添加</span><br><span class="line">            if ((peek.left &#x3D;&#x3D; null &amp;&amp; peek.right &#x3D;&#x3D; null)</span><br><span class="line">                    || (pre !&#x3D; null &amp;&amp; (pre &#x3D;&#x3D; peek.right || pre &#x3D;&#x3D; peek.left))) &#123;</span><br><span class="line">                res.add(peek.val);</span><br><span class="line">                pre &#x3D; peek;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (peek.right !&#x3D; null) stack.add(peek.right);</span><br><span class="line">                if (peek.left !&#x3D; null) stack.add(peek.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-341-Flatten-Nested-List-Iterator"><a href="#Leetcode-341-Flatten-Nested-List-Iterator" class="headerlink" title="Leetcode 341 Flatten Nested List Iterator"></a>Leetcode 341 Flatten Nested List Iterator</h4><blockquote>
<p>递归添加就好，可以使用栈和list解决</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">    add(nestedList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void add(List&lt;NestedInteger&gt; nestedList)&#123;</span><br><span class="line">    for (NestedInteger nestedInteger : nestedList) &#123;</span><br><span class="line">        if(nestedInteger.isInteger())&#123;</span><br><span class="line">            res.add(nestedInteger.getInteger());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            List&lt;NestedInteger&gt; list &#x3D; nestedInteger.getList();</span><br><span class="line">            add(list);&#x2F;&#x2F; 递归添加</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">    return res.size() !&#x3D; index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Integer next() &#123;</span><br><span class="line">    return res.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="Leetcode-102-Binary-Tree-Level-Order-Traversal"><a href="#Leetcode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="Leetcode 102 Binary Tree Level Order Traversal"></a>Leetcode 102 Binary Tree Level Order Traversal</h4><blockquote>
<p>层序遍历</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 层序遍历</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll &#x3D; queue.poll();</span><br><span class="line">                if(poll.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(poll.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(poll.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-107-Binary-Tree-Level-Order-Traversal-II"><a href="#Leetcode-107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Leetcode 107 Binary Tree Level Order Traversal II"></a>Leetcode 107 Binary Tree Level Order Traversal II</h4><blockquote>
<p>层序遍历，反过来插</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll &#x3D; queue.poll();</span><br><span class="line">                if(poll.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(poll.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(poll.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(0,list);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Leetcode 103 Binary Tree Zigzag Level Order Traversal"></a>Leetcode 103 Binary Tree Zigzag Level Order Traversal</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Z字形打印</span><br><span class="line">    &#x2F;&#x2F; 使用flag作为分界，先进先出只改变插入顺序</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        boolean flag &#x3D; true;&#x2F;&#x2F; 表名偶数</span><br><span class="line">        TreeNode temp &#x3D; null;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                temp &#x3D; queue.poll();</span><br><span class="line">                &#x2F;&#x2F; 根据flag判断为正序还是逆序插入</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    list.add(temp.val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    list.add(0,temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.left !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.right !&#x3D; null)&#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            flag&#x3D;!flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 双栈策略：是指就是模拟了一个队列而已</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrderII(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        stack1.push(root);</span><br><span class="line">        boolean flag &#x3D; true;</span><br><span class="line">        while(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                while (!stack1.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop &#x3D; stack1.pop();</span><br><span class="line">                    if(pop.left !&#x3D; null)&#123;</span><br><span class="line">                        stack2.push(pop.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(pop.right !&#x3D; null)&#123;</span><br><span class="line">                        stack2.push(pop.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(pop.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(!stack2.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop &#x3D; stack2.pop();</span><br><span class="line">                    if(pop.right !&#x3D; null)&#123;</span><br><span class="line">                        stack1.push(pop.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(pop.left !&#x3D; null)&#123;</span><br><span class="line">                        stack1.push(pop.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(pop.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            flag &#x3D; !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-199-Binary-Tree-Right-Side-View"><a href="#Leetcode-199-Binary-Tree-Right-Side-View" class="headerlink" title="Leetcode 199 Binary Tree Right Side View"></a>Leetcode 199 Binary Tree Right Side View</h4><blockquote>
<p>二叉树的右视图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 199 二叉树的右视图</span><br><span class="line">    &#x2F;&#x2F; 广度优先遍历</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (null &#x3D;&#x3D; root) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        &#x2F;&#x2F; 只存最右的节点即可</span><br><span class="line">        TreeNode poll;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int size &#x3D; queue.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                poll &#x3D; queue.poll();</span><br><span class="line">                if (i &#x3D;&#x3D; size - 1) &#123;</span><br><span class="line">                    res.add(poll.val);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll.left !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll.right !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 深度优先遍历解决</span><br><span class="line">    public List&lt;Integer&gt; rightSideViewII(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        executeRight(root, 0, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void executeRight(TreeNode root, int depth, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据list的size来的，一层只能有一个</span><br><span class="line">        if (root &#x3D;&#x3D; null) return;</span><br><span class="line">        if (depth &#x3D;&#x3D; res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        executeRight(root.right, depth + 1, res);</span><br><span class="line">        executeRight(root.left, depth + 1, res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="BFS和图的最短路径"><a href="#BFS和图的最短路径" class="headerlink" title="BFS和图的最短路径"></a>BFS和图的最短路径</h3><h4 id="Leetcode-279-Perfect-Squares"><a href="#Leetcode-279-Perfect-Squares" class="headerlink" title="Leetcode 279 Perfect Squares"></a>Leetcode 279 Perfect Squares</h4><blockquote>
<p>完全平方数</p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n = 12<br> 输出: 3<br> 解释: 12 = 4 + 4 + 4.</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：类似于寻找最短路径，放入第一次的路径长度，步数。每次寻找的时候，将相应的可以获取到平方数的计算路径与步数放入其中，一旦路径为0，表明此时步数是最短的。输出即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 放入当前数与当前数走的步数，也就是最短路径问题</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> Pair(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 为避免重复计算</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        visited[n] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair poll = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> num = poll.first;</span><br><span class="line">            <span class="keyword">int</span> step = poll.second;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则的话</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; num - i * i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = num - i * i;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果之前没有计算过</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[a]) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Pair(a, step + <span class="number">1</span>));</span><br><span class="line">                    visited[a] = <span class="keyword">true</span>; <span class="comment">// 已访问过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用动态规划的方式来做</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquaresII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 12 = 4 + 4 + 4  =3</span></span><br><span class="line">        <span class="comment">// 13 = 4 + 9 =2</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i;<span class="comment">// 所有的都用1表示的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="keyword">int</span>) Math.sqrt(i); j++) &#123;</span><br><span class="line">                <span class="comment">// 4的话，1 1 1 4,这是一轮算下来，当前数最小表示的是多少</span></span><br><span class="line">                <span class="comment">// 利用用1表示的所有，与自己之前j平方大小的数+1(即j)这个数相比较谁小取谁</span></span><br><span class="line">                r = Math.min(r, res[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-127-Word-Ladder"><a href="#Leetcode-127-Word-Ladder" class="headerlink" title="Leetcode 127 Word Ladder"></a>Leetcode 127 Word Ladder</h4><blockquote>
<p>单词接龙</p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br> 转换过程中的中间单词必须是字典中的单词。<br> 说明:</p>
<p>如果不存在这样的转换序列，返回 0。<br> 所有单词具有相同的长度。<br> 所有单词只由小写字母组成。<br> 字典中不存在重复的单词。<br> 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br> 示例 1:</p>
<p>输入:<br> beginWord = “hit”,<br> endWord = “cog”,<br> wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出: 5</p>
<p>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br> 返回它的长度 5。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/word-ladder" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>这一题整体的思路是：通过set数据结构去重复，然后通过遍历来获取，如果变换所有的都不再wordlist中只能说明当前的元素不可通过中间值转换，如果可以转换的话，依次替换字符串每个位置的元素进行替换，判断是否能够存在于end中，不存在继续往后走，每次的start都选择少的哪一个！有利于减少判断次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 127 单词接龙</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 不存在的话直接为0</span></span><br><span class="line">       <span class="keyword">if</span> (!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Set&lt;String&gt; start = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; word = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">       String template = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">       <span class="keyword">char</span>[] array = template.toCharArray();</span><br><span class="line">       <span class="comment">// 有一个终止条件是什么呢？</span></span><br><span class="line">       start.add(beginWord);</span><br><span class="line">       end.add(endWord);</span><br><span class="line">       <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!start.isEmpty()) &#123;</span><br><span class="line">           step++;</span><br><span class="line">           Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           word.removeAll(start);<span class="comment">// 移除所有使用过的元素</span></span><br><span class="line">           <span class="keyword">for</span> (String s : start) &#123;</span><br><span class="line">               <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">char</span> tmp = chars[i];</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                       <span class="comment">// 相等直接跳过</span></span><br><span class="line">                       <span class="keyword">if</span> (tmp == array[j]) <span class="keyword">continue</span>;</span><br><span class="line">                       <span class="comment">// 否则交换</span></span><br><span class="line">                       chars[i] = array[j];</span><br><span class="line">                       String tempStr = <span class="keyword">new</span> String(chars);</span><br><span class="line">                       <span class="keyword">if</span> (word.contains(tempStr)) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (end.contains(tempStr)) &#123;</span><br><span class="line">                               <span class="keyword">return</span> step;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 这里面存放的表示当前可以作为中转的字符</span></span><br><span class="line">                               tempSet.add(tempStr);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   chars[i] = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 从少的那边开始计算</span></span><br><span class="line">           <span class="keyword">if</span> (tempSet.size() &lt; end.size()) &#123;</span><br><span class="line">               start = tempSet;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               start = end;</span><br><span class="line">               end = tempSet;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用递归来处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLengthII</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Set&lt;String&gt; start = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; word = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">       start.add(beginWord);</span><br><span class="line">       end.add(endWord);</span><br><span class="line">       <span class="keyword">return</span> executeLadder(start, end, word, <span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeLadder</span><span class="params">(Set&lt;String&gt; start, Set&lt;String&gt; end, Set&lt;String&gt; word, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 这个就是终止条件，一旦为0，表示所有替换的都不再word中，即不可转换</span></span><br><span class="line">       <span class="keyword">if</span> (start.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (start.size() &gt; end.size()) &#123; <span class="comment">// 永远以小端查询大端，减少比对次数</span></span><br><span class="line">           <span class="keyword">return</span> executeLadder(end, start, word, res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果不小于0的话继续</span></span><br><span class="line">       word.removeAll(start);<span class="comment">// 移除使用过的</span></span><br><span class="line">       Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String s : start) &#123; <span class="comment">// 遍历所有的</span></span><br><span class="line">           <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">               <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (temp == c) <span class="keyword">continue</span>;</span><br><span class="line">                   chars[i] = c;</span><br><span class="line">                   String tempStr = <span class="keyword">new</span> String(chars);</span><br><span class="line">                   <span class="comment">// 一定要在word中才有机会往下走</span></span><br><span class="line">                   <span class="keyword">if</span> (word.contains(tempStr)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (end.contains(tempStr)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> res;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           tempSet.add(tempStr);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               chars[i] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 默认把tempSet当做start，因为前面已经有做判断</span></span><br><span class="line">       <span class="keyword">return</span> executeLadder(tempSet, end, word, res + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-126-Word-Ladder-II"><a href="#Leetcode-126-Word-Ladder-II" class="headerlink" title="Leetcode 126 Word Ladder II"></a>Leetcode 126 Word Ladder II</h4><blockquote>
<p>单词接龙II</p>
</blockquote>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="Leetcode-347-Top-K-Frequent-Elements"><a href="#Leetcode-347-Top-K-Frequent-Elements" class="headerlink" title="Leetcode 347 Top K Frequent Elements"></a>Leetcode 347 Top K Frequent Elements</h4><blockquote>
<p>使用优先队列来维护</p>
<p>1.排序取前k个，时间复杂度O(nlogn)</p>
<p>2.维护优先队列，时间复杂度O(nlogk)</p>
<p>3.维护优先队列，时间复杂度O(nlog(n-k))</p>
</blockquote>
<h4 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h4><h2 id="二叉树和递归"><a href="#二叉树和递归" class="headerlink" title="二叉树和递归"></a>二叉树和递归</h2><blockquote>
<p>递归两部分：</p>
<ol>
<li><p>递归终止条件</p>
</li>
<li><p>递归的运算过程</p>
</li>
</ol>
</blockquote>
<h4 id="Leetcode-104-Maximum-Depth-of-Binary-Tree"><a href="#Leetcode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 104 Maximum Depth of Binary Tree"></a>Leetcode 104 Maximum Depth of Binary Tree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> executeMaxDepth(root, depth);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeMaxDepth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 左边一直向下知道最后，依次+1，右边一直向下，依次+1</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(executeMaxDepth(root.left, depth), executeMaxDepth(root.right, depth)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-111-Minimum-Depth-of-Binary-Tree"><a href="#Leetcode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 111 Minimum Depth of Binary Tree"></a>Leetcode 111 Minimum Depth of Binary Tree</h4><blockquote>
<p>求的最短的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> executeMinDepth(root, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeMinDepth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要保证一定是叶子节点，如果不是叶子节点也不可行</span></span><br><span class="line">        <span class="comment">// 只管一边即可如果有不为null的,只需要考虑一边即可</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + executeMinDepth(root.right, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + executeMinDepth(root.left, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两边同时不为null，才有资格往下走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(executeMinDepth(root.left, depth), executeMinDepth(root.right, depth));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-226-Invert-Binary-Tree"><a href="#Leetcode-226-Invert-Binary-Tree" class="headerlink" title="Leetcode 226 Invert Binary Tree"></a>Leetcode 226 Invert Binary Tree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 否则进行左右交换</span></span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = temp;</span><br><span class="line">        root.left = invertTree(root.left);</span><br><span class="line">        root.right = invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-100-Same-Tree"><a href="#Leetcode-100-Same-Tree" class="headerlink" title="Leetcode 100 Same Tree"></a>Leetcode 100 Same Tree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断两棵树是否相同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 开始比较,从头开始，延伸到左右节点</span></span><br><span class="line">       <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-101-Symmetric-Tree"><a href="#Leetcode-101-Symmetric-Tree" class="headerlink" title="Leetcode 101 Symmetric Tree"></a>Leetcode 101 Symmetric Tree</h4><blockquote>
<p>对称二叉树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前数是否是对称树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">return</span> judgementSymmetric(root.left, root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgementSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 判断当前是否相等，然后判断左边的左是否等于右边的右，反之亦然</span></span><br><span class="line">       <span class="keyword">return</span> left.val == right.val &amp;&amp; judgementSymmetric(left.left, right.right)</span><br><span class="line">               &amp;&amp; judgementSymmetric(left.right, right.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-222-Count-Complete-Tree-Nodes"><a href="#Leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="Leetcode 222 Count Complete Tree Nodes"></a>Leetcode 222 Count Complete Tree Nodes</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 完全二叉树的节点个数</span></span><br><span class="line"><span class="comment">    * 第一种方法如下，但是这种做法没有利用到完全二叉树的性质</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       count += <span class="number">1</span>;</span><br><span class="line">       count += countNodes(root.left);</span><br><span class="line">       count += countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第二种方法就是借助左右子树的高度来判断</span></span><br><span class="line"><span class="comment">    * 借助计算公式(2^h-1)来判断当前的节点个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes_II</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> l = getDepth(root.left);</span><br><span class="line">       <span class="keyword">int</span> r = getDepth(root.right);</span><br><span class="line">       <span class="comment">// 这边表示，如果左边大于右边，表示右边一定是满的，所以去查找左边</span></span><br><span class="line">       <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; r) - <span class="number">1</span> + countNodes(root.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 否则只能相等了，以为不可能右边大于左边的,相等的情况，左边一定是满的</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; l) - <span class="number">1</span> + countNodes(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 由于是完全二叉树，高度完全取决于左边节点</span></span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">           res++;</span><br><span class="line">           root = root.left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-110-Balanced-Binary-Tree"><a href="#Leetcode-110-Balanced-Binary-Tree" class="headerlink" title="Leetcode 110 Balanced Binary Tree"></a>Leetcode 110 Balanced Binary Tree</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 判断左右高度，然后分别判断左右高度就好了</span></span><br><span class="line">       <span class="keyword">return</span> Math.abs(getDepthII(root.left) - getDepthII(root.right)) &lt;= <span class="number">1</span></span><br><span class="line">               &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepthII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(getDepthII(root.left), getDepthII(root.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-112-Path-Sum"><a href="#Leetcode-112-Path-Sum" class="headerlink" title="Leetcode 112 Path Sum"></a>Leetcode 112 Path Sum</h4><blockquote>
<p>二叉树和为Sum的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 路径总和就是判断是否有当前路径+起来的等于指定和的分支</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果往后一直都没有为0的话，而root又到了null，此时直接返回false</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 但凡能满足的都会在这里被拦截</span></span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> sum - root.val == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向左向右走</span></span><br><span class="line">      <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-404-Sum-of-Left-Leaves"><a href="#Leetcode-404-Sum-of-Left-Leaves" class="headerlink" title="Leetcode 404 Sum of Left Leaves"></a>Leetcode 404 Sum of Left Leaves</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 404. 计算左叶子的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> execute(root, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边表示是左树即true，如果是右边的话使用false</span></span><br><span class="line">        sum += execute(root.left, <span class="keyword">true</span>);</span><br><span class="line">        sum += execute(root.right, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 看评论别人的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeavesII</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += sumOfLeftLeaves(root.left);</span><br><span class="line">        sum += sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-257-Binary-Tree-Paths"><a href="#Leetcode-257-Binary-Tree-Paths" class="headerlink" title="Leetcode 257 Binary Tree Paths"></a>Leetcode 257 Binary Tree Paths</h4><blockquote>
<p>二叉树的所有路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树的所有路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">       executeBinaryTreePaths(root, res, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeBinaryTreePaths</span><span class="params">(TreeNode root, List&lt;String&gt; res, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       sb.append(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           res.add(sb.toString());<span class="comment">// 这是最终的归宿</span></span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder append = sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">       <span class="comment">// 否则的话，依旧要继续衔接下去，要回到最初始的状态,所以构造新的对象，否则对象sb会被复用</span></span><br><span class="line">       executeBinaryTreePaths(root.left,res,<span class="keyword">new</span> StringBuilder(append));</span><br><span class="line">       executeBinaryTreePaths(root.right,res,<span class="keyword">new</span> StringBuilder(append));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-113-Path-Sum-II"><a href="#Leetcode-113-Path-Sum-II" class="headerlink" title="Leetcode 113 Path Sum II"></a>Leetcode 113 Path Sum II</h4><h4 id="Leetcode-129-Sum-Root-to-Leaf-Numbers"><a href="#Leetcode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="Leetcode 129 Sum Root to Leaf Numbers"></a>Leetcode 129 Sum Root to Leaf Numbers</h4><h3 id="更加复杂的递归逻辑"><a href="#更加复杂的递归逻辑" class="headerlink" title="更加复杂的递归逻辑"></a>更加复杂的递归逻辑</h3><h4 id="Leetcode-437-Path-Sum-III"><a href="#Leetcode-437-Path-Sum-III" class="headerlink" title="Leetcode 437 Path Sum III"></a>Leetcode 437 Path Sum III</h4><blockquote>
<p>含有子递归</p>
</blockquote>
<h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><h4 id="Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Leetcode 235 Lowest Common Ancestor of a Binary Search Tree"></a>Leetcode 235 Lowest Common Ancestor of a Binary Search Tree</h4><blockquote>
<p>二分搜索树的最近公共祖先</p>
</blockquote>
<h4 id="Leetcode-98-Validate-Binary-Search-Tree"><a href="#Leetcode-98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode 98 Validate Binary Search Tree"></a>Leetcode 98 Validate Binary Search Tree</h4><h4 id="Leetcode-450-Delete-Node-in-a-BST"><a href="#Leetcode-450-Delete-Node-in-a-BST" class="headerlink" title="Leetcode 450 Delete Node in a BST"></a>Leetcode 450 Delete Node in a BST</h4><blockquote>
<p>删除二分搜索树的节点</p>
</blockquote>
<h4 id="Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Leetcode 108 Convert Sorted Array to Binary Search Tree"></a>Leetcode 108 Convert Sorted Array to Binary Search Tree</h4><h4 id="Leetcode-230-Kth-Smallest-Element-in-a-BST"><a href="#Leetcode-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="Leetcode 230 Kth Smallest Element in a BST"></a>Leetcode 230 Kth Smallest Element in a BST</h4><h4 id="Leetcode-236-Lowest-Common-Ancestor-of-a-Search-Tree（LCA问题）"><a href="#Leetcode-236-Lowest-Common-Ancestor-of-a-Search-Tree（LCA问题）" class="headerlink" title="Leetcode 236 Lowest Common Ancestor of a Search Tree（LCA问题）"></a>Leetcode 236 Lowest Common Ancestor of a Search Tree（LCA问题）</h4><blockquote>
<p>二叉树的最近公共祖先</p>
</blockquote>
<h2 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h2><h3 id="回溯法解决排列问题"><a href="#回溯法解决排列问题" class="headerlink" title="回溯法解决排列问题"></a>回溯法解决排列问题</h3><h4 id="Leetcode-17-Letter-Combinations-of-a-Phone-Number"><a href="#Leetcode-17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Leetcode 17 Letter Combinations of a Phone Number"></a>Leetcode 17 Letter Combinations of a Phone Number</h4><blockquote>
<p>电话号码的字母组合</p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<p>输入：”23”<br> 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>利用递归进行处理，在遍历过程中采用递归，即可，因为是需要多重组合，只需要依次遍历即可获取到多重组合。终止条件需要判断拼凑的s是否与原字符的长度相等，相等即终止！可以将其画成树，会更好理解。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String[] letters &#x3D; new String[]&#123;&quot; &quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">private List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">  res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (digits.length() &lt; 1) &#123;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  findCombinations(digits, 0, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void findCombinations(String digits, int index, String s) &#123;</span><br><span class="line">  &#x2F;&#x2F; s的长度一定是要与digits长度相同</span><br><span class="line">  if (s.length() &#x3D;&#x3D; digits.length()) &#123;</span><br><span class="line">    res.add(s);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  char c &#x3D; digits.charAt(index);</span><br><span class="line">  String letter &#x3D; letters[c - &#39;0&#39;];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; letter.length(); i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归下去</span><br><span class="line">    findCombinations(digits, index + 1, s + letter.charAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-93-Restore-IP-Addresses"><a href="#Leetcode-93-Restore-IP-Addresses" class="headerlink" title="Leetcode 93 Restore IP Addresses"></a>Leetcode 93 Restore IP Addresses</h4><h4 id="Leetcode-131-Palindrome-Partitioning"><a href="#Leetcode-131-Palindrome-Partitioning" class="headerlink" title="Leetcode 131 Palindrome Partitioning"></a>Leetcode 131 Palindrome Partitioning</h4><h4 id="Leetcode-46-Permutations"><a href="#Leetcode-46-Permutations" class="headerlink" title="Leetcode 46 Permutations"></a>Leetcode 46 Permutations</h4><blockquote>
<p>全排列</p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/permutations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路：</p>
<p>一般回溯法都是结合递归，最好使用树的形式来画出递归的情况，很容易就出来了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; perRes;</span><br><span class="line">private boolean[] used;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">  perRes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  used &#x3D; new boolean[nums.length];</span><br><span class="line">  if (nums.length &lt; 1) return perRes;</span><br><span class="line">  generatePermute(nums, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line">  return perRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generatePermute(int[] nums, int index, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  &#x2F;&#x2F; 终止条件也就是当前的list入结果集</span><br><span class="line">  if (list.size() &#x3D;&#x3D; nums.length) &#123;</span><br><span class="line">    perRes.add(new ArrayList&lt;&gt;(list));&#x2F;&#x2F; 注意这里的添加需要将其组合为list，否则会为null</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话需要继续进行递归操作</span><br><span class="line">  for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证每一次递归的每一个变量的唯一性</span><br><span class="line">    if (!used[i]) &#123;</span><br><span class="line">      list.add(nums[i]);</span><br><span class="line">      used[i] &#x3D; true;</span><br><span class="line">      generatePermute(nums, index, list);</span><br><span class="line">      &#x2F;&#x2F; 递归调用完毕之后需要回溯</span><br><span class="line">      list.remove(list.size() - 1);</span><br><span class="line">      used[i] &#x3D; false; &#x2F;&#x2F; 释放为可用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-47-Permutations-II"><a href="#Leetcode-47-Permutations-II" class="headerlink" title="Leetcode 47 Permutations II"></a>Leetcode 47 Permutations II</h4><h3 id="回溯法解决组合问题"><a href="#回溯法解决组合问题" class="headerlink" title="回溯法解决组合问题"></a>回溯法解决组合问题</h3><h4 id="Leetcode-77-Combinations"><a href="#Leetcode-77-Combinations" class="headerlink" title="Leetcode 77 Combinations"></a>Leetcode 77 Combinations</h4><blockquote>
<p>组合</p>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/combinations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>组合与排列不同，但是底层都是递归结合回溯操作来使得递归持续进行下去。还是画图比较可靠。</p>
<p>时间复杂度：O(kCkn)，空间复杂度：O(Ckn)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; resCombine;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组合</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">  resCombine &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  if (n &lt;&#x3D; 0 || k &lt;&#x3D; 0 || k &gt; n) return resCombine;</span><br><span class="line">  &#x2F;&#x2F; 注意index从1开始</span><br><span class="line">  generateCombine(n, 1, k, new ArrayList&lt;Integer&gt;());</span><br><span class="line">  return resCombine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generateCombine(int n, int index, int k, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  if (list.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">    resCombine.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话需要进行递归操作</span><br><span class="line">  &#x2F;&#x2F; 由于到了最后的元素地方，可以不用计算，俗称剪枝操作</span><br><span class="line">  &#x2F;&#x2F; 到了这里需要填补的数据个数为k-list.size()，即[i...n]还缺k-list.size个元素</span><br><span class="line">  &#x2F;&#x2F; 此时总数为n，则可以得到i的范围为n-(k-list.size)+1</span><br><span class="line">  for (int i &#x3D; index; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">    generateCombine(n, i + 1, k, list);</span><br><span class="line">    &#x2F;&#x2F; 进行回溯操作</span><br><span class="line">    list.remove(list.size() - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回溯法的剪枝"><a href="#回溯法的剪枝" class="headerlink" title="回溯法的剪枝"></a>回溯法的剪枝</h3><blockquote>
<p>剪枝就是剪去无意义的那些处理数据。</p>
<p>上述组合问题，剪枝操作之后，击败99.48%，优化了时间</p>
</blockquote>
<h4 id="Leetcode-39-Combination-Sum"><a href="#Leetcode-39-Combination-Sum" class="headerlink" title="Leetcode 39 Combination Sum"></a>Leetcode 39 Combination Sum</h4><h4 id="Leetcode-40-Combination-Sum-II"><a href="#Leetcode-40-Combination-Sum-II" class="headerlink" title="Leetcode 40 Combination Sum II"></a>Leetcode 40 Combination Sum II</h4><h4 id="Leetcode-216-Combination-Sum-III"><a href="#Leetcode-216-Combination-Sum-III" class="headerlink" title="Leetcode 216 Combination Sum III"></a>Leetcode 216 Combination Sum III</h4><h4 id="Leetcode-78-Subsets"><a href="#Leetcode-78-Subsets" class="headerlink" title="Leetcode 78 Subsets"></a>Leetcode 78 Subsets</h4><h4 id="Leetcode-90-Subsets-II"><a href="#Leetcode-90-Subsets-II" class="headerlink" title="Leetcode 90 Subsets II"></a>Leetcode 90 Subsets II</h4><h4 id="Leetcode-401-Binary-Watch"><a href="#Leetcode-401-Binary-Watch" class="headerlink" title="Leetcode 401 Binary Watch"></a>Leetcode 401 Binary Watch</h4><h3 id="二维平面上使用回溯法"><a href="#二维平面上使用回溯法" class="headerlink" title="二维平面上使用回溯法"></a>二维平面上使用回溯法</h3><h4 id="Leetcode-79-Word-Search"><a href="#Leetcode-79-Word-Search" class="headerlink" title="Leetcode 79 Word Search"></a>Leetcode 79 Word Search</h4><blockquote>
<p>单词搜索</p>
<p>利用偏移量数组来处理二维平面中的算法题</p>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<p>给定 word = “ABCCED”, 返回 true<br> 给定 word = “SEE”, 返回 true<br> 给定 word = “ABCB”, 返回 false</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/word-search" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>首先明确此题是需要进行递归回溯操作的，但是注意，由于起始点并不一定是初始点，此时需要根据状态的信息进行一个遍历，对所有的起始点进行一个遍历操作，看看是否能获取答案。其次，由于路径不可复用，此时需要设置一个访问visited的全局变量，控制同一位置的二次访问。注意由于需要保持回溯的性质，当返回false的时候，需要将当前访问状态置为false（visited是全局变量）。</p>
<p>递归的终止条件即当index为单词最后一个字符的下标时，此时返回是否找到。执行过程的话，首先需要判断有没有满足初始入口，如果不满足，直接返回false。满足的话，此时就拥有了四种属性，上下左右查找，看看四个方向是否有满足的。此时一般使用偏移量数组来表示上下左右的相对关系。遍历四个方向，每一个方向使用递归。边界条件是不能够越界(行列)且没有访问过。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int m;</span><br><span class="line">private int n;</span><br><span class="line">private int[][] offset &#x3D; new int[][]&#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">private boolean[][] visited;</span><br><span class="line"></span><br><span class="line">public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">  &#x2F;&#x2F; 行列</span><br><span class="line">  m &#x3D; board.length;</span><br><span class="line">  n &#x3D; board[0].length;</span><br><span class="line">  visited &#x3D; new boolean[m][n];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 进入递归过程</span><br><span class="line">      if (searchWord(board, word, 0, i, j)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean searchWord(char[][] board, String word, int index, int startx, int starty) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if (index &#x3D;&#x3D; word.length() - 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要判断最后的字符是否相等</span><br><span class="line">    return board[startx][starty] &#x3D;&#x3D; word.charAt(index);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 否则的话此时需要判断上下左右，但是判断之前需要看当前的startx与starty是否满足条件</span><br><span class="line">  &#x2F;&#x2F; 且需要排除访问过的字符</span><br><span class="line">  &#x2F;&#x2F; 此时需要对上下左右进行查找</span><br><span class="line">  &#x2F;&#x2F; 相等的时候才进来，否则直接返回false，证明当前字母不符合条件</span><br><span class="line">  if (word.charAt(index) &#x3D;&#x3D; board[startx][starty]) &#123;</span><br><span class="line">    visited[startx][starty] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里的startx与starty应该保持不变，否则回来的时候值就发生了辩护有</span><br><span class="line">      int x &#x3D; startx + offset[i][0];</span><br><span class="line">      int y &#x3D; starty + offset[i][1];</span><br><span class="line">      &#x2F;&#x2F; 在其中进行查找</span><br><span class="line">      &#x2F;&#x2F; 如果在其中，且没有访问过，且能够找到一条路径，返回true</span><br><span class="line">      &#x2F;&#x2F; 如果在其中，且没有访问过，不能够找到一条路径，此时需要回溯</span><br><span class="line">      if (inArea(x, y) &amp;&amp; !visited[x][y]) &#123;</span><br><span class="line">        if (searchWord(board, word, index + 1, x, y)) &#123;</span><br><span class="line">          &#x2F;&#x2F; 成功才有机会进入，返回true</span><br><span class="line">          return true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  visited[startx][starty] &#x3D; false;&#x2F;&#x2F; 返回false的话就需要释放</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean inArea(int x, int y) &#123;</span><br><span class="line">  return x &gt;&#x3D; 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="floodfill算法-经典问题"><a href="#floodfill算法-经典问题" class="headerlink" title="floodfill算法-经典问题"></a>floodfill算法-经典问题</h3><blockquote>
<p>寓意洪水泛滥，即水的漫延</p>
</blockquote>
<h4 id="Leecode-200-Number-of-Islands"><a href="#Leecode-200-Number-of-Islands" class="headerlink" title="Leecode 200 Number of Islands"></a>Leecode 200 Number of Islands</h4><blockquote>
<p>岛屿数量</p>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br> 11110<br> 11010<br> 11000<br> 00000</p>
<p>输出: 1<br> 示例 2:</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>凡递归必有终止条件，只是终止条件与执行过程中的判断会有重复，可以省略终止条件。</p>
<p>这里的思路就是只要是有效的1，就算作岛屿。然后将其连接的所有1都做上标记。此时就类似于洪水漫延的感觉，转换思路，只留下有效的1作为岛屿数量！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为1则为岛屿</span><br><span class="line">private int row;</span><br><span class="line">private int col;</span><br><span class="line">private int[][] d &#x3D; new int[][]&#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">private boolean[][] visit;</span><br><span class="line"></span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">  row &#x3D; grid.length;</span><br><span class="line">  if (row &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有元素</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  col &#x3D; grid[0].length;</span><br><span class="line">  visit &#x3D; new boolean[row][col];</span><br><span class="line">  int num &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; col; j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有访问过，且最后找到了岛屿，则数量加一</span><br><span class="line">      &#x2F;&#x2F; 这里转换思路，只需要将递归的过程设置为标记的过程即可。</span><br><span class="line">      if (!visit[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        findIslands(grid, i, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void findIslands(char[][] grid, int row, int col) &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里的递归终止条件，当前点四个方向都被访问了，或者四周都已经被使用了</span><br><span class="line">  visit[row][col] &#x3D; true;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">    int x &#x3D; row + d[i][0];</span><br><span class="line">    int y &#x3D; col + d[i][1];</span><br><span class="line">    &#x2F;&#x2F; 递归终止条件-&gt;包含在当前的判断条件中了</span><br><span class="line">    if (inLandArea(x, y) &amp;&amp; !visit[x][y] &amp;&amp; grid[row][col] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">      findIslands(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean inLandArea(int x, int y) &#123;</span><br><span class="line">  return x &gt;&#x3D; 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-130-Surrounded-Regions"><a href="#Leetcode-130-Surrounded-Regions" class="headerlink" title="Leetcode 130 Surrounded Regions"></a>Leetcode 130 Surrounded Regions</h4><h4 id="Leetcode-417-Pacific-Atlantic-Water-Flow"><a href="#Leetcode-417-Pacific-Atlantic-Water-Flow" class="headerlink" title="Leetcode 417 Pacific Atlantic Water Flow"></a>Leetcode 417 Pacific Atlantic Water Flow</h4><h3 id="回溯法是经典人工智能的基础"><a href="#回溯法是经典人工智能的基础" class="headerlink" title="回溯法是经典人工智能的基础"></a>回溯法是经典人工智能的基础</h3><h4 id="Leetcode-52-N-Queens"><a href="#Leetcode-52-N-Queens" class="headerlink" title="Leetcode 52 N-Queens"></a>Leetcode 52 N-Queens</h4><blockquote>
<p>递归+回溯+剪枝+相关优化思路</p>
<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<p>输入: 4<br> 输出: [<br> [“.Q..”,  // 解法 1<br> “…Q”,<br> “Q…”,<br> “..Q.”],</p>
<p>[“..Q.”,  // 解法 2<br> “Q…”,<br> “…Q”,<br> “.Q..”]<br> ]<br> 解释: 4 皇后问题存在两个不同的解法。</p>
<p>来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：</p>
<p>也是利用递归回溯进行相应的查找，每次查找需要避开同一行，同一列的相同。同一行的相同再遍历过程中可以避免，同一列的话使用全局变量保存是否已经放置了元素。对角线的话，根据给出的00 01 02 03可以发现有两种对角线，一种自上而下，一种自下而上，都有规律，一种x+y都相同，一种x-y都相同，以此避免在对角线上取到相同的。最后每次到最后，就将当前的位置信息变换为String的list结构存入即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每一行每一列都不能有相同的</span><br><span class="line">private boolean[] col;</span><br><span class="line">&#x2F;&#x2F; 两个对角线</span><br><span class="line">private boolean[] dia1;</span><br><span class="line">private boolean[] dia2;</span><br><span class="line">private List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">  col &#x3D; new boolean[n];</span><br><span class="line">  &#x2F;&#x2F; 总共有七条对角线</span><br><span class="line">  dia1 &#x3D; new boolean[2 * n - 1];</span><br><span class="line">  dia2 &#x3D; new boolean[2 * n - 1];</span><br><span class="line">  res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  putNQueen(n, 0, new ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void putNQueen(int n, int index, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  if (index &#x3D;&#x3D; n) &#123;</span><br><span class="line">    List&lt;String&gt; strings &#x3D; generateString(n,new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">    res.add(strings);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 开始遍历</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 一行一列是false，两条对角线都是false即可</span><br><span class="line">    &#x2F;&#x2F; index-i本来是表示斜对角线上的点，但是由于index-i可能会出现负数的情况</span><br><span class="line">    &#x2F;&#x2F; 可以得到index-i+n-1可以保证没有负数</span><br><span class="line">    if (!col[i] &amp;&amp; !dia1[index + i] &amp;&amp; !dia2[index - i + n - 1]) &#123;</span><br><span class="line">      &#x2F;&#x2F; 变化为已经被占用</span><br><span class="line">      col[i] &#x3D; true;</span><br><span class="line">      dia1[index + i] &#x3D; true;</span><br><span class="line">      dia2[index - i + n - 1] &#x3D; true;</span><br><span class="line">      list.add(i);</span><br><span class="line">      &#x2F;&#x2F; 继续递归查找下一行</span><br><span class="line">      putNQueen(n, index + 1, list);</span><br><span class="line">      &#x2F;&#x2F; 回溯，需要恢复以及list需要删除最后元素</span><br><span class="line">      col[i] &#x3D; false;</span><br><span class="line">      dia1[index + i] &#x3D; false;</span><br><span class="line">      dia2[index - i + n - 1] &#x3D; false;</span><br><span class="line">      list.remove(list.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; list中存放的是每一行可以放的坐标</span><br><span class="line">private List&lt;String&gt; generateString(int n,ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">  List&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    sb.append(&quot;.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    strings.add(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    String s &#x3D; strings.get(i);</span><br><span class="line">    StringBuilder stringBuilder &#x3D; new StringBuilder(s);</span><br><span class="line">    stringBuilder.setCharAt(list.get(i),&#39;Q&#39;);</span><br><span class="line">    strings.remove(i);</span><br><span class="line">    strings.add(i,stringBuilder.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  return strings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-52-N-Queens-II"><a href="#Leetcode-52-N-Queens-II" class="headerlink" title="Leetcode 52 N-Queens II"></a>Leetcode 52 N-Queens II</h4><h4 id="Leetcode-37-Sudoku-Solver"><a href="#Leetcode-37-Sudoku-Solver" class="headerlink" title="Leetcode 37 Sudoku Solver"></a>Leetcode 37 Sudoku Solver</h4><blockquote>
<p>数独问题+相关优化思路</p>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>记忆化搜索：自上而下的方法</p>
<p>动态规划：直接使用循环，使用的是自下而上的方法，一般可以使用自上而下解决的问题都可以使用自下而上的方法解决</p>
<p>一般先使用自上而下思考，最后使用动态规划自下而上编码解决问题</p>
</blockquote>
<h4 id="Leetcode-70-Climbing-Stairs"><a href="#Leetcode-70-Climbing-Stairs" class="headerlink" title="Leetcode 70 Climbing Stairs"></a>Leetcode 70 Climbing Stairs</h4><h4 id="Leetcode-120-Triangle"><a href="#Leetcode-120-Triangle" class="headerlink" title="Leetcode 120 Triangle"></a>Leetcode 120 Triangle</h4><blockquote>
<p>又是一次失败的尝试！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过了，时间复杂度：O(n^2) 空间复杂度：O(n^2)</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">  &#x2F;&#x2F; 层数</span><br><span class="line">  int size &#x3D; triangle.size();</span><br><span class="line">  &#x2F;&#x2F; 上一个元素可以获得的下面元素为</span><br><span class="line">  &#x2F;&#x2F; 记录上一个元素的</span><br><span class="line">  int[][] dp &#x3D; new int[size][size];</span><br><span class="line">  dp[0][0] &#x3D; triangle.get(0).get(0);</span><br><span class="line">  int res &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; size; i++) &#123;</span><br><span class="line">    List&lt;Integer&gt; tempList &#x3D; triangle.get(i);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; tempList.size(); j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 第一个数的时候</span><br><span class="line">      if (j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将其直接与上一排第一个相加</span><br><span class="line">        dp[i][j] &#x3D; dp[i - 1][j] + tempList.get(j);</span><br><span class="line">      &#125; else if (j &#x3D;&#x3D; i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则将其与上排前一个相加，同等位置，下一排会往后延伸一位，所以往上需要j-1</span><br><span class="line">        dp[i][j] &#x3D; dp[i - 1][j - 1] + tempList.get(j);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 否则的话，则是处于中间段,此时计算上面相邻的两个即可</span><br><span class="line">        dp[i][j] &#x3D; Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + tempList.get(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 最后所有的结果都在二维数组最后一组数据中</span><br><span class="line">  for (int i &#x3D; 0; i &lt; dp[size - 1].length; i++) &#123;</span><br><span class="line">    res &#x3D; Math.min(dp[size - 1][i], res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于上述只与dp[i-1][j] dp【i-1][j-1]有关</span><br><span class="line">&#x2F;&#x2F; 用两个变量来存储上面的这两个变量</span><br><span class="line">public int minimumTotal1(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">  &#x2F;&#x2F; 层数</span><br><span class="line">  int size &#x3D; triangle.size();</span><br><span class="line">  &#x2F;&#x2F; 上一个元素可以获得的下面元素为</span><br><span class="line">  &#x2F;&#x2F; 记录上一个元素的</span><br><span class="line">  int[] dp &#x3D; new int[size];</span><br><span class="line">  dp[0] &#x3D; triangle.get(0).get(0);</span><br><span class="line">  int res &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  int prev &#x3D; 0;&#x2F;&#x2F; dp[i-1][j]</span><br><span class="line">  int cur &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; size; i++) &#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; triangle.get(i);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; list.size(); j++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 表示向右移动</span><br><span class="line">      prev &#x3D; dp[j];</span><br><span class="line">      &#x2F;&#x2F; 每一个dp[j]记录的都是一个元素。总共有四层</span><br><span class="line">      if(j &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        dp[j] &#x3D; prev + list.get(j);</span><br><span class="line">      &#125;else if(j &#x3D;&#x3D; i)&#123;</span><br><span class="line">        dp[j] &#x3D; cur + list.get(j);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        dp[j] &#x3D; Math.min(prev,cur)+list.get(j);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 注意prev和cur需要向右移动</span><br><span class="line">      cur &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">    res &#x3D; Math.min(res, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Leetcode-64-Minimum-Path-Sum"><a href="#Leetcode-64-Minimum-Path-Sum" class="headerlink" title="Leetcode 64 Minimum Path Sum"></a>Leetcode 64 Minimum Path Sum</h4><h4 id="Leetcode-343-Integer-Break"><a href="#Leetcode-343-Integer-Break" class="headerlink" title="Leetcode 343 Integer Break"></a>Leetcode 343 Integer Break</h4><h4 id="Leetcode-279-Perfect-Squares-1"><a href="#Leetcode-279-Perfect-Squares-1" class="headerlink" title="Leetcode 279 Perfect Squares"></a>Leetcode 279 Perfect Squares</h4><blockquote>
<p>使用动态规划解决</p>
</blockquote>
<h4 id="Leetcode-91-Decode-Ways"><a href="#Leetcode-91-Decode-Ways" class="headerlink" title="Leetcode 91 Decode Ways"></a>Leetcode 91 Decode Ways</h4><h4 id="Leetcode-62-Unique-Paths"><a href="#Leetcode-62-Unique-Paths" class="headerlink" title="Leetcode 62 Unique Paths"></a>Leetcode 62 Unique Paths</h4><h4 id="Leetcode-63-Unique-Paths-II"><a href="#Leetcode-63-Unique-Paths-II" class="headerlink" title="Leetcode 63 Unique Paths II"></a>Leetcode 63 Unique Paths II</h4><h3 id="状态及状态转移"><a href="#状态及状态转移" class="headerlink" title="状态及状态转移"></a>状态及状态转移</h3><h4 id="Leetcode-198-House-Robber"><a href="#Leetcode-198-House-Robber" class="headerlink" title="Leetcode 198 House Robber"></a>Leetcode 198 House Robber</h4><h4 id="Leetcode-213-House-Robber-II"><a href="#Leetcode-213-House-Robber-II" class="headerlink" title="Leetcode 213 House Robber II"></a>Leetcode 213 House Robber II</h4><h4 id="Leetcode-337-House-Robber-III"><a href="#Leetcode-337-House-Robber-III" class="headerlink" title="Leetcode 337 House Robber III"></a>Leetcode 337 House Robber III</h4><h4 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Leetcode 309 Best Time to Buy and Sell Stock with Cooldown"></a>Leetcode 309 Best Time to Buy and Sell Stock with Cooldown</h4><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><blockquote>
<p>记忆化搜索与动态规划来实现</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Id</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">weight</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">value</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">12</td>
</tr>
</tbody></table>
<blockquote>
<p>背包容量为5的背包，可以获取最大的价值为22</p>
</blockquote>
<blockquote>
<p>时间复杂度：O(n<em>C)  空间复杂度：O(n</em>C)</p>
</blockquote>
<h3 id="0-1背包问题的优化"><a href="#0-1背包问题的优化" class="headerlink" title="0-1背包问题的优化"></a>0-1背包问题的优化</h3><blockquote>
<p>主要是针对空间的优化</p>
</blockquote>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><blockquote>
<p>每个物体可以无限使用</p>
<p>多重背包问题：每个物品不止1个</p>
<p>多维费用背包问题：考虑物品的体积和重量两个维度</p>
<p>物品之间的相互约束；相互依赖</p>
</blockquote>
<h4 id="Leetcode-416-Partition-Equal-Subset-Sum"><a href="#Leetcode-416-Partition-Equal-Subset-Sum" class="headerlink" title="Leetcode 416 Partition Equal Subset Sum"></a>Leetcode 416 Partition Equal Subset Sum</h4><h4 id="Leetcoce-322-Coin-Change"><a href="#Leetcoce-322-Coin-Change" class="headerlink" title="Leetcoce 322 Coin Change"></a>Leetcoce 322 Coin Change</h4><h4 id="Leetcode-377-Combination-Sum-IV"><a href="#Leetcode-377-Combination-Sum-IV" class="headerlink" title="Leetcode 377 Combination Sum IV"></a>Leetcode 377 Combination Sum IV</h4><h4 id="Leetcode-474-Ones-and-Zeros"><a href="#Leetcode-474-Ones-and-Zeros" class="headerlink" title="Leetcode 474 Ones and Zeros"></a>Leetcode 474 Ones and Zeros</h4><h4 id="Leetcode-139-Word-Break"><a href="#Leetcode-139-Word-Break" class="headerlink" title="Leetcode 139 Word Break"></a>Leetcode 139 Word Break</h4><h4 id="Leetcode-494-Target-Sum"><a href="#Leetcode-494-Target-Sum" class="headerlink" title="Leetcode 494 Target Sum"></a>Leetcode 494 Target Sum</h4><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h4 id="Leetcode-300-Longest-Increasing-Subsequence"><a href="#Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode 300 Longest Increasing Subsequence"></a>Leetcode 300 Longest Increasing Subsequence</h4><h4 id="Leetcode-376-Wiggle-Subsequence"><a href="#Leetcode-376-Wiggle-Subsequence" class="headerlink" title="Leetcode 376 Wiggle Subsequence"></a>Leetcode 376 Wiggle Subsequence</h4><h3 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h3><h4 id="Leetcode-300-Longest-Common-Subsequence"><a href="#Leetcode-300-Longest-Common-Subsequence" class="headerlink" title="Leetcode 300 Longest Common Subsequence"></a>Leetcode 300 Longest Common Subsequence</h4><h3 id="Dijkstra单源最短路径算法也是动态规划"><a href="#Dijkstra单源最短路径算法也是动态规划" class="headerlink" title="Dijkstra单源最短路径算法也是动态规划"></a>Dijkstra单源最短路径算法也是动态规划</h3><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="简单贪心算法"><a href="#简单贪心算法" class="headerlink" title="简单贪心算法"></a>简单贪心算法</h3><blockquote>
<p>一般贪心算法与排序算法是紧密联系</p>
</blockquote>
<h4 id="Leetcode-455-Assign-Cookies"><a href="#Leetcode-455-Assign-Cookies" class="headerlink" title="Leetcode 455 Assign Cookies"></a>Leetcode 455 Assign Cookies</h4><h4 id="Leetcode-392-Is-Subsequence"><a href="#Leetcode-392-Is-Subsequence" class="headerlink" title="Leetcode 392 Is Subsequence"></a>Leetcode 392 Is Subsequence</h4><blockquote>
<p>思考解法与贪心算法那之间的联系</p>
</blockquote>
<h3 id="贪心算法与动态规划之间的关系"><a href="#贪心算法与动态规划之间的关系" class="headerlink" title="贪心算法与动态规划之间的关系"></a>贪心算法与动态规划之间的关系</h3><h4 id="Leetcode-435-Non-overlapping-Intervals"><a href="#Leetcode-435-Non-overlapping-Intervals" class="headerlink" title="Leetcode 435 Non-overlapping Intervals"></a>Leetcode 435 Non-overlapping Intervals</h4><h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><blockquote>
<p>如果不能使用贪心算法，只需要举出反例即可</p>
</blockquote>
<blockquote>
<p>如果无法举出反例，如何证明贪心算法的正确性？</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>课程是结束了，但是自己的练习之路还是没有结束，自己的练习可能才刚开始，这次算法视频是看完了，就如算法视频课程的老师所说，不能一味的追求Accepted的快感而忽视了自己的思考过程，确实是这样，但是很多时候自己确实是想不到这些东西该如何解决，加上自己性子比较急，但是我知道这些都不是理由和借口，真正的智商差距真的很小，但是每个人都事物追求的兴趣真的差距很大。</p>
<p>对于算法这件事情，之前的不自信都是因为算法感觉不太稳导致的不自信，美团的面试真的是让自己的不自信到达了一个低谷，所以算法在自己的心目中很重要的一个部分。现阶段，先解决这个课程的算法题，自己的Leetcode上刷的题目，大多数都是没有什么水平的，或者说是自己没有思考就直接看答案的，导致自己是速成了一些算法思想，但是没有实际的解决算法的能力与思考的维度有所差距。还是存在很大的问题的，现阶段的事情，需要自己慢慢的去思考，我希望的是具有一种融入思想中的融入骨子里的那种算法的感觉，而不是每一次都挠头然后一脸懵逼，看着答案才豁然开朗。每一个人来这个世界，都是为了实现自己的人生价值，没有上限，只有下限！</p>
<p>加油！</p>
]]></content>
  </entry>
  <entry>
    <title>RocketMQ学习</title>
    <url>/2020/05/05/RocketMQ/</url>
    <content><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近在公司因为业务需要，需要使用到DDMQ，然而滴滴MQ是基于RocketMQ来开发的，之前对于消息队列的概念一直比较模糊，只知道可以存放数据，可以拉取数据消费，但实际上知道的都是它最基本的功能。它能够将生产的消息放入到消息队列中，同时对于监听中的消费者，将自己的消息推送给消费者消费。还支持批量发送，延迟消费等等。</p>
<h2 id="2-RocketMQ"><a href="#2-RocketMQ" class="headerlink" title="2. RocketMQ"></a>2. RocketMQ</h2><p>RocketMQ的话是阿里巴巴开源给apache的一款分布式的消息队列，使用java开发的（Java最高殿堂在国内当属阿里了），主要的组成部分有producer、broker、namesrv、consumer四个部分组成，producer负责生产消息，namesrv负责producer与broker通信之间的地址信息存储以及consumer与broker通信之间的地址信息的存储，consumer就是消息的消费者。</p>
<p>一般而言在正式的生产环境中broker为了实现高可用，一般都会采用双主双从的的模式搭建即2m-2s-sync的模式，这个选择的话需要在conf目录下的配置文件中配置即可。注意高可用的维持中，如果主挂了，需要从变为主的话，RocketMq还不支持从节点自动变为主，需要手动修改配置文件使得从变为主。</p>
<h3 id="2-1-消息队列的作用"><a href="#2-1-消息队列的作用" class="headerlink" title="2.1 消息队列的作用"></a>2.1 消息队列的作用</h3><p>一直以来各种面试宝典都会告诉你，消息队列首先是流量削峰，然后是应用解耦，最后是数据的分发三个作用。但大都只是你所想象的它的用处是这些，在实际的生产环境中怎么理解呢？</p>
<p>首先<strong>流量削峰</strong>，主要是因为在高并发的场景下，大量的请求一拥而入，此时如果都直接一次性请求到系统中，很可能直接将系统压垮，所以可以采用消息队列存储这些请求，让系统按照自身的能力进行消息的消费，从而实现流量削峰。</p>
<p><strong>应用解耦</strong>是个什么回事呢，假如我们有个电商网站，存在下单系统-&gt;支付系统-&gt;库存系统-&gt;物流系统，一般的操作是先下单然后减库存然后通过物流处理运出货物。但是如果有一个环节出了问题，整个流程就走不通了，产生失败。而如果将系统解耦，每次用户下单之后，将消息发送到消息队列中存储起来，支付系统，库存系统，物流系统分别去消费这个消息，即使有环节出了问题，修复之后，整个流程还是能够走通，这就是应用解耦。</p>
<p>最后一个就是<strong>数据分发</strong>，即假设我们有个消息平台，而有多个系统会来我们这边消费信息，之前的逻辑是我们在设计的时候就需要知道哪些系统需要接入，代码需要怎么编写，当有系统要退出的时候，代码如何修改，流程繁琐。当使用了消息队列的话，此时可以直接通过订阅的方式让各个系统自己选择是否要接入消息平台。这就是数据分发。</p>
<h3 id="2-2-消息队列工作流程"><a href="#2-2-消息队列工作流程" class="headerlink" title="2.2 消息队列工作流程"></a>2.2 消息队列工作流程</h3><p><img src="https://static.oschina.net/uploads/img/201609/28105945_t8eA.png" alt="RocketMQ架构图"></p>
<p>上面就是RocketMQ的架构图，具体的工作流程如下：</p>
<ul>
<li>启动Name Server，启动后监听produer、broker、consumer的接入，相当于路由控制中心</li>
<li>broker启动，与集群中所有的Name Server保持长连接，定期发送心跳包，心跳包包括当前的Broker信息（IP+端口）以及存储的所有的topic消息。注册成功后，Name Server中就有了Topic与Broker的映射关系。</li>
<li>Producer发送消息，启动前需要先指定Name Server的地址，与其建立联系，获取到当前需要发送的Topic在哪些Broker上，轮询从队列列表中选择一个队列，与队列所在的Broker建立长连接并发送消息给Broker</li>
<li>Consumer消费消息，启动前也需要与Name Server建立联系，获取需要消费的Topic在哪个Broker上，然后与Broker连接，进行消息的消费。</li>
</ul>
<h3 id="2-3-生产者-amp-消费者"><a href="#2-3-生产者-amp-消费者" class="headerlink" title="2.3 生产者&amp;消费者"></a>2.3 生产者&amp;消费者</h3><p>Producer在创建的时候需要选择Name Server的地址，然后启动，最后发送消息，消息中需要指定Topic，tags，key，消息体等信息。</p>
<p>Consumer在创建的时候需要选择Name Server的地址，订阅需要消费的topic和tag，然后注册监听器，监听消息然后消费。</p>
<p>代码示例：</p>
<p>Producer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化消息生产者,需要有分组</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"group1"</span>);</span><br><span class="line">        <span class="comment">// 设置地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        <span class="comment">// 启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 生产消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息体</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,<span class="string">"TagA"</span>,</span><br><span class="line">                    (<span class="string">"hello world "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">// 发送消息会获取一个消息发送的结果，因为是同步的，所以必须会返回一个结果</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.println(<span class="string">"发送消息的结果："</span>+sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 构造一个消费者</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">        <span class="comment">// 设置存储数据的broker地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        <span class="comment">// 订阅topic与标签tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//负载均衡模式消费</span></span><br><span class="line"><span class="comment">//        consumer.setMessageModel(MessageModel.CLUSTERING);</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        <span class="comment">// 注册回调函数，即监听器，监听是否有此topic的tagA的消息，有的话就消费</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"消费："</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要返回消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"消费者成功启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意：</p>
<p>Producer的消息发送有三种：</p>
<ul>
<li>发送同步消息（发送后会等待结果返回）</li>
<li>发送异步消息（发送消息后的结果由回调函数返回）</li>
<li>单向发送消息（只管发送，不管结果如何）</li>
</ul>
<p>Consumer的消息消费有两种模式：</p>
<ul>
<li>负载均衡（如果10条消息，两个消费者，一般来说一人5条消息）</li>
<li>广播模式（广播就是大家都会听见的，而对于消费者来说，就是大家都要消费）</li>
</ul>
<p><strong>顺序消息</strong></p>
<p>即一个消息的整体按照不同顺序发送到队列中，但是消费的时候需要保持这个消息的完整性，这个我感觉比较绕口，而且代码的话就是每个消息会有一个标识，相同的消息整体，标识会相同，发送的时候会通过选择器发送，以保证拥有相同标识的消息会发送到同一个队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化消息生产者</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"group1"</span>);</span><br><span class="line">        <span class="comment">// 设置地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        <span class="comment">// 启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 标签</span></span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</span><br><span class="line">        List&lt;OrderStep&gt; orderSteps = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String dateStr = format.format(date);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String body = dateStr + <span class="string">"hello rocketmq "</span> + orderSteps.get(i);</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"orderTopic"</span>,</span><br><span class="line">                    tags[i % tags.length], (<span class="string">"KEY"</span> + i), body.getBytes());</span><br><span class="line">            SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">long</span> id = (<span class="keyword">long</span>) o;<span class="comment">// 这个id是orderId</span></span><br><span class="line">                    <span class="keyword">long</span> index = id % list.size();<span class="comment">// 现在有3个队列，此时id%3一定会出现在0 1 2</span></span><br><span class="line">                    <span class="keyword">return</span> list.get((<span class="keyword">int</span>) index);<span class="comment">// 此时取出这个队列中的数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderSteps.get(i).orderId); <span class="comment">// 这时候是将orderId放入，如果前面相同就按照orderId来判别</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"SendResult status:%s, queueId:%d, body:%s"</span>,</span><br><span class="line">                    sendResult.getSendStatus(),</span><br><span class="line">                    sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                    body));</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消息消费的话正常消费即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        <span class="comment">// 设置从头部还是从尾部开始消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 绑定的topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">"orderTopic"</span>,<span class="string">"TagA || TagB || TagC"</span>);</span><br><span class="line">        <span class="comment">// 注册顺序消费</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> </span>&#123;</span><br><span class="line">                consumeOrderlyContext.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : list) &#123;</span><br><span class="line">                    <span class="comment">// 此时进行消费</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"消费："</span>+<span class="string">"queueId "</span>+msg.getQueueId()</span><br><span class="line">                            +<span class="string">", content:"</span>+<span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"消费者成功启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>延时消息</strong></p>
<p>延时消息的话RocketMQ最多只支持2个小时的延时，不可随意选择，但是DDMQ的话是支持自由选择延迟时间的。</p>
<p>这个延迟消息的发送，只需要在发送的时候选择发送的消息延迟级别即可<code>msg.setDelayTimeLevel(2);</code>。其余同上。</p>
<p><strong>过滤消息</strong></p>
<p>这个一般是通过Tag来过滤的，还有通过sql啥的过滤，不过现在好像有些版本不大支持，不赘述。</p>
<p><strong>事务消息</strong></p>
<p>在RocketMQ中有个事务消息的概念，具体的事务消息流程如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200505110348355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>首先Producer发送消息给MQ Server</li>
<li>MQ Server接收到消息后MQ Server返回ok，然后执行本地事务。</li>
<li>Producer将本地事务执行的结果告诉MQ Server，提交或者回滚或者未知</li>
<li>提交的话MQ Server将消息给消费者发送，回滚的话就删除消息，而未知的话，此时将启动回查机制，即MQ Server检查Producer这个消息的状态，Producer转而查看本地事务执行的状态，最后得到提交或者回滚给MQ Server</li>
</ul>
<p>以上就是整个事务消息的执行过程。整个过程发生在Producer与MQ Server之间，与消费者Consumer无关</p>
<p>Producer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TransactionListener listener = <span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagA"</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagB"</span>, msg.getTags())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.UNKNOW; <span class="comment">// 表示没有对消息做任何的处理，此时会进行消息的回查</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行回查</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"当前回查的tag: "</span> + msg.getTags());</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"group8"</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        <span class="comment">// 设置监听器</span></span><br><span class="line">        producer.setTransactionListener(listener);</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"transactionTopic"</span>, tags[i],</span><br><span class="line">                    (<span class="string">"hello caoduanxi "</span> + i).getBytes());</span><br><span class="line">            SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">"消息发送："</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为存在事务补偿机制，这里会回查，所以不要shutdown</span></span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer: 正常消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group8"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"192.168.230.100:9876;192.168.230.101:9876"</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">"transactionTopic"</span>, <span class="string">"*"</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"consumeThread="</span> + Thread.currentThread().getName() + <span class="string">","</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"消费者启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-阿里云服务器-amp-RocketMQ"><a href="#2-4-阿里云服务器-amp-RocketMQ" class="headerlink" title="2.4 阿里云服务器&amp;RocketMQ"></a>2.4 阿里云服务器&amp;RocketMQ</h3><p>首先安装，其次修改runbroker.sh&amp;runserver.sh的虚拟机内存分配大小</p>
<p>注意虚拟机的内存分配 Xms &lt; Xmx否则一定会报错</p>
<p>然后运行的时候注意选择</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nohup sh ./bin/mqnamesrv -n 公网ip:9876 &amp;</span><br><span class="line">nohup sh ./bin/mqbroker -n 公网ip:9876 -c conf/broker.conf  autoCreateTopicEnable=<span class="literal">true</span> &amp;</span><br></pre></td></tr></table></figure>

<p>上述的如果不指定自动创建topic会报错！如果不指定ip和端口会报错连接不上，注意需要在broker.conf中添加配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brokerIP1=公网ip</span><br></pre></td></tr></table></figure>

<p>在阿里云服务器的安全组配置中开放9876端口和10911端口，一个是namesrv需要的，一个是broker需要的</p>
<h2 id="3-RocketMQ高级功能"><a href="#3-RocketMQ高级功能" class="headerlink" title="3. RocketMQ高级功能"></a>3. RocketMQ高级功能</h2><p>上面说了RocketMQ使用双主双从模式实现高可用的，这里说下如何实现RocketMQ的高可靠性，可靠性就是出现宕机怎么保证消息不丢失，说到这个就需要持久化机制参与作战了。</p>
<h3 id="3-1-消息存储"><a href="#3-1-消息存储" class="headerlink" title="3.1 消息存储"></a>3.1 消息存储</h3><p>消息存储的流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200505111355331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>可以看到消息的持久化发生在MQ服务器中，进行消息的存储与删除。</p>
<p>流程如下：</p>
<ul>
<li>生产者生产消息发送给MQ</li>
<li>MQ确认后对消息进行存储，然后返回ACK确认</li>
<li>MQ将消息发送给消费者，如果消费成功的话，消费者返回ACK确认，此时MQ接收到之后将消息进行删除；如果在指定时间内没有接收到消息的话，此时MQ会认为消息消费失败，会重复执行4 5 6三个步骤</li>
</ul>
<h3 id="3-2-存储介质"><a href="#3-2-存储介质" class="headerlink" title="3.2 存储介质"></a>3.2 存储介质</h3><p>消息持久化存储就涉及到对存储介质的思考，我们怎么存呢？</p>
<ul>
<li>关系型数据库DB（缺陷是如果数据库挂掉了，会产生MQ消息无法落盘导致线上故障）</li>
<li>文件系统，顾名思义就是自己本身所具备的存储系统，目前主流的消息队列都是使用消息刷盘至所部署的虚拟机/物理机的文件系统中保存，刷盘有同步刷盘和异步刷盘两种模式，消息刷盘为消息存储提供了一种高效率高可靠性和高性能的数据持久化方式。除非MQ本身或者机器磁盘故障，不然一般不会出现无法持久化的问题。</li>
</ul>
<p>文件系统性能优于关系型数据库DB</p>
<h3 id="3-3-消息存储结构"><a href="#3-3-消息存储结构" class="headerlink" title="3.3 消息存储结构"></a>3.3 消息存储结构</h3><p><img src="https://img-blog.csdnimg.cn/20200505112613187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>消息的存储是ConsumeQueue配合CommitLog来完成的，消息真正的存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似索引文件，存储的是执行物理文件的地址。每个Topic的每个Message Queue都对应着一个 ConsumeQueue文件。</p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumerQueue：存储消息在CommitLog中的索引</li>
<li>IndexFile：为消息查询提供的一种根据key或者时间区间查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程。</li>
</ul>
<h3 id="3-4-负载均衡策略"><a href="#3-4-负载均衡策略" class="headerlink" title="3.4 负载均衡策略"></a>3.4 负载均衡策略</h3><p><strong>Producer的负载均衡策略</strong></p>
<p>Producer的每个实例在发送消息的时候，默认轮询所有的Message Queue发送，以让消息落到不同的Queue上，而由于Queue是落在不同的Broker上的，所以消息就发送到了不同的Broker上了。</p>
<p><strong>Consumer的负载均衡策略</strong></p>
<p>集群模式下：</p>
<p>每条消息只需要投递到订阅这个Topic的Consumer Group下的一个实例即可，RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取那一条Message Queue。每次实例对象有变更的时候，会触发一次Rebalance，会按照Queue的数量与消费实例对象个数平均分配。</p>
<p>如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<p>广播模式：</p>
<p>消息投递到所有的消费实例即可。</p>
<h3 id="3-5-消息重试"><a href="#3-5-消息重试" class="headerlink" title="3.5 消息重试"></a>3.5 消息重试</h3><p><strong>顺序消息的重试</strong></p>
<p>顺序消息由于需要保证消息消费的有序性，一旦有消息发生重试就有可能导致阻塞现象的产生。因此在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<p><strong>无序消息的重试</strong></p>
<p>无序消息的重试只针对集群模式的进行重试，而对于广播的，不再进行重试，因为可能导致部分实例产生重复消费的现象。无序消息的重试可以根据返回的消息状态实现重试。</p>
<p>默认重试次数16次。</p>
<h3 id="3-6-死信队列"><a href="#3-6-死信队列" class="headerlink" title="3.6 死信队列"></a>3.6 死信队列</h3><p>顾名思义，死信即信息没有被消费然后又达到了重试次数的消息，没有人要它了，等同于死亡一般，有点类似于僵尸线程。一般这种消息不会讲消息丢弃而是存放到死信队列中（Dead-Letter Queue）</p>
<p><strong>死信消息特性：</strong></p>
<ul>
<li>不会再被消费者正常消费</li>
<li>有效期与正常消息相同，为3天，3天之后会被自动删除</li>
</ul>
<p><strong>死信队列的特性</strong></p>
<ul>
<li>一个死信队列对应一个Group Id，而不是单个消费者实例</li>
<li>如果一个GROUP ID没有产生死信消息，RocketMQ不会为其创建死信队列</li>
<li>一个死信队列包含了对应的GROUP ID的所有死信消息，不论去topic是否相同</li>
</ul>
<p>死信消息可以在控制台手动发送！</p>
<h3 id="3-7-消费的幂等性"><a href="#3-7-消费的幂等性" class="headerlink" title="3.7 消费的幂等性"></a>3.7 消费的幂等性</h3><p>这里主要是针对消息的重复消费而言的，一般来说发送的消息只能够被消费一般，但是存在很多意外的因素导致消息会被重复消费，这个时候，消费的幂等性就被破坏了。</p>
<p>消费幂等性的保持需要在消息的业务key上做幂等性处理。</p>
<p><strong>消费幂等性破坏的原因：</strong></p>
<ul>
<li><strong>发送消息时重复</strong>：一条消息发送并被服务器持久化了，但是由于网络的闪断或者客户端宕机，导致服务端对客户端应答失败，这个时候生产者意识到消息发送失败，则发送了重复消息。导致消费者在消费的时候收到两条内容相同且Message Id也相同的消息</li>
<li><strong>投递消息时重复：</strong>消费场景下，消息已投递并完成了处理的业务，当客户端给服务端返回应答的时候网络的闪断，为了保证消息至少被消费一次，服务端在网络恢复后会再次重试投递相同的消息，此时消费者客户端会收到两条内容相同且Message Id也相同的消息</li>
<li><strong>负载均衡时消息重复：</strong>（包括但不限于网络抖动、Broker 重启以及订阅方应用重启），当消息队列RocketMQ的Broker或者客户端重启，扩容或者缩容的时候，触发rebalance，此时消费者可能会收到重复的消息</li>
</ul>
<h3 id="3-8-处理消费幂等性"><a href="#3-8-处理消费幂等性" class="headerlink" title="3.8 处理消费幂等性"></a>3.8 处理消费幂等性</h3><p>由于Message ID可能会出现冲突即相等的情况，一般不建议使用Message Id作为处理依据，最好的处理方式是以业务唯一标示作为幂等性处理的依据，而业务的唯一标示可用消息的key来作为设置。</p>
<p>可以通过数据库对此key做一个存储，消费了的存储，未消费不存储，消费的时候去数据库查一下看是否消费。或者使用redis记录，原理同上。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>由于要用到消息队列，所以学习了一下消息队列，消费者监听消费，生产者生产消息，Name Server，Broker每个角色都有每个角色的作用，不禁感叹，消息队列的创造者真的强啊！本次学习大致知道了消息队列的工作模式，如何生产，如何消费，如何存储，如何保证高可用，如何保证高可靠性，如何对消息的幂等性进行处理，如何对死信的消息进行处理。每一件事情都有它的缘由，所以每一个消息的生产到消费都有一个过程。Keep thinking，keep coding!</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发学习</title>
    <url>/2020/05/05/Java%E5%B9%B6%E5%8F%91%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-1-如何使用线程"><a href="#1-1-如何使用线程" class="headerlink" title="1.1 如何使用线程"></a>1.1 如何使用线程</h3><p>使用线程有三种方法</p>
<ul>
<li>继承Thread类来实现</li>
<li>实现Runnable接口来实现</li>
<li>实现Callable接口来实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by caoduanxi on 2020/4/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            ThreadT thread = <span class="keyword">new</span> ThreadT();</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(thread);</span><br><span class="line">            thread1.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 通过Runnable实现</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"\t runnable "</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            ThreadTCall threadTCall = <span class="keyword">new</span> ThreadTCall();</span><br><span class="line">            FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(threadTCall);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">            thread.start();</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+i+<span class="string">"次："</span>+futureTask.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; <span class="comment">// 通过实现Callable实现</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t call "</span>+ j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadT</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="comment">// 继承Thread实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask可以用来包装实现了Callable或者Runnable的类，用于异步计算，继承自Runnable以及Future类。</p>
<p>线程的start的方法可以使得线程保持在就绪状态，但是不能保证其一定执行run方法，它的执行需要等待CPU的调度，获取时间片之后才会进入运行状态。</p>
<h3 id="1-2-程序模拟线程的各个状态"><a href="#1-2-程序模拟线程的各个状态" class="headerlink" title="1.2 程序模拟线程的各个状态"></a>1.2 程序模拟线程的各个状态</h3><p>Thread线程的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">      NEW, </span><br><span class="line">      RUNNABLE,</span><br><span class="line">      BLOCKED,</span><br><span class="line">      WAITING,</span><br><span class="line">      TIMED_WAITING,</span><br><span class="line">      TERMINATED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>NEW</strong>：线程创建，还未运行</li>
<li><strong>RUNNABLE</strong>：就绪状态和运行状态<ul>
<li>官方释义：线程运行的状态，在JVM中运行，但是可能需要等待一些诸如操作系统处理器的资源（类似于时间片，磁盘IO等）</li>
</ul>
</li>
<li><strong>BLOCKED</strong>：阻塞状态<ul>
<li>官方释义：线程阻塞等待监视器锁的状态，等待进入synchronized锁资源或者再次进入Object.wait()方法之前的状态。</li>
</ul>
</li>
<li><strong>WAITING</strong>：无限期等待<ul>
<li>官方释义：无限期等待，可通过调用Object.wait()或者LockSupport.park()来进入这个状态，还有就是Thread.join()方法，但是这个方法需要等待前面的线程终止才可以执行。</li>
</ul>
</li>
<li><strong>TIMED_WAITING</strong>：有限期等待<ul>
<li>官方释义：线程等待一个特定时间时的状态，进入这种状态主要是由于调用了下列方法：Thread.sleep范方法，Object.wait(long timeout)，Thread.join(long timeout)，LockSupport. parkNanos(Object blocker, long nanos)，LockSupport.parkNanos(long nanos)</li>
</ul>
</li>
<li><strong>TERMINATED</strong>：终止状态<ul>
<li>官方释义：线程终止时的状态，意味着线程的操作执行完毕。</li>
</ul>
</li>
</ul>
<p><strong>线程状态转移图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200419102205483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这里主要是这个运行状态切换到到Blocked状态，如果是直接调用synchronized或者是wait()或者是I/O操作的话，都会造成阻塞状态。当我们WAITING的话，此时如果被唤醒的话是不能够直接回到就绪状态的，需要经历BLOCKED阻塞状态获取到锁之后才回到就绪状态。</p>
<p><font color="red">注意：阻塞是被动的，而等待是主动的</font></p>
<p><strong>Object.wait()与Thread.sleep()的区别？</strong></p>
<blockquote>
<p>答：</p>
<ul>
<li>wait方法是Object的，sleep是Thread的，归属不同</li>
<li>wait不占有锁，一旦wait调用，释放锁，等到被唤醒重新进入到BLOCKED状态等待获取到锁进入到就绪状态，而sleep是不释放锁，一旦sleep调用，线程会休眠设置的时间，然后回到就绪状态，因为它不释放锁，当等待时间结束就可以直接回到就绪状态</li>
</ul>
</blockquote>
<h3 id="1-3-线程实现机制对比"><a href="#1-3-线程实现机制对比" class="headerlink" title="1.3 线程实现机制对比"></a>1.3 线程实现机制对比</h3><p>线程实现有三种方式，如果要加上线程池的话，那么就有四种方式，但是这里还未说到线程池，暂且定为三种。三种之中有两种是实现接口的方式实现，一种是继承Thread类实现。</p>
<ul>
<li>由于Java是单继承的，但是是多实现的，如果继承了Thread类的话就没有办法继承其他类，但是可以实现多个接口</li>
<li>类可能只要求可以执行，即拥有run方法即可，如果是继承整个Thread类的话，开销过大</li>
</ul>
<p>综上，如果需要使用线程，建议使用实现接口的方式来实现。</p>
<h2 id="2-基础线程机制"><a href="#2-基础线程机制" class="headerlink" title="2. 基础线程机制"></a>2. 基础线程机制</h2><h3 id="2-1-Executor"><a href="#2-1-Executor" class="headerlink" title="2.1 Executor"></a>2.1 Executor</h3><p>这是一个接口，管理多个异步任务的执行，无须程序员显式的去管理线程的生命周期。但注意，这里的异步任务执行，并不强求一定是异步，也可以创建之后直接执行。异步的话是指多个线程执行不会互相干扰。</p>
<p>默认实现有以下三种：</p>
<ul>
<li>newFixedThreadPool</li>
<li>newSingleThreadExecutor</li>
<li>newCacheThreadPool</li>
</ul>
<h3 id="2-2-newFixedThreadPool"><a href="#2-2-newFixedThreadPool" class="headerlink" title="2.2 newFixedThreadPool"></a>2.2 newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>表示创建一个指定线程数目的线程池，指定了数目的话，在线程池中就只会有这几个线程，有任务多的话会在阻塞队列中等待，线程会循环利用，一旦有空闲的线程就去阻塞队列中获取任务执行。</p>
<p>底层是基于ThreadPoolExecutor来实现的，有五个参数</p>
<ol>
<li>核心线程个数</li>
<li>最大工作线程个数</li>
<li>线程池中线程存活时间</li>
<li>时间单位</li>
<li>阻塞队列</li>
</ol>
<p>注意，在newFixedThreadPool中的线程直到调用shoudown()方法之前都是存在的。newFixedThreadPool使用的阻塞队列是LinkedBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       executorService.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面十个任务，执行的只有5个线程，这就是newFixedThreadPool</p>
<h3 id="2-3-newSingleThreadExecutor"><a href="#2-3-newSingleThreadExecutor" class="headerlink" title="2.3 newSingleThreadExecutor"></a>2.3 newSingleThreadExecutor</h3><p>单一的线程执行器，创建只有一个线程的线程池。相当于线程个数为1的newFixedThreadPool</p>
<p>从newFixedThreadPool中可以看到如果使用newSingleThreadExecutor执行十个任务，工作的线程全程只有一个。</p>
<h3 id="2-4-newCachedThreadPool"><a href="#2-4-newCachedThreadPool" class="headerlink" title="2.4  newCachedThreadPool"></a>2.4  newCachedThreadPool</h3><p>根据需要创建线程个数，有些资料上说是一个任务创建一个线程，这是不对的。源码中写的是根据需要创建线程个数，一旦有任务来了，先看看有没有可用的线程，如果有可用的线程就复用可用的线程，否则创建新的线程。</p>
<p>最大线程个数为Integer.MAX_VALUE个，线程存活时间设置为60s，使用的阻塞队列为SynchronousQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-守护线程机制"><a href="#2-5-守护线程机制" class="headerlink" title="2.5 守护线程机制"></a>2.5 守护线程机制</h3><p>daemon：守护的意思。</p>
<p>守护线程是程序运行时在后台提供的服务，不属于程序不可或缺的部分，程序的终止就是伴随着程序中只剩下守护线程了，此时JVM会退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"jvm out success!"</span>)));</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(<span class="string">"I'm living!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程结束退出"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I’m living!<br>I’m living!<br>主线程结束退出<br>jvm out success!</p>
</blockquote>
<h3 id="2-6-yield"><a href="#2-6-yield" class="headerlink" title="2.6 yield"></a>2.6 yield</h3><p>礼让，让出自己的时间片或者其他资源给与自己同优先级的线程先执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonTest(),<span class="string">"thread1"</span>);</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonTest(),<span class="string">"thread2"</span>);</span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           Thread.yield();</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里可以看出thread1和thread2会交替执行，但是也不一定是交替执行。</p>
</blockquote>
<h2 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h2><p>中断操作主要是发生在线程执行到执行完毕的中途，线程执行完毕会自动结束，但是如果运行中发生异常也会提前结束。</p>
<h3 id="3-1-InterruptException"><a href="#3-1-InterruptException" class="headerlink" title="3.1 InterruptException"></a>3.1 InterruptException</h3><p>调用Thread.interrupted()方法，如果当前线程处于wait，sleep或者join状态的话，此时会抛出InterruptException异常</p>
<h3 id="3-2-Interrupted"><a href="#3-2-Interrupted" class="headerlink" title="3.2 Interrupted"></a>3.2 Interrupted</h3><p>线程中有thread.isInterrupted()可以判断线程是否执行被中断成功。</p>
<h3 id="3-3-Executor的中断操作"><a href="#3-3-Executor的中断操作" class="headerlink" title="3.3 Executor的中断操作"></a>3.3 Executor的中断操作</h3><p>在ExecutorService中有个shutdown方法，此方法类似于interrupt方法，可以实现中断。</p>
<h2 id="4-互斥同步"><a href="#4-互斥同步" class="headerlink" title="4. 互斥同步"></a>4. 互斥同步</h2><p>Java中的互斥同步操作主要是为了对资源的同步进行一个处理，实现共享资源的互斥访问。实现方法有两种，第一种是使用基于JVM底层的synchronized锁，第二种方法是基于程序API实现的ReentrantLock</p>
<h3 id="4-1-synchronized"><a href="#4-1-synchronized" class="headerlink" title="4.1 synchronized"></a>4.1 synchronized</h3><p>synchronized关键字底层基于jvm实现。可以实现同步代码块，同步对象，同步方法。</p>
<p><strong>同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">              System.out.println(i+<span class="string">" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SynchronizedTest test = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              test.exe();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              test.exe();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步一个类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">              System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步静态方法</strong></p>
<p>由于static表示当前属性隶属于类，所以同步静态方法的话可以表示当前的类被同步了，作用范围是整个类。</p>
<h3 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h3><p>ReentrantLock是java.util.concurrent（简称JUC）下的一个类</p>
<p>注意使用ReentrantLock的时候一定要注意有上锁就要手动释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">              System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Condition实现精确通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (getCount() == MAX_VALUE) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  condition1.await();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          size++;</span><br><span class="line">          res.add(size);</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"\t生产了："</span> + size);</span><br><span class="line">          condition2.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (getCount() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  condition2.await();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          size--;</span><br><span class="line">          res.remove(size);</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"\t消费了："</span> + size);</span><br><span class="line">          condition1.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-锁机制比较"><a href="#4-3-锁机制比较" class="headerlink" title="4.3 锁机制比较"></a>4.3 锁机制比较</h3><ul>
<li>锁实现机制：<ul>
<li>synchronized基于jvm实现的，而ReentrantLock是基于JDK的API实现的</li>
</ul>
</li>
<li>性能：<ul>
<li>新版本的synchronized优化了许多，现在性能不是与ReentrantLock的区别</li>
</ul>
</li>
<li>等待可中断：<ul>
<li>synchronized不可实现中断，一旦占有锁必须是释放锁之后其他线程才可去占有锁，但是ReentrantLock可以实现中断。</li>
</ul>
</li>
<li>公平与非公平：<ul>
<li>锁有公平与非公平锁的区分，synchronized默认是非公平锁，这是一种竞争锁，在CPU资源紧张的时候，就看各个线程自己的争抢能力了，有利于资源利用最大化。ReentrantLock默认也是非公平锁，但是可以选择实现公平锁，公平锁就是按照线程到来的先后顺序依次执行。</li>
</ul>
</li>
<li>锁绑定与通知机制：<ul>
<li>一个ReentrantLock可以绑定多个Condition对象，可以选择性通知各个对象。这些synchronized都不具备。</li>
</ul>
</li>
</ul>
<h2 id="5-线程之间的协作"><a href="#5-线程之间的协作" class="headerlink" title="5. 线程之间的协作"></a>5. 线程之间的协作</h2><p>线程之间的写作一般发生在多个线程共同工作区解决某个问题的场景，如果某些任务需要再其他任务之前执行，此时就需要线程之间有某种协作来实现这个操作了。</p>
<h3 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join()"></a>5.1 join()</h3><p>join()方法是Thread中的一个方法，意味着如果其他线程在当前线程的运行中调用了join方法，此时当前线程会挂起，等待join进来的线程运行结束，然后进入BLOCKED状态，等待唤醒进入到就绪状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTestIV</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A....."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// join方法必须在其他线程的运行中，即run方法中使用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：为什么需要休眠3s和2s呢，其实就是为了让b一定先获得CPU的控制权，如果没有sleep，两个同时竞争，结果可能是a先获取，执行完了，此时a.join()方法根本不生效，或者是B执行完了，B都打印出来了，A才获得时间片。所以需要休眠！</p>
<p>这样即可观察到b挂起，a执行，随后b再执行！</p>
</blockquote>
<h3 id="5-2-wait-notify-notifyAll"><a href="#5-2-wait-notify-notifyAll" class="headerlink" title="5.2 wait()/notify()/notifyAll()"></a>5.2 wait()/notify()/notifyAll()</h3><p>wait()方法会使得当前线程进入无限期等待状态即WAITING状态，notify()/notifyAll()方法的话会使得当前线程进入到BOLCKED状态，直到获取到锁或者IO操作结束回到就绪态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"before"</span>);</span><br><span class="line">     notifyAll();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         wait();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"after"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     ThreadTestV test = <span class="keyword">new</span> ThreadTestV();</span><br><span class="line">     Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             test.after();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     thread.start();</span><br><span class="line">     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             test.before();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>before<br>after                                                                                                                                                                          </p>
</blockquote>
<h3 id="5-3-await-signal-signalAll"><a href="#5-3-await-signal-signalAll" class="headerlink" title="5.3 await()/signal()/signalAll()"></a>5.3 await()/signal()/signalAll()</h3><p>这三个方法是ReentrantLock中的方法，主要就是实现解除等待着的线程。Condition类的好处就是可以实现定点通知，同一个condition下的可以通知到具体的线程。</p>
<p>await()相比wait()要更加的灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTestSix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTestSix test = <span class="keyword">new</span> ThreadTestSix();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.after();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.before();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>before<br>after</p>
</blockquote>
<h2 id="6-阻塞队列"><a href="#6-阻塞队列" class="headerlink" title="6. 阻塞队列"></a>6. 阻塞队列</h2><p>在线程池中，创建不同的线程池会使用到不同的阻塞队列，学习一下不同阻塞队列的特性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200423231819636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>常见的线程阻塞队列有：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>DelayedWorkedQueue</li>
<li>BlockingDeque:LinkedBlockingDeque</li>
<li>SynchronousQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
</ul>
<h3 id="6-1-ArrayBlockingQueue"><a href="#6-1-ArrayBlockingQueue" class="headerlink" title="6.1 ArrayBlockingQueue"></a>6.1 ArrayBlockingQueue</h3><p>基于数组的阻塞队列，先进先出的工作模式，一旦确定了容量就不可以在修改容量了，支持公平锁与非公平锁的设置。底层使用的是ReentrantLock来实现的，一般有以下几种使用方式：</p>
<p><strong>1. add+remove+element</strong></p>
<ul>
<li><p>如果没有容量了，继续add，会报<font color="red">java.lang.IllegalStateException: Queue full</font></p>
</li>
<li><p>如果没有元素了，由于是基于数组实现的，继续remove直接返回false</p>
</li>
<li><p>element()是获取其中的元素，如果没有元素，报错<font color="red">java.util.NoSuchElementException</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (offer(e))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-2-DelayedWorkedQueue"><a href="#6-2-DelayedWorkedQueue" class="headerlink" title="6.2 DelayedWorkedQueue"></a>6.2 DelayedWorkedQueue</h3><p>这是使用在ScheduledThreadPoolExecutor中的一个延时队列，可以设置固定的延时策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ScheduledThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 设置延迟多久执行</span></span><br><span class="line">       poolExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"延时队列，耗时："</span>+(System.currentTimeMillis()-startTime)+<span class="string">"ms"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">// 周期性延时执行</span></span><br><span class="line">       poolExecutor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"定时任务执行，当前时间: "</span>+getNow());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">2</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-SynchronousQueue"><a href="#6-3-SynchronousQueue" class="headerlink" title="6.3 SynchronousQueue"></a>6.3 SynchronousQueue</h3><p>同步队列，这个队列甚至没有任何元素，用在newCachedThreadPool()中，可以用来实现缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-DelayQueue"><a href="#6-4-DelayQueue" class="headerlink" title="6.4 DelayQueue"></a>6.4 DelayQueue</h3><p>DelayQueue中的元素需要实现Delayed，这个队列的作用域DelayWorkedQueue的作用差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DealyQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A(<span class="string">"a1"</span>,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">        A a2 = <span class="keyword">new</span> A(<span class="string">"a2"</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        A a3 = <span class="keyword">new</span> A(<span class="string">"a3"</span>, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        DelayQueue&lt;A&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        queue.put(a1);</span><br><span class="line">        queue.put(a2);</span><br><span class="line">        queue.put(a3);</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span> + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            A take = queue.take();</span><br><span class="line">            System.out.format(<span class="string">"name:&#123;%s&#125;, time:&#123;%s&#125;\n"</span>,take.name, LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Delayed</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">     <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name, <span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="number">0</span>? unit.toMillis(time): <span class="number">0</span>);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        A a = (A)o;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.time - a.time;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", time="</span> + time +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-LinkedBlockingQueue"><a href="#6-5-LinkedBlockingQueue" class="headerlink" title="6.5 LinkedBlockingQueue"></a>6.5 LinkedBlockingQueue</h3><p>基于链表的阻塞队列，容量无限大Integer.MAX_VALUE。</p>
<h3 id="6-6-PriorityBlockingQueue"><a href="#6-6-PriorityBlockingQueue" class="headerlink" title="6.6 PriorityBlockingQueue"></a>6.6 PriorityBlockingQueue</h3><p>优先阻塞队列，与预先队列的概念一样，内部有比较器，默认按照自然顺序，可以自定义比较。</p>
<h2 id="7-并发工具类"><a href="#7-并发工具类" class="headerlink" title="7. 并发工具类"></a>7. 并发工具类</h2><h3 id="7-1-CountDownLatch"><a href="#7-1-CountDownLatch" class="headerlink" title="7.1 CountDownLatch"></a>7.1 CountDownLatch</h3><p>CountDownLatch相当于撞门一般，就比如人撞门，门设置的是6个人一起才可以撞开，于是当第六个人尝试撞门的时候，此时们就开了。（有点类似于阶段完成某项任务，最后到达任务完成）</p>
<p>主要的方法：await()阻塞，每次一个线程到达，countDown()就减少一个，到0的时候，主线程进行。</p>
<h3 id="7-2-CycliBarrier"><a href="#7-2-CycliBarrier" class="headerlink" title="7.2 CycliBarrier"></a>7.2 CycliBarrier</h3><p>这个就相当于召唤神龙了，七颗龙珠召唤神龙的感觉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"齐了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"\t 到达"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-Semaphore"><a href="#7-3-Semaphore" class="headerlink" title="7.3 Semaphore"></a>7.3 Semaphore</h3><p>信号量，也即允许多少个线程同时执行，一般作用在有限的资源而有多个线程需要同时工作的场景，此时可以使用Semaphore来精确控制。</p>
<p>下面模拟的是2个车位但是有10辆车需要停，这个时候就要使用Semaphore来控制线程对资源访问的同步性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在资源有限的情况，使用semaphore来模拟多个线程如何使用有限的资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 信号量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 抢到了车位"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 等待两秒，离开"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Java的内存模型"><a href="#8-Java的内存模型" class="headerlink" title="8. Java的内存模型"></a>8. Java的内存模型</h2><p>Java的内存模型分为主内存和工作内存，当线程工作的时候用到主内存中的变量的时候，会先读取主内存中的变量值，然后作为副本写入到自己的缓存中，线程从缓存中获取变量值进行处理，处理完毕之后再将结果写入到主内存中去。</p>
<p><img src="https://img-blog.csdnimg.cn/20200505172844813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>由于多个线程同时工作的时候，每个线程都会保存自己从主内存中读取到的变量值，这样一来就会导致线程不安全的例子发生，原因是因为当A读取的时候i=30，而自己运算+1之后31，此时写回主内存，但此时主内存已经被其他线程修改为32了，此时写会就会无形之中丢失了1，一旦线程数加大丢失的数字也会增多，导致线程不安全。</p>
<p>线程不安全示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileTest test = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    test.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">"计算结果为："</span>+test.i);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行会发现结果不会等于100000，永远小于这个值。</p>
<h3 id="8-1-内存模型交互流程"><a href="#8-1-内存模型交互流程" class="headerlink" title="8.1 内存模型交互流程"></a>8.1 内存模型交互流程</h3><p>内存模型交互流程主要分为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200507233139910.png" alt="img"></p>
<ul>
<li>read：将变量值从主内存中读取到工作内存中</li>
<li>load：读取到变量值之后，将变量值放入到当前线程的变量副本中</li>
<li>use：将工作内存中的变量值传递给工作引擎</li>
<li>assign：执行完毕之后将变量值再赋值给工作内存中的变量</li>
<li>store：将工作变量中的值传递给主内存中</li>
<li>write：store之后，将store的值赋给主内存中的变量</li>
<li>lock：作用于主内存中的变量</li>
<li>unlock</li>
</ul>
<h3 id="8-2-内存模型的三大特性"><a href="#8-2-内存模型的三大特性" class="headerlink" title="8.2 内存模型的三大特性"></a>8.2 内存模型的三大特性</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p>Java内存操作模型保证了read、load、use、assign、store、write、lock和unlock的操作具有原子性，Java虚拟机允许将没有被volatile修饰的64位的基本类型数据的读写操作划分为两次32位的操作来执行，即load、store、read、write操作可以不具备原子性。</p>
<p>int类型的话也只是保证load、assign、store的单个的原子性，但不能保证整体操作的原子性，一般使用原子类例如AtomicInteger来保证操作的原子性。</p>
<p>或者使用synchronized关键字来实现原子性，这里主要是对于lock和unlock来说的，在虚拟机的实现上对应的字节码指令为monitorexit和monitorenter。</p>
<p>volatile关键字并不能保证原子性，虽然可以保证内存变量的可见性，但是对于原子性不能保证，这是因为在并发环境下，多个线程会去读取到实时的内存变量，但是当写回的时候就会发生数据丢失。</p>
<h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><p>可见性在java内存中的表现为当某个线程修改了这个共享的变量的值，其他使用当前变量的线程可以立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值从而实现可见性。</p>
<p>实现可见性的三个关键字：</p>
<p><strong>volatile：通过内存屏障和指令重排序保证可见性</strong></p>
<ul>
<li>对volatile进行读操作的时候，会在读操作之前增加一个load的屏障指令</li>
<li>对volatile进行写操作的时候，会在写操作之后增加一个store的屏障指令</li>
</ul>
<p><strong>内存屏障：处理器的一组指令，用于实现对内存操作的顺序限制（指令重排时不能把后面的指令重排到内存屏障之前的位置）</strong></p>
<p>上面加屏障的主要目的是确保，禁止指令重排，读取read不往后排，存储store不往前排。</p>
<p>即写不往前排，读不往后排。</p>
<p><strong>synchronized：同步块的可见性指的是，对一个变量unlock之前，必须把变量同步回主内存中，执行store，write操作</strong></p>
<p><strong>final：被final关键字修饰的字段在构造器中一旦初始化完成，并且没有发生this逃逸（其他线程通过this引用访问到初始化了一半的对象），那么其他线程就能看见final的关键字了。</strong></p>
<h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><p>有序性：在本线程内观察所有的操作都是有序的，但是在一个线程中观察另外一个线程，所有的操作都是无序的，无序是因为发生了指令重排，在JMM中允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，但是会影响到多线程并发的执行。</p>
<p>volatile关键字通过内存屏障来禁止指令重排序，即重排序不能够把屏障后面的指令，放到屏障之前。</p>
<p>synchronized关键字也可以保持有序性，即保证每一时刻只有一个线程同步执行代码，即让线程顺序同步执行。</p>
<h3 id="8-3-先行发生原则"><a href="#8-3-先行发生原则" class="headerlink" title="8.3 先行发生原则"></a>8.3 先行发生原则</h3><p><strong>单一线程原则</strong></p>
<p>在一个线程内，在程序前面的操作，先行发生于后面的操作。</p>
<p><strong>管程锁定原则</strong></p>
<p>一个unlock操作先行发生于一个lock操作之前</p>
<p><strong>volatile变量规则</strong></p>
<p>对一个volatile变量的写操作先于这个变量的读操作</p>
<p><strong>线程启动规则</strong></p>
<p>Thread的start()方法的调用先行发生于这个线程中的每一个动作，简单来说就是线程中的run有很多事情要处理，但是如果你不start()，后续这个run中的操作根本不会发生。</p>
<p><strong>线程加入原则</strong></p>
<p>Thread对象的结束先行发生于join()方法返回。也就是在A线程执行中，b.join()，那么这个b线程结束之前，join方法是不会返回到A线程中。</p>
<p><strong>线程中断规则</strong></p>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。也就是先要中断，然后才能检测到。</p>
<p><strong>对象终结规则</strong></p>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的执行</p>
<p><strong>传递性</strong></p>
<p>如果A先行发生操作B，B先行发生操作C，那么A先行发生操作C</p>
<h2 id="9-线程安全"><a href="#9-线程安全" class="headerlink" title="9. 线程安全"></a>9. 线程安全</h2><p>线程安全：多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现出正确的行为。</p>
<h3 id="9-1-不可变"><a href="#9-1-不可变" class="headerlink" title="9.1 不可变"></a>9.1 不可变</h3><p>一个不可变的对象一定是线程安全的，不需要采取其他保障线程安全的措施来保证不可变对象的安全性，只要一个不可变的对象被构建出来，永远也不会看到它在多个线程中不一致的状态，多线程环境下，应当尽量使得对象不可变，来满足线程安全。</p>
<p><strong>不可变的类型</strong></p>
<ul>
<li><p>final关键字修饰的对象</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举类型</p>
</li>
<li><p>Number的部分子类。但是同为Number子类的AtomicInteger和AtomicLong是可变的。</p>
</li>
<li><p>集合类型的话可以使用Collections.unmodifiableList(list)类似这种方式获取不可变的集合</p>
</li>
</ul>
<h3 id="9-2-互斥同步"><a href="#9-2-互斥同步" class="headerlink" title="9.2 互斥同步"></a>9.2 互斥同步</h3><p>互斥同步的话就是我们一般说的锁机制，一般有synchronized和ReentrantLock</p>
<h3 id="9-3-非阻塞同步"><a href="#9-3-非阻塞同步" class="headerlink" title="9.3 非阻塞同步"></a>9.3 非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和线程唤醒所带来的性能问题，因此这种同步也被称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发同步策略，就是认为如果不做同步的措施就一定会出问题。无论共享数据是否真的被竞争，它都会加锁。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程进行数据争用，那么操作就成功了，如果有其他线程争用，则采用补偿机制，即不断的重试，直到成功为止。这种乐观的并发策略不需要将线程阻塞住，因此这种同步被称为<strong>非阻塞同步</strong>。</p>
<p><strong>CAS</strong></p>
<p>Compare and Swap比较交换，比较并交换有三个参数，比如是cas(V,A,B)，V表示内存地址，A是旧的预期值，B是待更新的值，即如果内存地址V处的值为A，则更新V处的值为B。</p>
<p><strong>AtomicInteger</strong></p>
<p>AtomicInteger可以实现非阻塞同步，底层的实现就是unsafe中的CAS操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;<span class="comment">// 当前对象，值偏移量，1表示增加1</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;<span class="comment">// 定义一个变量var5</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);<span class="comment">// 获取内存中当前位置的值</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"><span class="comment">// 如果值是var5的话，就把值替换为var5+var4,即var5+1,否则继续看这个值是否符合预期。直到符合预期</span></span><br><span class="line">    <span class="keyword">return</span> var5;<span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意：</strong></font>使用CAS确实很好，但是这个会有一个问题即著名的ABA问题，即假设有两个线程，线程1将A的值修改为B，而线程2将B修改为A，此时系统会当做这个变量没有发生变化，但是这个变量发生了两次修改。JUC中提供了原子类AtomicStampReference来解决这个问题，即记住当前修改的邮戳。大部分情况下ABA问题不会影响程序执行的正确性。</p>
<h3 id="9-4-无同步方案"><a href="#9-4-无同步方案" class="headerlink" title="9.4 无同步方案"></a>9.4 无同步方案</h3><p>没有同步方案不一定不能保证线程安全，如果一个方法本来就不涉及共享数据，那它就没必要使用同步措施来保证同步了。</p>
<p><strong>栈空间</strong></p>
<p>如果多个线程同时访问一个方法中的局部变量，根据JVM虚拟机的模型中的组成可以知道，局部变量表是存储在栈帧中的是属于线程私有的，不会出现线程安全问题。</p>
<p><strong>线程本地存储</strong></p>
<p>线程本地存储即ThreadLocal，即每个线程都拥有的自己本地的一个变量即线程私有。</p>
<p>ThreadLocal从理论上来说并不是为了解决多线程并发问题的，因为根本不存在多线程竞争的问题。</p>
<p>在一些场景（尤其是使用线程池）下，由于ThreadLocal.ThreadLocalMap的底层数据结构到值ThreadLocal有内存泄露的情况，应尽可能在每次使用ThreadLocal后手动调用remove方法，以避免ThreadLocal经典的内存泄露甚至造成自身的业务混乱的风险。</p>
<p><a href="https://blog.csdn.net/puppylpg/article/details/80433271" target="_blank" rel="noopener">ThreadLocal原理及内存泄露预防</a></p>
<h2 id="10-锁优化"><a href="#10-锁优化" class="headerlink" title="10. 锁优化"></a>10. 锁优化</h2><p>指代JVM对synchronized锁的优化</p>
<h3 id="10-1-自旋锁"><a href="#10-1-自旋锁" class="headerlink" title="10.1 自旋锁"></a>10.1 自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁的时候执行忙循环（自旋），如果这段时间可以获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能够避免进入阻塞状态从而减少开销，但是它需要进行忙循环占用CPU时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在jdk1.6中引入了自适应的自旋锁，自适应意味着自旋的次数不再固定了而是由前一次在同一个锁上的自旋次数以及锁的持有者的状态来决定的。</p>
<h3 id="10-2-锁消除"><a href="#10-2-锁消除" class="headerlink" title="10.2 锁消除"></a>10.2 锁消除</h3><p>锁消除是指对于检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持的，如果堆上的共享数据不可能逃逸出去被其他线程访问到，那么就可将他们当做私有数据对待，也就可以将它们的锁进行消除。</p>
<h3 id="10-3-锁粗化"><a href="#10-3-锁粗化" class="headerlink" title="10.3 锁粗化"></a>10.3 锁粗化</h3><p>如果一系列连续的操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。例如StringBuffer中的append方法，连续几个append方法可以粗化为加锁一次即可。</p>
<h3 id="10-4-轻量级锁"><a href="#10-4-轻量级锁" class="headerlink" title="10.4 轻量级锁"></a>10.4 轻量级锁</h3><p>jdk1.6引入了轻量级锁和偏向锁，从而让锁拥有四个状态：无锁状态（unlock）、偏向锁状态（biasble）、轻量级锁状态（lightweight lock）和重量级锁状态（inflated）</p>
<p>Mark Word对象头里面的数据。</p>
<p>轻量级锁是相对重量级锁而言的，它使用CAS来避免重量级锁使用互斥量的开销，对于绝大部分的锁，在整个同步周期内都不存在竞争，因此也都不需要使用互斥量进行同步，可以先采用CAS进行同步，如果CAS失败再改用互斥量同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为0 01，说明当前锁对象的锁未锁定（unlock）状态，此时虚拟机在当前线程的虚拟机栈中创建Lock Record，然后使用CAS操作将对象的Mark Word更新为Lock Record指针，如果CAS操作成功了，那么该线程就获取到了该对象上的锁，并且对象的Mark Word的锁标记变为00，处于轻量级锁状态。</p>
<p>如果CAS操作失败了，虚拟机会首先检查对象的Mark Word是否指向当前线程的虚拟机栈，如果是的话表明当前线程已经拥有这个锁对象，就可以直接进入这个同步块继续执行，否则说明这个锁对象已经被其他线程抢占了，如果有两个以上线程争抢同一个锁，那轻量级锁就不再有效，需要膨胀为重量级锁了。</p>
<pre><code>1.初期锁对象刚创建时，还没有任何线程来竞争，对象的Mark Word是下图的第一种情形，这偏向锁标识位是0，锁状态01，说明该对象处于无锁状态（无线程竞争它）。

2.当有一个线程来竞争锁时，先用偏向锁，表示锁对象偏爱这个线程，这个线程要执行这个锁关联的任何代码，不需要再做任何检查和切换，这种竞争不激烈的情况下，效率非常高。这时Mark Word会记录自己偏爱的线程的ID，把该线程当做自己的熟人。如下图第二种情形。

3.当有两个线程开始竞争这个锁对象，情况发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的Mark Word就执行哪个线程的栈帧中的锁记录。如下图第三种情形。

4.如果竞争的这个锁对象的线程更多，导致了更多的切换和等待，JVM会把该锁对象的锁升级为重量级锁，这个就叫做同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，这个监视器对象用集合的形式，来登记和管理排队的线程。如下图第四种情形。</code></pre><p><img src="https://img-blog.csdnimg.cn/20190111091608949.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="10-5-偏向锁"><a href="#10-5-偏向锁" class="headerlink" title="10.5 偏向锁"></a>10.5 偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁的就不再需要同步，甚至连CAS操作也不需要了。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为1 01，同时使用CAS操作将该线程ID记录到Mark Word中，如果CAS成功，以后这个线程进入到这个锁相关的同步块就不需要在进行任何同步操作了。</p>
<p>当有另一个线程去尝试获取这个锁的对象的时候，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级状态。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" alt="img"></p>
<p>图上也有很形象的Mark Word内容转移图。</p>
<h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11. 小结"></a>11. 小结</h2><p>以上就是Java并发相关的所有的内容，其中还有些地方待补充</p>
<ul>
<li><input disabled="" type="checkbox"> 线程池的拒绝策略问题</li>
<li><input disabled="" type="checkbox"> ThreadLocal源码&amp;内存泄露的根本原因</li>
</ul>
<p>Java并发是面试中一个很重要的点，现在的网站并发都很高，如何抗住这些并发也是这些基础知识累积起来的，会的话在编程的时候逻辑思维就会主动的去思考这些如何实现，从而潜移默化的优化代码。并发很重要继续加油，Keep thinking，keep coding!</p>
]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础复习</title>
    <url>/2020/04/14/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java基础复习-2020-04-12开始"><a href="#Java基础复习-2020-04-12开始" class="headerlink" title="Java基础复习(2020-04-12开始)"></a>Java基础复习(2020-04-12开始)</h2><h3 id="1-String、StringBuffer、StringBuilder"><a href="#1-String、StringBuffer、StringBuilder" class="headerlink" title="1. String、StringBuffer、StringBuilder"></a>1. String、StringBuffer、StringBuilder</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是不可变的，为什么不可变？因为底层的实现是通过一个不可变的char[]类型的数组实现的。</p>
<p>且在String中所有的字符操作都是改变value的指向，并没有实际改变value的值。也即重新创建了一个对象。</p>
<p>因为是不可变的，所以线程安全。</p>
<ul>
<li>因为不可变，可以缓存hash值，hash值也是不可变的，避免重复多次计算</li>
<li>因为不可变，可以使用String pool，每次创建如果String pool中有，可以直接取得引用，只有不可变才可以使用String pool</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>是可变的，继承自AbstractStringBuilder，主要是使用append方法来改变的。</p>
<p>线程安全的，因为每一个方法都被加上了synchronized关键字修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>StringBuilder也是继承自AbstractStringBuilder，可变的。不是线程安全的。</p>
<h4 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h4><p>intern方法的话，表示如果再String pool中存在当前字符则直接取出返回，否则将当前字符串加入到String Pool中。如果存在当前字符串，则取出的使用<code>equals()</code>方法则为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="new-String-“abc”-创建对象个数"><a href="#new-String-“abc”-创建对象个数" class="headerlink" title="new String(“abc”)创建对象个数"></a>new String(“abc”)创建对象个数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String abc = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>首先答案为1个或者2个对象个数。注意”abc”是字符串字面量。</p>
<ul>
<li>1个的情况，创建的时候发现String Pool中存在abc对象，此时只需要在堆上创建一个对象即可</li>
<li>2个的情况，创建的时候发现String Pool中不存在abc对象，此时需要再String Pool中创建一个”abc”对象指向字符串字面量，然后在堆中创建一个abc字符串对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两个对象，一个是存在常量表中，一个是存放在堆中，所以地址不同</span></span><br><span class="line"><span class="comment">// 但是他们的内容都是指向字符串字面量test</span></span><br><span class="line">String s1 = <span class="string">"test"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<p>如果String是可变的话，在for循环操作的时候就会破坏set集合，出现重复，但是实际上，并没有改变值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"a"</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"b"</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">"c"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String a: set)&#123;</span><br><span class="line">  a = <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(set);<span class="comment">// [a,b,c]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Java参数传递"><a href="#2-Java参数传递" class="headerlink" title="2. Java参数传递"></a>2. Java参数传递</h3><p>值传递还是引用传递: </p>
<ul>
<li>第一段代码修改其中的值，返回的是修改后的数据，值传递。</li>
<li>第二段代码修改对象的引用，返回的是原对象，表明引用传递失效，仍旧为值传递。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  A a = <span class="keyword">new</span> A(<span class="string">"A"</span>);</span><br><span class="line">  System.out.println(a.getName());</span><br><span class="line">  modifyName(a); <span class="comment">// A</span></span><br><span class="line">  System.out.println(a.getName()); <span class="comment">// B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyName</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">  a.setName(<span class="string">"B"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  A a = <span class="keyword">new</span> A(<span class="string">"A"</span>);</span><br><span class="line">  System.out.println(a.getName()); <span class="comment">// A</span></span><br><span class="line">  modifyName2(a);</span><br><span class="line">  System.out.println(a.getName()); <span class="comment">// A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyName2</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">  System.out.println(a.getName()); <span class="comment">// B</span></span><br><span class="line">  a = <span class="keyword">new</span> A(<span class="string">"B"</span>);</span><br><span class="line">  System.out.println(a.getName()); <span class="comment">// A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-final关键字"><a href="#3-final关键字" class="headerlink" title="3. final关键字"></a>3. final关键字</h3><p>final关键字可以修饰变量，类，以及方法</p>
<ul>
<li><p>修饰变量的时候，此时表示当前的变量是常量，不可变。</p>
<ul>
<li>如果是基本类型数据，表示值不可变</li>
<li>如果是引用类型数据，表示引用不变，即不能引用其他对象，但是被引用的对象本身是可以改变的，也就是其中属性的值是可变的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String s = <span class="string">"abc"</span>;</span><br><span class="line">String s1 = <span class="string">"bcd"</span>;</span><br><span class="line"><span class="comment">// s = s1; // Cannot assign value to final variable 's'</span></span><br><span class="line">String replace = s.replace(<span class="string">'c'</span>, <span class="string">'a'</span>);</span><br><span class="line">System.out.println(replace); <span class="comment">// aba</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰类的时候，表示当前类不可被继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">// Cannot inherit from final A</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰方法的时候，表示当前方法不可被子类重写</p>
</li>
</ul>
<h3 id="4-程序语句块执行顺序"><a href="#4-程序语句块执行顺序" class="headerlink" title="4. 程序语句块执行顺序"></a>4. 程序语句块执行顺序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String a = getString();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类静态变量"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"父类静态变量"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String b = getString();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类静态变量"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"子类静态变量"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类静态变量  父类静态代码块<br>子类静态变量  子类静态代码块<br>父类普通代码块 父类构造方法<br>子类普通代码块 子类构造方法</p>
</blockquote>
<p>统一来讲</p>
<blockquote>
<p>父类（静态变量、静态代码块）</p>
<p>子类（静态变量、静态代码块）</p>
<p>父类（普通变量、普通代码块）</p>
<p>父类（构造方法）</p>
<p>子类（普通变量、普通代码块）</p>
<p>子类（构造方法）</p>
</blockquote>
<h3 id="5-Object的方法"><a href="#5-Object的方法" class="headerlink" title="5. Object的方法"></a>5. Object的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass(); <span class="comment">// 获取当前对象的类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>; <span class="comment">// 返回哈希值，主要用于HashMap中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; <span class="comment">// equals方法，判断两个对象是否相等</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>; <span class="comment">// 对象克隆方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// toString方法，返回代表当前对象的字符串</span></span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>; <span class="comment">// 唤醒某个等待当前对象的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>; <span class="comment">// 唤醒所有的等待当前对象的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 线程等待方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;&#125;;<span class="comment">// 线程等待方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 无限期等待</span></span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125; <span class="comment">// gc的时候调用的，判断对象是否真的要被回收</span></span><br></pre></td></tr></table></figure>

<h3 id="6-浅拷贝-amp-深拷贝"><a href="#6-浅拷贝-amp-深拷贝" class="headerlink" title="6. 浅拷贝&amp;深拷贝"></a>6. 浅拷贝&amp;深拷贝</h3><p>浅拷贝只是拷贝对象的引用，而深拷贝是拷贝出一个全新的对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by caoduanxi on 2020/4/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowClone</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] course;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        ShallowClone shallow = <span class="keyword">new</span> ShallowClone();</span><br><span class="line">        shallow.setName(<span class="string">"caoduanxi"</span>);</span><br><span class="line">        shallow.setAge(<span class="number">24</span>);</span><br><span class="line">        shallow.setCourse(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">        System.out.println(shallow.toString());</span><br><span class="line">        ShallowClone clone = (ShallowClone)shallow.clone();</span><br><span class="line">        <span class="comment">// 对于基本数据类型的改变，不会影响</span></span><br><span class="line">        shallow.setName(<span class="string">"modify name"</span>);</span><br><span class="line">        System.out.println(clone.getName()+<span class="string">"::"</span>+clone.getAge());</span><br><span class="line">        System.out.println(shallow.getName()+<span class="string">"::"</span>+clone.getAge());</span><br><span class="line">        <span class="comment">// 对于引用类型数据的变化，会有影响</span></span><br><span class="line">        <span class="keyword">int</span>[] course = shallow.course;</span><br><span class="line">        course[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">        shallow.setCourse(course);</span><br><span class="line">        System.out.println(<span class="string">"clone:"</span>+ Arrays.toString(clone.getCourse()));</span><br><span class="line">        System.out.println(<span class="string">"shallow:"</span>+ Arrays.toString(shallow.getCourse()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ShallowClone(name=caoduanxi, age=24, course=[1, 2, 3, 4, 5])<br>caoduanxi::24<br>modify name::24<br>clone:[100, 2, 3, 4, 5]<br>shallow:[100, 2, 3, 4, 5]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by caoduanxi on 2020/4/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepClone</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] course;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 深拷贝的话，拷贝的是一个全新的对象,但是这个全新对象的值是等于拷贝的对象的</span></span><br><span class="line">        <span class="comment">// 但是值是可以被修改的</span></span><br><span class="line">        DeepClone deepClone = <span class="keyword">new</span> DeepClone();</span><br><span class="line">        deepClone.setAge(<span class="keyword">this</span>.age);</span><br><span class="line">        deepClone.setName(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">int</span>[] course = <span class="keyword">this</span>.course;</span><br><span class="line">        <span class="keyword">int</span>[] cloneCourse = <span class="keyword">new</span> <span class="keyword">int</span>[course.length];</span><br><span class="line">        System.arraycopy(course, <span class="number">0</span>, cloneCourse, <span class="number">0</span>, course.length);</span><br><span class="line">        deepClone.setCourse(cloneCourse);</span><br><span class="line">        <span class="keyword">return</span> deepClone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepClone deep = <span class="keyword">new</span> DeepClone();</span><br><span class="line">        deep.setCourse(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">        deep.setName(<span class="string">"caoduanxi"</span>);</span><br><span class="line">        deep.setAge(<span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"deep:"</span> + deep);</span><br><span class="line">        DeepClone clone = (DeepClone) deep.clone();</span><br><span class="line">        System.out.println(<span class="string">"clone:"</span> + clone);</span><br><span class="line">        <span class="comment">// 对基本类型进行修改，互相不影响</span></span><br><span class="line">        deep.setName(<span class="string">"deep modify name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"deep:"</span> + deep.getName());</span><br><span class="line">        clone.setName(<span class="string">"clone modify name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"clone:"</span> + clone.getName());</span><br><span class="line">        <span class="comment">// 对引用类型进行修改，也不影响</span></span><br><span class="line">        <span class="keyword">int</span>[] course = deep.getCourse();</span><br><span class="line">        course[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">        System.out.println(<span class="string">"deep course:"</span> + Arrays.toString(deep.getCourse()));</span><br><span class="line">        System.out.println(<span class="string">"clone course:"</span> + Arrays.toString(clone.getCourse()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>deep:DeepClone(name=caoduanxi, age=25, course=[1, 2, 3, 4, 5])<br>clone:DeepClone(name=caoduanxi, age=25, course=[1, 2, 3, 4, 5])<br>deep:deep modify name<br>clone:clone modify name<br>deep course:[1000, 2, 3, 4, 5]<br>clone course:[1, 2, 3, 4, 5]</p>
</blockquote>
<p>最好的深拷贝实现方法就是通过对象序列化的方式来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by caoduanxi on 2020/4/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneBySerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] course;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        DeepCloneBySerializable deep =</span><br><span class="line">                <span class="keyword">new</span> DeepCloneBySerializable(<span class="string">"caoduanxi"</span>, <span class="number">24</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(deep);</span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">// 读入对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">        DeepCloneBySerializable clone = (DeepCloneBySerializable) ois.readObject();</span><br><span class="line">        <span class="keyword">int</span>[] course = deep.getCourse();</span><br><span class="line">        course[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">        System.out.println(<span class="string">"deep:"</span> + deep.toString() + <span class="string">"\nclone:"</span> + clone.toString());</span><br><span class="line">        System.out.println(<span class="string">"deep course:"</span> + Arrays.toString(deep.getCourse()));</span><br><span class="line">        System.out.println(<span class="string">"clone course:"</span> + Arrays.toString(clone.getCourse()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>deep:com.example.pratice.test.DeepCloneBySerializable@6e0be858<br>clone:com.example.pratice.test.DeepCloneBySerializable@5b480cf9<br>deep course:[1000, 2, 3, 4, 5]<br>clone course:[1, 2, 3, 4, 5]</p>
</blockquote>
<h3 id="7-equals-amp-hashCode"><a href="#7-equals-amp-hashCode" class="headerlink" title="7. equals&amp;hashCode"></a>7. equals&amp;hashCode</h3><p>equals方法比较的是两个对象的数据是否相等。而hashCode比较的是两个对象的哈希值是否相等。</p>
<p>哈希值是有一定范围限制的，所以会出现两个对象具有相同哈希值的情况，所以可以知道<font color="red">哈希值相等的对象不一定相等</font></p>
<p>equals方法比较的是两个对象的值是否相等，<font color="red">如果equals相等，那么当前对象也就相等，他们的哈希值也就相等</font></p>
<blockquote>
<p>问：为什么重写equals方法的时候要重写hashCode方法？</p>
</blockquote>
<p>一般来说hashcode用的多的是在HashMap中用来对数据存放的table位置进行一个定位，数据很多会有相等的table位置，但是table里面存储的是链表以及红黑树，此时hashcode相等不能代表当前对象相等，还需要比较他们的值是否equals，如果是，那么就定位到了准确的数据点。</p>
<p>如果不重写hashcode方法，会造成两个对象相等，但是hashcode不相等的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsAndHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        EqualsAndHash that = (EqualsAndHash) o;</span><br><span class="line">        <span class="keyword">return</span> x == that.x &amp;&amp;</span><br><span class="line">                y == that.y &amp;&amp;</span><br><span class="line">                z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(x, y, z);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EqualsAndHash eah = <span class="keyword">new</span> EqualsAndHash(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        EqualsAndHash hae = <span class="keyword">new</span> EqualsAndHash(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(eah.equals(hae)); </span><br><span class="line">        System.out.println(<span class="string">"eah: "</span> + eah.hashCode() + <span class="string">"\nhae: "</span> + hae.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>true<br>eah: 621009875<br>hae: 1265094477</p>
</blockquote>
<p>上述结果就是重写了equals，没有重写hashcode方法出现的哈希值不等的情况。</p>
<p><font color="red">原因：</font>如果重写了hashcode，那么两个对象会调用相同的hashCode计算方法计算。但是没有重写，相当于两个对象去请求Object的hashCode()方法，自然返回两个不同的哈希值。</p>
<h3 id="8-访问权限修饰符"><a href="#8-访问权限修饰符" class="headerlink" title="8. 访问权限修饰符"></a>8. 访问权限修饰符</h3><p>Java的访问权限修饰符有四个：public、protected、默认default、private</p>
<p>public是全都可见</p>
<p>protected是当前类，当前包下，当前子类下</p>
<p>default是当前类，当前包下</p>
<p>private是当前类</p>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>当前类</th>
<th>同一包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="9-重写与重载"><a href="#9-重写与重载" class="headerlink" title="9. 重写与重载"></a>9. 重写与重载</h3><p>重写：发生在继承体系中</p>
<ul>
<li>子类方法的访问权限必须大于父类方法</li>
<li>子类方法的返回类型必须是父类返回类型或者其子类型</li>
<li>子类抛出的异常类型必须是父类抛出异常类型或者子类型</li>
</ul>
<p>重载：发生在一个类下面，指代一个方法名称相同，但是参数类型、个数、顺序至少有一个不同。<font color="red">注意：不能以返回值不同来定义重载！</font></p>
<h3 id="10-Java反射机制"><a href="#10-Java反射机制" class="headerlink" title="10. Java反射机制"></a>10. Java反射机制</h3><p>定义：指代程序可以检测、访问、修改自身状态或者行为的能力</p>
<p>作用：</p>
<ul>
<li>运行时判断一个对象所属的类</li>
<li>运行时构造任意一个类的对象</li>
<li>运行时判断一个类所具有的属性与方法</li>
<li>运行时调用任意一个对象的方法</li>
</ul>
<h3 id="11-异常"><a href="#11-异常" class="headerlink" title="11. 异常"></a>11. 异常</h3><p>异常主要分为两种：Error、Exception，父类都为Throwable</p>
<p>Error表示JVM无法处理的错误，而Exception表示可以处理。</p>
<p>Exception分为两种：</p>
<ul>
<li>受检异常：程序员可以使用try…catch语句捕获并进行处理的，可以从异常中恢复，保障程序能够正常的运行</li>
<li>非受检异常：程序运行是发生的错误，会导致程序崩溃无法恢复。</li>
</ul>
<p>受检异常：IOException</p>
<p>非受检异常：RuntimeException-&gt;IndexOutOfBoundsException</p>
]]></content>
      <categories>
        <category>秋招复习</category>
      </categories>
      <tags>
        <tag>Java基础|秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础复习</title>
    <url>/2020/04/14/%E9%9B%86%E5%90%88%E7%B1%BB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="集合类-2020-04-12"><a href="#集合类-2020-04-12" class="headerlink" title="集合类(2020-04-12)"></a>集合类(2020-04-12)</h2><h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1. 整体介绍"></a>1. 整体介绍</h3><p>常见的集合类有：Map/Set/List/Queue</p>
<p><strong>Map:</strong></p>
<ul>
<li>TreeMap：红黑树实现，支持有序性操作，查找时间复杂度O(logn)</li>
<li>HashMap：底层数组+链表+红黑树实现，查找时间复杂度O(1)</li>
<li>LinkedHashMap：基于HashMap实现，但是底层相比HashMap维护了双向链表（LRU算法），双向链表维持了元素的顺序</li>
<li>HashTable：与HashMap基本一致，但是是线程安全的，使用synchronized关键字修饰</li>
</ul>
<p><strong>Set：</strong>插入的元素不能保证有序性，所以是无序的</p>
<ul>
<li>TreeSet：红黑树实现，支持有序性操作。</li>
<li>HashSet：基于HashMap实现，只是将其中的键值变化为只存取值，从而实现了去重的特性。</li>
<li>LinkedHashSet：具有HashSet的查找效率，内部使用双向链表维持元素的插入顺序。</li>
</ul>
<p><strong>List：</strong>有序</p>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是支持快速插入和快速删除，可用作栈、队列、双向队列的实现</li>
<li>Vector：与ArrayList类似，但是是线程安全的，使用synchronized关键字修饰</li>
</ul>
<p><strong>Queue：</strong>双向队列</p>
<ul>
<li>LinkedList：如上介绍</li>
<li>PriorityQueue：底层基于堆结构实现（堆底层还是数组），可以保证最顶端的元素是最小（大）的，不能保证整体有序。</li>
</ul>
<h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h3><p>ArrayList中的快速失败机制，何为快速失败机制，就是在迭代器遍历的过程中对数据进行一个修改，会抛出一个<code>ConcurrentModificationException</code>，这个异常是因为期待的expectedModCount与实际的modeCount数值不一样大。ArrayList的没一次操作，都会使得modeCount++。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">  list.remove(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">Exception in thread “main” java.util.ConcurrentModificationException</font></p>
<p>错误的起因是因为3次add操作，此时modeCount为3，期待的expectedModCount也为3，但是在迭代过程中，发生了一次remove操作，此时modeCount=4，但是expectedModCount是在迭代器简历的时候赋值，仍然为3，于是就抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification(); <span class="comment">// 在每一次的迭代下一个元素的过程中会检查，一旦不等，直接抛出异常</span></span><br><span class="line">  <span class="keyword">int</span> i = cursor;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  cursor = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是所谓的快速失败机制。</p>
<p><strong>简单看看ArrayList的源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认容量大小为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;; <span class="comment">// 初始化的是一个空的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一系列扩容操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 扩容按照1.5倍速</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">  <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// 最大是有限制的</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">  <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">    Integer.MAX_VALUE :</span><br><span class="line">  MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除元素remove：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) <span class="comment">// 意思就是复制当前元素后面的元素到移除这个元素的位置，长度为中间减去的长度</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h3><p>基本与ArrayList类似，但是所有的方法都是线程安全的，使用了synchronized关键字修饰。扩容是直接两倍的库容。</p>
<p><strong>与ArrayList的区别</strong></p>
<ul>
<li>Vector是同步的，开销比ArrayList要大，访问速度更慢。建议最好使用ArrayList而不是Vector，同步的过程可以由程序员自主控制。</li>
<li>扩容，Vector是两倍，ArrayList是1.5倍</li>
</ul>
<h3 id="4-线程安全的List"><a href="#4-线程安全的List" class="headerlink" title="4. 线程安全的List"></a>4. 线程安全的List</h3><h4 id="4-1-java-util-Collections-SynchronizedList"><a href="#4-1-java-util-Collections-SynchronizedList" class="headerlink" title="4.1 java.util.Collections.SynchronizedList"></a>4.1 java.util.Collections.SynchronizedList</h4><p>可以使用<code>Collections.Synchronizedlist</code>获取一个线程安全的List</p>
<h4 id="4-2-java-util-concurrent-CopyOnWriteArrayList"><a href="#4-2-java-util-concurrent-CopyOnWriteArrayList" class="headerlink" title="4.2 java.util.concurrent.CopyOnWriteArrayList"></a>4.2 java.util.concurrent.CopyOnWriteArrayList</h4><p><code>CopyOnWriteArrayList</code>主要是利用ReentrantLock来实现的在写的时候加锁操作，防止并发出现问题，但是读的时候是不加锁的，这就是所谓的”读写分离“操作。“写时复制”</p>
<p>来看看写数据的方法：add()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 获取到锁</span></span><br><span class="line">  lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">// 赋值一个新的数组进行操作</span></span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    setArray(newElements);<span class="comment">// 设置复制后的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">  array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读数据的话，直接再array中读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<p>CopyOnWriteArrayList适合在写操作的时允许读操作，提高了读操作的性能，适合读多写少的场景。</p>
<p>存在的缺点：</p>
<ul>
<li>从上面add的代码中可以看到，是复制出了一个副本，此时内存占用是两倍的形式。</li>
<li>数据不一致问题：可以看出上面读的数据并不能够保证它的实时性，因为写操作加了锁，读操作并没有加锁，可能读的时候写操作的数据还未同步到读的数组中。</li>
</ul>
<p>综上：CopyOnWriteArrayList并不适合内存敏感以及实时性要求很高的场景。</p>
<h3 id="5-LinkedList"><a href="#5-LinkedList" class="headerlink" title="5. LinkedList"></a>5. LinkedList</h3><p>底层基于链表实现，在整个list中维护着first与last节点，数据存放在Node&lt;E&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加元素操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);<span class="comment">// 连接最后一个元素，默认是从后面插入的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">// 获取当前的last节点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>); <span class="comment">// 由于插入也是一个节点，构造一个节点</span></span><br><span class="line">  last = newNode; <span class="comment">// 移动last节点到当前的newNode节点</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">// 如果last节点为null，表明当前list中没有元素，first指向newNode(唯一的元素)</span></span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    l.next = newNode; <span class="comment">// 如果不为null的话，表示前面有元素，此时连接前后的关系。pre在new Node建立</span></span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与ArrayList比较</strong></p>
<ul>
<li>LinkedList底层基于链表实现，ArrayList底层基于动态数组实现</li>
<li>LinkedList不支持随机访问，只能挨个遍历。ArrayList支持随机访问</li>
<li>LinkedList插入删除O(1)，查找O(n)（实质是O(n/2)，遍历了一半的链表）；ArrayList插入删除O(n)，查找O(1)</li>
</ul>
<h3 id="6-HashMap"><a href="#6-HashMap" class="headerlink" title="6. HashMap"></a>6. HashMap</h3><p>HashMap的话，首先说底层实现JDK1.7底层是数组+链表实现，而在JDK1.8中底层是数组+链表+红黑树实现，当节点个数超过8个，此时会树化为红黑树。但是当节点为6个时，此时需要恢复为链表。为什么负载因子是o.75，这个是有说是泊松分布的原因。</p>
<p><strong>以下是基于JDK1.8源码</strong></p>
<p>存储结构Node&lt;K,V&gt;，可以看出如果出现哈希冲突，是使用拉链法来解决（next指针）。每一个Node代表一个节点数据，遇到哈希冲突，直接通过next指针来连接即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-put操作"><a href="#6-1-put操作" class="headerlink" title="6.1 put操作"></a>6.1 put操作</h4><p><strong>put插入元素操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 存储元素表是否为空，是的话初始化</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 否则判断tab中当前hash位置是否为null，表示没有元素</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// 构造新新节点直接插入</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k; <span class="comment">// 都不是的话，就等于找到了tab中的那个槽，判断是否与第一个hash相等且值相等</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p; <span class="comment">// 是的话，直接覆盖</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 否则判断为树的话，直接树化</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则只能是出现了hash冲突，采用拉链法解决，就往下找</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// binCount统计个数，8个需要树化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">// 看是不是到了最后一个，是的话，构造新节点即可</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash); <span class="comment">// 树化</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// 不是最后一个，判断是否找到了，放心第一次绝对不会命中！因为上面有阶段判断。精辟！</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e; <span class="comment">// 否则继续下移，直到找到，或者把节点安放为止</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// 判断上面是否是覆盖了原来的值，是的话需要取出</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">// 仅仅是当前节点不存在或者</span></span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e); <span class="comment">// 这是LinkedHashMap中的访问节点后操作</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount; <span class="comment">// 改变次数+1</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 这是为了没有替换的元素，直接插入导致的null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-resize扩容操作"><a href="#6-3-resize扩容操作" class="headerlink" title="6.3 resize扩容操作"></a>6.3 resize扩容操作</h4><p><strong>扩容resize操作：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr; <span class="comment">// 上面基本是容量翻倍，门限值翻倍</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 构建新的map数据表</span></span><br><span class="line">  table = newTab;<span class="comment">// table变为新表</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 不为null才遍历赋值，否则直接返回新表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e; </span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;<span class="comment">// 这里是清楚老表，方便回收，同时获取到当前e节点</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">// 如果只有一个，直接与新的节点&amp;操作获取自己的槽</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果是树类型，使用树的操作</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保存顺序 否则就是链表多个节点了</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next; <span class="comment">// 这里使用next保存下一个几点</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 老节点&amp;老容量必定为0</span></span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// </span></span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e; <span class="comment">// 这里是尾插入法</span></span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果&amp;操作为1，必定是新的槽位上的数据</span></span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e; <span class="comment">// 尾插法</span></span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; <span class="comment">// 如果再最后位置，将j位置放入老的链表</span></span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123; <span class="comment">// 如果是在最后位置，将j+oldCap位置放入新的链表</span></span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab; <span class="comment">// 返回链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下<code>e.hash &amp; oldCap == 0</code>可以断定为低位的数据。为1可以断定为高位的数据</p>
<blockquote>
<p>举个例子，从容量16扩容到32，即10000 -&gt; 100000</p>
<p>此时在0-15的槽位中的数据，hash值只能为0-15，此时可以知道如果是低位数据值最大为01111即15，此时进行&amp;操作10000 &amp; 01111 = 0必为0，但是如果是高位数据呢，一般来说是处于16-31范围之内，此时我们举个31的例子，即011111 &amp; 010000 = 16也就是不为1。所以可以断定为是高位数据。</p>
</blockquote>
<p>对于为什么要进行resize操作，也就是扩容操作，这里我的理解是当元素达到map表装不下的时候，此时需要进行扩容，但是对于数据之前如果是在16的槽位的数据表中，最大的也不过15，但是注意它那个使用自己hash&amp;15 = {0,15}，有些数据其实是高位，但是没办法啊，只有16个槽位。</p>
<p>这也就是为什么在进行resize操作的时候有高低位数据之间的区分了。主要就是为了拯救那些委曲求全的高位大佬们，帮助它们找到自己新的释放才能的槽位处。</p>
<p><font color="red">注意：上面的高低位数据的插入都是使用的尾插法，这一举措解决了jdk1.7中以后的头插法会导致死循环的问题。</font>jdk1.7中的头插法，在下面列出来。</p>
<h4 id="6-3-jdk1-7的resize扩容操作"><a href="#6-3-jdk1-7的resize扩容操作" class="headerlink" title="6.3 jdk1.7的resize扩容操作"></a>6.3 jdk1.7的resize扩容操作</h4><p><strong><font color="red">JDK1.7的扩容</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable，initHashSeedAdNeeded(newCapacity)); <span class="comment">// 数据转移</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor,MAXMUM_CAPACITY+<span class="number">1</span>);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>重点在这个转移数据的方法transfer中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">// 头插法</span></span><br><span class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">// 将元素放在数组上</span></span><br><span class="line"><span class="number">13</span>                 e = next;             <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下头插法怎么形成链表的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20200412232416291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzEzMTUwMjA2MjY=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="6-4-remove操作"><a href="#6-4-remove操作" class="headerlink" title="6.4 remove操作"></a>6.4 remove操作</h4><p><strong>移除node的操作，remove方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index; <span class="comment">// 当前tab，节点p，n：表长度，index：哈希的下标</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>)&#123;<span class="comment">//确保表不为空，长度大于0，当前hash的下标不为null</span></span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      node = p;<span class="comment">// 正好找到的话。直接替换</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果不是当前节点，且存在下一个，</span></span><br><span class="line">      <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 看是否是红黑树</span></span><br><span class="line">        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 只能是链表了</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 循环找到节点</span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key ||</span><br><span class="line">               (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            node = e;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">// 最后判断是否有要返回的值</span></span><br><span class="line">    <span class="comment">// 如果不是值必须相等才能替换，或者说值相等</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                         (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 移除节点</span></span><br><span class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">// 如果替换的正好就是这个槽位，直接将下一个放到你这个槽位上来</span></span><br><span class="line">        tab[index] = node.next;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        p.next = node.next;<span class="comment">// 如果不是正好就是槽位，仅是替换了节点的话，此时需要将p.next -&gt; node.next</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      --size;</span><br><span class="line">      afterNodeRemoval(node);</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-get操作"><a href="#6-5-get操作" class="headerlink" title="6.5 get操作"></a>6.5 get操作</h4><p><strong>获取元素get操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// 一定要保证hash值所在的位置有元素</span></span><br><span class="line">    <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 检查头是否就是需要的</span></span><br><span class="line">        ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 树的话，从树中拿</span></span><br><span class="line">        <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 否则从链表中遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与HashTable比较：</strong></p>
<ul>
<li>HashTable使用synchronized关键字来实现同步，是线程安全的</li>
<li>HashMap可以插入键值对为null的数据Node</li>
<li>HashMap的迭代器是fail-fast</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的，即无序性</li>
</ul>
<p>上述的数据无序性需要声明一下，为什么是无序的，因为hashMap是利用散列函数来获取位置的，存取的时候就是散列，所以导致了它的无序性，由于HashSet底层也是HashMap实现的所以也是无序的。</p>
<h3 id="7-ConcurrentHashMap"><a href="#7-ConcurrentHashMap" class="headerlink" title="7. ConcurrentHashMap"></a>7. ConcurrentHashMap</h3><p>为解决HashMap的线程不安全以及HashTable的效率低问题，就有了我们的ConcurrentHashMap</p>
<p>在jdk1.7中利用的是Segment+链表实现，基于ReentrantLock锁来实现的。</p>
<p>存在的问题是链表查找的速度慢，且在jdk1.7中还是使用的头插法，但是在并发情况下似乎没啥影响，只是对于HashMap中并发操作会造成死循环操作。</p>
<p>jdk1.8的话，做的改进是抛弃了Segment，使用Node这种结构来代替了，从而使得并发的数量为Node个数，Node内部为链表或者红黑树结构。使用的是CAS+synchronized来实现的。大大提高了并发度。</p>
<p><strong>数据节点Node&lt;K,V&gt;：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V val; <span class="comment">// 注意这里用了volatile关键字修饰，也就是去主内存中获取值，而不是当前线程的工作内存</span></span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-put操作"><a href="#7-1-put操作" class="headerlink" title="7.1 put操作"></a>7.1 put操作</h4><p><strong>数据插入put操作：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">// 获取hash值</span></span><br><span class="line">  <span class="keyword">int</span> binCount = <span class="number">0</span>;<span class="comment">// 统计元素个数</span></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      tab = initTable(); <span class="comment">// 啥都没有，初始化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; <span class="comment">// 当前位置为空，直接通过cas填充</span></span><br><span class="line">      <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                   <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 如果是-1，帮助转移</span></span><br><span class="line">      tab = helpTransfer(tab, f);</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      V oldVal = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 否则就是需要和其他元素打交道了，此时需要加锁，否则会出问题</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 看是否大于0</span></span><br><span class="line">            binCount = <span class="number">1</span>; <span class="comment">// 置为1，统计数量从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">              K ek;<span class="comment">// 如果正好相等的话，直接覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key ||</span><br><span class="line">                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                oldVal = e.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  e.val = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="comment">// 不相等的话，继续往链表下面走，直到找到为止</span></span><br><span class="line">              Node&lt;K,V&gt; pred = e;</span><br><span class="line">              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                          value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">// 否则就是小于0，判断是否是树类型</span></span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;<span class="comment">// 数量定位2，放入</span></span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                  value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              oldVal = p.val;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">// 对数量进行界定，看是否满足8，树化</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">          treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addCount(<span class="number">1L</span>, binCount);<span class="comment">// 数量进行+1操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-get操作"><a href="#7-2-get操作" class="headerlink" title="7.2 get操作"></a>7.2 get操作</h4><p><strong>获取元素get操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">  <span class="keyword">int</span> h = spread(key.hashCode());<span class="comment">// 获取hash值</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果找到了当前Node&lt;K,V&gt;</span></span><br><span class="line">    <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">        <span class="keyword">return</span> e.val;<span class="comment">// 如果正好是当头元素，直接取出，返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 否则需要去树中找了</span></span><br><span class="line">      <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果上述两步操作都没有成功，证明是在链表非头结点出</span></span><br><span class="line">      <span class="keyword">if</span> (e.hash == h &amp;&amp;           <span class="comment">// 继续遍历操作，直到找到为止</span></span><br><span class="line">          ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 如果到最后还是没有找到，表明没有，返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-常见面试问题"><a href="#7-3-常见面试问题" class="headerlink" title="7.3 常见面试问题"></a>7.3 常见面试问题</h4><blockquote>
<p>1.谈谈你理解的 HashMap，讲讲其中的 get put 过程。</p>
</blockquote>
<p>HashMap的get过程比较简单，因为是使用Node&lt;K,V&gt;[]数组存储的，此时使用散列函数获取到hash值定位到当前元素的数组所在位置，判断是否是头结点，是的话直接返回，如果不是的话，判断是否是红黑树类型，是的话从红黑树中取值。否则就在链表中遍历取值。</p>
<p>put的过程，首先同上，也是需要获取到再数组中的位置，此时先判断当前位置上是否存在了元素，如果不存在的直接构建Node节点存放即可。存在的话，表示遭遇了哈希冲突，解决方法是用拉链法，此时就需要判断自己与头结点的key是否相同，想通过的话需要覆盖值，不相同的话，此时需要判断是否为树类型，通过树插入；否则又是链表了，此时通过遍历链表插入即可（注意判断节点个数，超过8需要树化）。</p>
<blockquote>
<p>2.jdk1.8做了哪些优化？</p>
</blockquote>
<p>jdk1.8的话首先在底层的结构上使用了数组+链表+红黑树实现，对于查找的效率提高了。其次对于并发时候jdk1.7的头插法插入容易使得产生死循环操作，在jdk1.8中使用尾插法，使用高低位判断的方法解决了这个问题。</p>
<blockquote>
<p>3.HashMap是否是线程安全的？</p>
</blockquote>
<p>不是线程安全的，jdk1.8的put操作如果是多个线程同时操作，没有办法保证获取到的值就是修改后的值，出现值覆盖，保证不了线程安全。jdk1.7的话就是头插法导致链表的死循环问题。</p>
<blockquote>
<p>4.线程安全的并发容器？</p>
</blockquote>
<p>HashTable，但是由于是统一synchronized修饰，并发度太低。一般使用ConcurrentHashMap来实现！</p>
<blockquote>
<p>5.ConcurrentHashMap是如何实现的？1.7和1.8有何区别？为什么这么做？</p>
</blockquote>
<p>首先ConcurrentHashMap的实现是因为HashMap的线程不安全，而HashTable的并发度又太小，才出现了ConcurrentHashMap，需要保证线程安全的话，有synchronized，ReentrantLock加锁操作实现，同时还有cas来保证线程安全问题。于是在jdk1.7中中使用了继承ReentrantLock的Segment来存放Node节点数据，使得并发度提升到了Segment数量的级别，每次锁的话都是锁当前定位到的Segment。具体的put操作的话，定位到segment，然后就是put的一系列操作。而jdk1.8话的话使用的是数组+链表+红黑树，存储的结构也变为了Node节点，每次锁都只锁一个Node，此时的并发度提升到了Node的数量个数。put’操作的话，定位Node位置，判断是否为空，是的话，利用cas方式填充节点，然后判断是否为-1，此时需要帮助其他线程转移。如果都不是，此时只能是树或者链表了，此时需要单独加锁保证线程安全。然后及时链表或者树的插入。结束返回被替换的节点，判断总数是否达到了树化的条件。最后数量+1，结束。</p>
<p>这么做的原因都是为了提升并发度。</p>
<h3 id="8-LinkedHashMap"><a href="#8-LinkedHashMap" class="headerlink" title="8. LinkedHashMap"></a>8. LinkedHashMap</h3><p>基于HashMap实现，但是在底层维护着双向链表以维持顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表的头</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">// 双向链表的尾</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">// 访问顺序，true:表示访问顺序;false:表示插入顺序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>LRU算法的原型：当访问了这个元素以后，需要将当前元素移动到链表的尾部，保证尾部元素是最新访问的元素，而链表的头部是最近最久未使用的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">  <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">// 是访问&amp;不是链表尾部元素</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="comment">// 定义p为e,b为p的前一个节点，a为p的后一个节点</span></span><br><span class="line">      (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.after = <span class="keyword">null</span>; <span class="comment">// 因为最后p必定成为最后一个元素，所以p.after=null</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="comment">// 如果b为null的话，表示前面没有元素，此时head=a</span></span><br><span class="line">      head = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果前面有元素的话，此时b的下一个节点指向a</span></span><br><span class="line">      b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) <span class="comment">// 如果p不是最后一个元素</span></span><br><span class="line">      a.before = b; <span class="comment">// 则将a与b连起来</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      last = b; <span class="comment">// 将last放到b处</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">// 如果last也为null的话，此时表明head就在p</span></span><br><span class="line">      head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      p.before = last; <span class="comment">// 如果last不为null的话此时p.before = last</span></span><br><span class="line">      last.after = p; <span class="comment">// last.after = p连接起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    tail = p; <span class="comment">// 把尾节点tail指向p</span></span><br><span class="line">    ++modCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果是插入的话：</strong><font color="red">注意：<code>removeEldestEntry</code>方法可以继承之后重写，改为true，实现热点数据问题。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; first; <span class="comment">// 默认removeEldestEntry是false，不移除元素</span></span><br><span class="line">  <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">    K key = first.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是这个方法可以用做固定大小的hashMap淘汰机制，重写，改为true即可，以此保证热点数据</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-WeakHashMap"><a href="#9-WeakHashMap" class="headerlink" title="9. WeakHashMap"></a>9. WeakHashMap</h3><p>可以看到WeakHashMap中的Entry继承了WeakReference，即弱引用，即下一次垃圾回收当前键值对就会被回收。</p>
<p>作用：主要用来实现缓存，通过使用WeakHashMap来引用缓存对象，由JVM对这部分缓存进行回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       V value;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Entry(Object key, V value,</span><br><span class="line">             ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">             <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(key, queue);</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">           <span class="keyword">this</span>.next  = next;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat中的ConcurrentHashMaps的longterm区使用的就是WeakHashMap，但是注意这里的话获取的话现在eden中找，找不到去longterm中找寻，随后放入eden中。</p>
<p>在放入数据的时候，这里需要注意，一旦eden中元素过多，此时采取的是将eden中所有的数据放入到longterm中等待回收，然后放入当前键值对。注意，这里对于缓存eden来说有个建立缓存的过程。</p>
<p>可以使用SoftReference来，SoftReference的话，表示软引用，与WeakReference之间的区别是它的回收不是下一次GC，而是内存空间不够的时候才会被回收（有更充足的时间来让其建立缓存，不至于GC就从longterm中消失），相比于WeakReference来说的话，是具有绝对的优势的，减少了简历缓存的时间和消耗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);<span class="comment">// 伊甸区不用担心被回收</span></span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);<span class="comment">// 只要垃圾回收就会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123; <span class="comment">// 如果eden中获取不到</span></span><br><span class="line">            <span class="keyword">synchronized</span> (longterm) &#123; <span class="comment">// 锁住，防止被回收</span></span><br><span class="line">                v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123; <span class="comment">// 获取到了的话，将其放入eden中，保证长期访问的对象不会被回收</span></span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;<span class="comment">// 如果eden中对象的个数超了</span></span><br><span class="line">            <span class="keyword">synchronized</span> (longterm) &#123; <span class="comment">// 此时将所有的eden中的对象放入到longterm，让其被回收一部分</span></span><br><span class="line">                <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();<span class="comment">// 清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);<span class="comment">// 放入当前的键值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h3><p>本次集合类复习，相比于前几次收获是大了不少，首先从整体来说，有List,Map,Set,Queue几种，代表的话ArrayList，LinkedList，HashMap，LinkHashMap，TreeMap，HashSet，LinkedHashSet，TreeSet，这里由于散列造就了Map和Set的无序性也是之前只知道无序而不知道原理的地方。随后就是并发操作的HashTable，由于并发太低，且所有方法都加锁资源消耗比较大，一般不用，一般使用ConcurrentHashMap，jdk1.7与jdk1.8之间的区别，底层实现的数据结构的区别，以及对于并发安全的list，Collections.synchronizedList可以实现并发线程安全，以及CopyOnWrite通过复制副本实现了并发安全，但是需要2倍的空间。最后就是LinkedHashMap中的LRU算法，面试也是经常考到，其中的移除元素操作，可以自定义实现热点数据。还有就是用作缓存的WeakHashMap其存活周期为下一次GC，适合用做缓存。</p>
<blockquote>
<p>Keep thinking，keep coding~继续加油</p>
<p>2020年04月14日22:48:54 写于北京市</p>
</blockquote>
]]></content>
      <categories>
        <category>秋招复习</category>
      </categories>
      <tags>
        <tag>Java集合类|秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>快手面试准备</title>
    <url>/2020/04/14/%E5%BF%AB%E6%89%8B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p><strong>1. zuul网关，如果zuul网关挂了nginx能知道吗？</strong></p>
<p>一般使用nginx+zuul来搭建实现高可用网关。所以如果是高可用的话，zuul挂了的话，nginx肯定是知道的。zuul的作用是实现转发和过滤来说使用的。可以做安全校验等一系列动作。以及路由转发。</p>
<p><strong>2. 配置zuul网关，如何配置</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">service-zuul</span></span><br><span class="line"><span class="comment">    # 服务器路由在这里起作用了，主要的作用就是转发请求，但是需要在zuul中配置好转发规则</span></span><br><span class="line"><span class="comment">    # 服务器路由不仅可以做转发的作用还可以起到过滤的作用，安全验证</span></span><br><span class="line"><span class="attr">zuul</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">routes</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">api-a</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">/api-a/*</span></span><br><span class="line">      <span class="attr">serviceId</span>: <span class="string">service-ribbon</span></span><br><span class="line">    <span class="meta">api-b</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">/api-b/*</span></span><br><span class="line">      <span class="attr">serviceId</span>: <span class="string">service-feign</span></span><br></pre></td></tr></table></figure>

<p><strong>3. JMM内存溢出的问题？</strong></p>
<p><strong>4. volatile的原理，如何防止指令重排，与synchronized的区别</strong></p>
<p>volatile的主要作用就是保证内存变量的可见性，已经防止指令重排。指令重排的实现是底层有内存屏障实现的。</p>
<p><strong>5. Spring的循环依赖问题怎么解决？使用三级缓存，三级缓存怎么实现的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** JNDI names of resources that are known to be shareable, i.e. can be cached */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; shareableResources = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of shareable singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of the types of nonshareable resources: bean name to bean type. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; resourceTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还是没有解决循环依赖的问题！</p>
</blockquote>
<p><strong>6. JDK动态代理为什么一定要实现接口？不实现接口会出现什么问题？</strong></p>
<p><strong>7. redis如何保持时效性？</strong></p>
<p><strong>8. 线程池原理？</strong></p>
<p><strong>9. 判断回文字符串</strong></p>
<p><strong>10. 给一个字符串，要求只能去掉一个字符，判断是否是字符串？</strong></p>
<p><strong>11. 垃圾收集算法</strong></p>
<ul>
<li>标记-清除</li>
<li>复制算法</li>
<li>标记-整理</li>
<li>分代收集</li>
</ul>
<p><strong>12. 常见的垃圾收集器</strong></p>
<ul>
<li>单线程的Serial收集器，单线程，可能造成stop the world</li>
<li>parallel收集器，Serial多线程版本</li>
<li>CMS（Concurrent Mark Sweep）收集并发收集器，主要是为了获取最短回收停顿时间，但是容易造成碎片（标记-清除算法），而且受计算机的核数限制，对计算机资源铭感，不能处理浮动垃圾。</li>
<li>G1垃圾回收器，面向服务器的垃圾回收器，具备并行与并发，分代收集，空间整合，可预测停顿。G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。</li>
</ul>
<p><strong>13. OS的逻辑地址</strong></p>
<p>OS的逻辑地址主要是为了用来映射物理地址的，逻辑地址=页号+页内地址，物理地址=块号+页内地址（一般指代页内偏移量）</p>
<p><strong>14. 实现LRU算法</strong></p>
<p>LRU算法，最近最少使用算法，使用Map和Node的数据结构来实现，维护一个first与last的Node类型指针。当获取元素的时候，此时利用key去map中找，map查找的时间复杂度为O(1)，此时如果为null，返回null，如果找到了，注意返回值的同时需要将当前节点通过first与last指针移动到顶端位置。添加元素的时候，此时需要判断当前map的size是否达到了最大的容量，如果是的话，需要删除最后一个节点，即last.key元素（判断last是否为null，不为null的话，此时将last指针前移，判断last是否为null，如果为null的话，表示first也为null，否则last.next为null）</p>
<p><strong>15. TCP/IP五层结构及其功能</strong></p>
<ul>
<li>物理层：主要负责透明的传输比特流</li>
<li>网络接口层：封装数据帧，在两个相邻结点之间的链路上“透明”的传输帧中的数据，交换机属于数据链路层，通过mac地址访问主机</li>
<li>网络层：主要负责分组交换网上的不同主机提供通信服务；路由寻址；IP协议</li>
<li>传输层：主要负责向两个主机中进程之间的通信提供服务。TCP/IP协议</li>
<li>应用层：为用户的应用进程提供服务</li>
</ul>
<p><strong>16. 链路层的差错检测方法</strong></p>
<ul>
<li>奇偶检验法</li>
<li>二维奇偶校验法</li>
<li>检查和法（一般用在传输层）</li>
<li>循环冗余校验（CRC）</li>
</ul>
<p>上述几种方法进行的差错校验都是为了让接收方可以很好的去判断传输的数据是否发生了错误。</p>
<p><strong>17. 网络层的路由选择算法？RIP，OSPF是什么？</strong></p>
<ul>
<li>RIP路由信息协议：基于距离向量的路由选择协议，主要是通过数跳数，每次更新路径短的。仅和相邻路由器交换信息。通过最少的路由器即为最好。<ul>
<li>工作过程：向周围路由发送请求报文，等待周围路由器响应，路由器收到响应后，修改本地路由，向周围路由广播路由修改信息。</li>
</ul>
</li>
<li>OSPF开放最短路径优先协议：使用分布式的基于链路状态的路由选择协议。向本自治系统所有路由器发送消息。利用洪泛法交换链路状态信息，范围局限在每一个区域而不是自治系统。</li>
</ul>
<p><strong>18. ARP协议</strong></p>
<ul>
<li>通过IP地址获取Mac地址的过程</li>
<li>广播发送当前ip地址的数据包，收到数据报的主机会返回给当前主机自己的MAC地址</li>
</ul>
<p><strong>19. Ping使用的协议ICMP，简述其过程</strong></p>
<p>假设A ping B</p>
<ul>
<li>PING通知系统建立一个固定格式的ICMP请求数据包</li>
<li>ICMP协议打包这个数据包和B的IP地址交给IP协议层</li>
<li>IP协议将B的地址作为目的地址，本机的IP地址作为源地址，加上一些必要控制信息，组成IP数据报</li>
<li>获取B的MAC地址</li>
<li>数据链路层构建数据帧，目的地址是IP层传过来的MAC地址，源地址是本地的IMAC地址。</li>
<li>机器B收到数据帧，检查目的地址，与本机MAC地址比对。符合接收。响应应答报文。如果不符合丢弃。</li>
</ul>
<p><strong>20. TCP流量控制，当接收方的接收窗口为0的时候措施</strong></p>
<p>发送方会一直发送探测信号，一把成倍形式上升，第一次探测是1秒，而后2 4 8 直到60后不会再增加，如果探测始终都没有ack返回，则断开连接。</p>
<p><strong>21. TCP的拥塞控制</strong></p>
<ul>
<li>快速重传机制：如果连续收到3此同一报文的响应即4个同样的ACK，则证明有报文丢失，立即重传。这种ack报文是指代的下一个片段是谁，因为有窗口段。第一个收到之后，ack会默认告知下一个片段是哪一个，如果当前片段丢失，会连续收到3个这样的确认报文，此时发送端立即重发。</li>
<li>慢开始算法，先1,2,4,8，如果到达门限，采用拥塞避免算法，每次加1，如果遇到拥塞控制，此时门限值为当前拥塞控制值的一半，此时从0开始慢开始。</li>
<li>快速恢复+拥塞避免；快速恢复只是说在遇到拥塞的时候，此时不是从0开始，而是从此时门限值开始拥塞避免算法。</li>
</ul>
<p><strong>22. 流量控制和拥塞控制有什么区别？</strong></p>
<ul>
<li>一个是一次的发送与接收的通信控制，一个是整个网络的通信控制</li>
<li>流量控制是端到端的过程，A给B发送数据，太快会导致B没有办法接受，这时候的控制就是流量控制，原理是通过滑动窗口的大小来改变实现。</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、路由器、以及降低网络性能有关的所有因素。</li>
</ul>
<p><strong>23. TCP的连接管理中可能出现哪些攻击漏洞？</strong></p>
<p><strong>24. HTTP状态码</strong></p>
<ul>
<li>1XX：表示已经收到，可以进行下一步（信息，服务器接收到请求，或者请求者继续执行操作）</li>
<li>2XX：表示已经成功（成功，操作被成功接收并处理）</li>
<li>3XX：表示需要跳转（重定向，需要进一步的操作以完成请求）</li>
<li>4XX：表示客户端有错误（客户端错误，请求包含语法错误或者无法请求错误）</li>
<li>5XX：表示服务器内部错误（服务器在处理请求过程中发生了错误）</li>
</ul>
<p><strong>25. GET和POST的区别</strong></p>
<ul>
<li>请求方式不同，参数不同，一个直接附带在url中一个隐藏在方法体中</li>
<li>GET请求有缓存，post没有</li>
<li>GET请求是幂等性的，post不是</li>
</ul>
<p><strong>26. 如果客户端禁用cookie，如何实现HTTP的状态管理</strong></p>
<p>使用url重写，对URL地址进行重写。对于sendRedirect方法后的URL地址进行重写；对于表单ation和超链接的url地址进行重写。</p>
<p><strong>27. 强平衡二叉树和若平衡二叉树</strong></p>
<ul>
<li>强：AVL树，是带有平衡添加的二叉查找树，一般使用平衡因子差值判断是否平衡并通过旋转来实现平衡。与红黑树相比，AVL树是严格的平衡二叉树，左右子树高度不能超过1。AVL树适合插入与删除次数较少，查找多的情况</li>
<li>弱：红黑树，对于搜索插入删除较多的情况，就是用红黑树。</li>
</ul>
<p><strong>28. 图的遍历算法（DFS，BFS），最小生成树算法，最短路径算法及简述其思想。</strong></p>
<p><strong>29. 常见的设计模式</strong></p>
<p>单例模式，代理模式，JDK动态代理，CGLIB动态代理，工厂模式。</p>
<p><strong>30. count(*)和count(1)的区别</strong></p>
<ul>
<li>count(*)表示忽略了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(1)表示忽略了所有的列，用1表示代码行，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列。统计结果会忽略劣质为NULL</li>
</ul>
<p><strong>31. NIO和IO的区别</strong></p>
<ul>
<li>IO是面向Stream流的，而NIO是面向Buffer的</li>
<li>IO是阻塞的，NIO是非阻塞的</li>
</ul>
<p><strong>32. Selector工作过程，为什么说他是非阻塞的？</strong></p>
<ul>
<li>select方法是阻塞的，但是注册的描述符不是阻塞的</li>
</ul>
<p><strong>33. epoll和poll的区别，各自的应用场景？</strong></p>
<p><strong>34. sleep和wait的区别</strong></p>
<ul>
<li>sleep不释放锁，而wait释放锁</li>
</ul>
<p><strong>35. newFixedThreadPool使用的阻塞队列是哪一个？</strong></p>
<ul>
<li>LinkedBlockedQueue</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试|快手</tag>
      </tags>
  </entry>
  <entry>
    <title>面试复盘记录</title>
    <url>/2020/03/28/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="1-2019-06-27-小宝科技"><a href="#1-2019-06-27-小宝科技" class="headerlink" title="1. 2019/06/27(小宝科技)"></a>1. 2019/06/27(小宝科技)</h2><p>SSM和SSH的区别？</p>
<p>深度优先和广度优先的区别？</p>
<p>二叉树一块的知识需要重点复习！</p>
<p>（红黑树，面试必备题目）</p>
<p>redis为什么拿来做缓存？内存数据库，内存持久化，速度快！</p>
<p>SpringMVC运行流程？</p>
<p>读写分离怎么做到的？意义是什么？</p>
<h2 id="2-2019-07-04-好享家"><a href="#2-2019-07-04-好享家" class="headerlink" title="2. 2019/07/04(好享家)"></a>2. 2019/07/04(好享家)</h2><p>1.自我介绍</p>
<p>2.秒杀项目如何实现的？</p>
<p>3.数据库如何保证安全，如果100个人同时访问，1000个，10000个呢，此时的数据库应做什么变化？应该是并发问题。</p>
<p>4.Spring如何管理对象的声明周期，对象的生命周期是什么样的？SpringBoot了解吗？</p>
<p>5.谈一谈IOC，有哪些方式来实现依赖注入？</p>
<p>6.JSP的九大内置对象谈一谈？</p>
<p>7.Request常用来干什么？</p>
<p>8.如何把数据传递给前端？</p>
<p>9.接口提高代码的重用性和性能是怎么实现的？原理是什么？</p>
<p>10.URL的Restful风格是什么意思，常用的方法，增删改查使用哪些？</p>
<p>11.JSTL说一下，List数据如何取出？（JSTL语法问题）</p>
<p>12.Servlet的生命周期？</p>
<p>13.Socket编程聊一下？常用的IO流聊一下，NIO聊一下，多个读写NIO是怎么保证数据的完整性？常用的流有哪些？如何分别读取这些流中的数据？</p>
<p>13.项目部署你用的是什么服务器？Tomcat的目录结构说一下？Server.xml在哪个目录下？</p>
<p>最近有了解什么新技术吗？</p>
<p>1.自我介绍</p>
<p>2.秒杀项目如何实现的？</p>
<p>3.数据库如何保证安全，如果100个人同时访问，1000个，10000个呢，此时的数据库应做什么变化？应该是并发问题。</p>
<p><strong>4.Spring如何管理对象的声明周期，对象的生命周期是什么样的？SpringBoot了解吗？</strong></p>
<p>Spring的对象生命周期依次为：</p>
<ul>
<li>对象的创建Construct</li>
<li>对象的初始化前BeforeInit</li>
<li>对象的创建以后PostConstruct</li>
<li>对象的初始化Init</li>
<li>对象的初始化后AfterInit</li>
<li>对象的销毁前PreDestrory</li>
<li>对象的销毁后Destroy</li>
</ul>
<p>单例对象：</p>
<ul>
<li>在容器启动的时候调用构造方法创建对象</li>
<li>在容器关闭的时候调用销毁方法销毁对象</li>
</ul>
<p>多例对象：</p>
<ul>
<li>每次调用的时候都会调用构造方法创建对象</li>
<li>容器不会管理这个bean；容器不会调用销毁方法</li>
</ul>
<p><strong>5.谈一谈IOC，有哪些方式来实现依赖注入？</strong></p>
<p>IOC（Inversion of Control）控制反转，控制的是对象的创建，反转的是对象创建过程，之前由程序员创建实例的过程交给了Spring容器负责。</p>
<p>依赖注入的话常用的有：Setter方式注入、构造方法注入、基于注解的注入。</p>
<p><strong>6.JSP的九大内置对象谈一谈？</strong></p>
<p>JSP九大内置对象包括：</p>
<table>
<thead>
<tr>
<th>内置对象名</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>HttpServletRequest</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
</tr>
<tr>
<td>page</td>
<td>Object(this)</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
</tr>
</tbody></table>
<p>四大作用域：</p>
<p>context、request、session、page</p>
<p><strong>7.Request常用来干什么？</strong></p>
<p>一般用来获取request.getSession()，request.getParameter()</p>
<p><strong>8.如何把数据传递给前端？</strong></p>
<p>在Controller层中使用Ｍodel.attribute(“data”,data)去添加数据进入，前端通过${data}取出来</p>
<p><strong>9.接口提高代码的重用性和性能是怎么实现的？原理是什么？</strong></p>
<p>提高代码重用性的方法：</p>
<ul>
<li>改写类的实例方法：并非首选，只是在类的方法中提供公共的可以访问的方法，里面的方法所使用的变量以及参数都必须调用全局性的，不能够非局部的变量。</li>
<li>选择最简单的参数接口类型：在接口中的定义的参数要尽可能的简单可以识别，也就是识别度高，可以提高代码的重用性。</li>
<li>把参数类型改成接口<ul>
<li>在面向对象编程中，代码重用真正的要点在于通过接口参数类型利用多态性，而不是通过类继承，我们通过对接口而不是对类编程达到代码重用的目的。如果某个方法的所有参数都是对一些已知接口的引用，那么这个方法就能够操作这样一些对象，当我们编写方法的代码时，这些对象的类甚至还不存在。从技术上说，可重用的是方法，而不是传递给方法的对象。</li>
</ul>
</li>
</ul>
<p><strong>10.URL的Restful风格是什么意思，常用的方法，增删改查使用哪些？</strong></p>
<p>查询操作-POST</p>
<p>添加/修改操作-POST</p>
<p>修改操作-PUT</p>
<p>删除操作-DELETE</p>
<p><strong>11.JSTL说一下，List数据如何取出？（JSTL语法问题）</strong></p>
<p>JSTL：JSP标准标签库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:foreach <span class="keyword">var</span>=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"5"</span>&gt;</span><br><span class="line">    Item&lt;c:out value=$&#123;var&#125;&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;/c:foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:foreach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">	$&#123;list&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure>

<p>基础迭代标签，支持多种集合类型</p>
<p><strong>12.Servlet的生命周期？</strong></p>
<ul>
<li>加载</li>
<li>创建</li>
<li>初始化</li>
<li>处理客户请求</li>
<li>卸载</li>
</ul>
<p><strong>13.Socket编程聊一下？常用的IO流聊一下，NIO聊一下，多个读写NIO是怎么保证数据的完整性？常用的流有哪些？如何分别读取这些流中的数据？</strong></p>
<p><strong>13.项目部署你用的是什么服务器？Tomcat的目录结构说一下？Server.xml在哪个目录下？</strong></p>
<p>Tomcat，</p>
<p>Tomcat目录结构如下：</p>
<ul>
<li>bin：主要是用来存放tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是.bat结尾（windows命令）</li>
<li>conf：conf目录主要用来存放tomcat的一些配置文件，<ul>
<li>server.xml可以设置端口号、设置域名或者IP、默认加载的项目、请求编码；</li>
<li>web.xml可以设置tomcat支持的文件类型</li>
<li>context.xml可以配置数据源之类的</li>
<li>tomcat-user可以用来配置管理tomcat的用户与权限</li>
<li>在Catalina目录下可以设置默认加载的项目</li>
</ul>
</li>
<li>lib：主要用于tomcat运行时需要加载的jar包</li>
<li>logs：主要用于存放tomcat在运行过程中产生的日志文件，非常重要的是在控制台输出的日志，清空不会对tomcat的运行产生影响<ul>
<li>windows环境下产生的日志文件输出catalina.xxxx-xx-xx.log文件中</li>
<li>linux环境下产生的日志文件在catalina.out文件中</li>
</ul>
</li>
<li>temp：存放tomcat运行过程中产生的临时文件</li>
<li>webapps：用来存放应用程序，当tomcat启动时会去加载webapps目录下的应用程序，可以以文件夹，war包，jar包的形式发布项目。</li>
<li>work：用来存放tomcat运行时编译好的文件，比如JSP编译后的文件，清空work目录，然后重启tomcat，可以达到清除缓存的作用。</li>
</ul>
<p>最近有了解什么新技术吗？</p>
<h2 id="3-2019-12-30（人人车面试"><a href="#3-2019-12-30（人人车面试" class="headerlink" title="3. 2019/12/30（人人车面试)"></a>3. 2019/12/30（人人车面试)</h2><p>首先自我介绍，然后开始了面试，问了实习经历主要是在公司负责做什么的，回答了在公司实习主要是帮助同事在版本迭代中处理一些小的模块功能，具体问是做什么的，自己也记不清了，自己只是记得自己做过一个标签模块。具体的产品设计也不记得，大致就是SpringBoot项目，自己回答了一下。</p>
<p>然后看见我有项目，就问了项目是用来干什么的，我回答，项目是用来作为当前市面上的秒杀系统设计的，面试官说给她说一下，顿时自己也是不知道从哪里开始，于是就blabla随便说了一些东西，问用到了什么技术的话，我说用到了mybatis、Spring、SpringMVC等技术，问我秒杀的时候数据库是怎么做的减库存，如何防止超卖现象发生？我说在MySQL语句中我有限定，对于减库存的话采用的是乐观锁机制，减库存的时候才去查询是否有库存，没有的话就不执行操作。面试官说这么多人的东西肯定会存在并发问题，你怎么解决这个并发问题呢？我说可以使用Redis做一个后端的缓存，他说做缓存是缓存什么？我说当时数据库中只存了几条记录，存的就是商品的信息，他说如果商品数很多的话呢，难道都要缓存进去吗？我说这个就看你调用的情况了，可以在redis中限制缓存的数量，也就是常说的保存热点数据问题，这样可以使用<strong>Redis内存淘汰机制</strong>，将访问少的缓存key给删除。她说你这个并发高的时候如果直接操作数据库的话，这个并发量数据库肯定承受不了，怎么解决，我说可以使用消息队列。面试官问：消息队列你了解多少。我说消息队列可以异步处理请求提高系统的性能，消息队列处理的速度比数据库要快，可以提升性能，而且对于并发的场景可以利用消息队列来削峰将并发的事务消息存储在消息队列中。后面blabla我也就记不清楚了。</p>
<p>于是来到了个人技能部分，首选是自己写的数据java基础和软件设计开发，于是她就问我<strong>多态</strong>是什么，我说多态是对于一个请求系统响应的多种状态，她说你给我举个例子，我哑口无言，心里想的是继承也是多态，但是没说，跟面试官说，暂时想不出。于是面试官问子类继承父类，父类怎么将部分方法限制不让子类重写。我说使用private修饰符，她说还有呢，我说将此方法设置为父类的静态方法。后面我写的是熟悉常用的数据结构和算法。于是她问我常用的数据结构有哪些，我说map、set、list、queue等，他问我list一般用哪些，我说使用ArrayList，她说ArrayList在某个地方插入一个数是怎么样的，我说这个性能损耗比较大，时间复杂度为O(n)，她说还有一种插入性能比较好的List，我说LinkedList，她说怎么实现的，我说底层基于链表实现的，维护一个后驱节点即可。在某个位置插入时间复杂度为O(1)。她说你知道队列吗，我说知道Queue，她说你说下，我说LinkedList一般用她来实现，先进先出。然后问我你说的Map可以说一下嘛，我说map底层基于数组和链表以及红黑树组成。她说你具体说下，我说我就说个map方法吧。首选判断给定的表是否为空，为空的话需要初始化表，如果不为空的话，通过hash值与长度的&amp;找到当前key存放的位置，然后判断当前槽位是否有对象，没有直接放入，有的话判断值是否相等，相等则覆盖，否则继续判断是否是红黑树类型，是的话通过红黑树的操作方式将节点插入，否则就是链表，通过链表的方式放入。她说你说链表，map中的链表是干嘛的。用来解决哈希冲突的，当出现哈希冲突的时候，使用链表存储hash值相同但值不同的元素。然后他问set呢，我说常用的是HashSet，底层是基于HashMap，后面没展开。于是她说HashMap是无序的，如果要有序呢，我说使用LinkedHashMap数据结构，她问他怎么保持有序，我说维护了一个前驱和后驱节点来实现的。他继续问set和list有什么区别，我说set不能存放相同的元素，list可以。</p>
<p>然后就问的简历上写的Spring、SpringMVC以及SpringBoot，她问SpringBoot说一下，我说SpringBoot是Spring和SpringMVC的整合体，一般和Mybatis搭配使用，Spring AOP说一下，我说这个是面向切面编程，可以通过AOP来切面加入一些通知或者日志记录，她说怎么实现，我说可以通过原生的Schema实现和AspectJ实现，她说注解，我说可以，她说怎么监控一个Controller，我说切点中写入Controller中的包名。她说方法呢，那就限定，她说<strong>如果要排除几个方法</strong>呢。我…….，她说过。。。于是问SpringBoot的配置文件在哪，resouces下面，一般开发有几个配置文件，我说3个，一个编码，一个测试，一个上线三个配置文件。SpringCloud了解吗，基本的组件说一下吧。SpringCloud基本组件Eureka服务的注册与发现，Ribbon负载均衡器，Feign微服务之间调用，Hystrix熔断器解决服务异常，线程资源占用问题。Zuul网关，可以用来做路由转发以及安全校验。Spring Cloud Config用来做微服务的管理配置。她说Zuul你用过吗，我说用过，怎么实现路由功能的，在配置文件中声明相应的微服务地址，设置规则拦截然后转发。你搭建过SpringCloud吗，搭建过。</p>
<p>你写了MySQL数据库，一般数据库你用什么数据库，我说Oracle学过，但是用的多的还是MySQL，她说MySQL有哪些数据类型。我说int bigint tinyint varchar,我说其他的就不太了解了，她说tinyint你也用过，我说是的，她说tinyint几个字节，1个，如果我要存100个数据，使用什么来存，我说int类型，她说这个当然可以，具体一些，我说int(3)限定3位。。。（<strong>其实可以使用smallint这种类型，这是她想要的答案</strong>），她说varchar，这个存字符，她说如果不要存那么多呢，我说varchar限定位数，她说这个可以，具体呢…..（<strong>有个类型为char</strong>），她说可以使用char，我说不太了解，回去学习一下。后面她说你开发应该会写mysql吧，我说会写，她说你建表会使用索引吗，我说会，她说为什么索引会快，我说将无序的数据变化了有序的数据，所以快，这个跟底层B+树的数据结构有关。她说你说下b+树的数据结构。我说B+树实现在MyISAM中实现是key+data，在InnoDB中是key，data都在叶子节点上。她问如何建立唯一索引，我说使用unique，后面她问了一个学生表，姓名不能重复，怎么设置索引。<strong>我以为他听到了我说的unique（当时说的是独特的键index）</strong>。。。。后面她说过。。。那种我不会的感觉。。。。。于是就问，如果我要是需要遍历数据填写在in()中使用什么，我说使用#{}或者${}她说有什么区别，我说前者不会预编译，后者会实现预编译。她说我要是list遍历，挨个放进in中，我说要使用到动态sql中的循环来遍历了。其中还问了sql中的right join与left join的区别。</p>
<p>后面就问的是java虚拟机一块，常见的对象死亡的判断？引用计数法和可达性分析算法。问可达性分析算法中的GCRoots哪些对象可以作为GCroots（<strong>没回答上来：1.虚拟机栈中引用对象 2. 方法区中类静态属性引用的变量 3. 方法区中常量引用的对象 4. 本地方法栈中JNI（即一般说的native方法）引用的对象</strong>），内存回收的基本算法，复制算法、标记清除算法、标记整理算法，分代收集算法。（<strong>问了一个问题，标记整理怎么实现的，标记整理如果空间满了怎么办？不是很懂。。。。</strong>）</p>
<p>现在也差不多了，时间都有些超时了，我这边面试就这样了，你有什么想问的问题吗？因为没准备充分，第一个问了个傻逼问题：如果有幸能够进入公司，会做哪些业务？。。。。。。第二个，对于我的面试，您觉得后续还应该做哪些调整，或者一些学习的建议。（主要建议还是架构一块的知识点，需要加强，因为前面架构的设计基本不会。说不通的感觉。感觉死的很惨。。）</p>
<p>以上就是整个人人车的面试！2019-12-30写于南京</p>
<h2 id="4-2020-01-02-（OPPO面试）"><a href="#4-2020-01-02-（OPPO面试）" class="headerlink" title="4. 2020/01/02 （OPPO面试）"></a>4. 2020/01/02 （OPPO面试）</h2><p>自我介绍：XXXX</p>
<p>开始谈java基础，首先是final关键字的用法，多种场景下的使用方法以及注意事项。然后关键字volatile关键字，volatile关键字主要是防止指令重排和保证变量的内存可见性。（这里面试官发现我还是很熟悉这些基础，还问我是不是看过什么。。。。。心醉），然后问equals与hashcode的区别，两者之间对等的关系，equals相等，hashcode必相等，hashcode相等，equals不一定相等。然后问常见的排序，问快排怎么实现的，快排的时间复杂度O(nlogn)，问最坏的情况是<font color="red">O(n^2)</font>，这个没有回答上来，然后面试官问，这个与冒泡排序和插入排序有什么区别，我说复杂度的区别，她说不是。（<font color="red">现在我知道了，当时没有想到是问这个区别，所以基本的排序算法复杂度需要自己分析一遍，把稳定与不稳定要了解一下。冒泡排序和插入排序是稳定的，快速排序不稳定。</font>) 问使用过哪些linux命令，cat vim ps -ef  grep find netstat (<font color="red">用于检验本机各端口的网络连接情况</font>)，find是干什么的，查找文件下所有的目录。后面问进程和线程知道吗？有什么区别？我说进程是包括一个或者多个线程的，进程之间各自拥有各自的内存资源，线程之间共享一份内存资源，进程切换比线程切换消耗大得多。面试官问我linux上的线程与java中的线程有什么区别？（这个我真不知道），最后问我协程知道是啥吗？我说不知道。</p>
<p><strong>线程和进程的区别？</strong></p>
<p>线程与进程类似，但是线程是比进程更小的单位，进程是最小的资源单位，线程是最小的执行单位。一个进程在执行过程之中可以产生多个线程，与进程不同的是同类的多个线程共享一块内存空间与一组系统资源，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，正因为如此，线程被称为轻量级进程。另外因为共享资源的原因，所以线程在执行时一般都要进行同步和互斥，总的来说，进程和线程的主要差别在于他们是不同的操作系统资源管理的方式。</p>
<p><strong>协程：</strong></p>
<p>协程是轻量级的线程。协程是个单线程，它的每次调用都是重入，调用完之后回到最开始的地方，然后再重入。协程不是被操作系统内核管理，而完全是由程序控制（也就是在用户态执行）。这样带来的最大的好处就是性能提到了很大的提升，不会像线程切换那样消耗资源。</p>
<h2 id="5-2020-01-07-（自如面试）"><a href="#5-2020-01-07-（自如面试）" class="headerlink" title="5. 2020/01/07 （自如面试）"></a>5. 2020/01/07 （自如面试）</h2><p>自我介绍：。。。。。。</p>
<p>java基础，八种基本的数据类型（<font color="red">没有回答上来！</font>,后面想起来了，byte,char,short,int,long,double,float,boolean），然后就问的一个字符串如何将一句话中的单词反转，我说用split分割空格，如果是每一个字符都反转呢，那就直接toCharArray，然后从后向前遍历即可。</p>
<p>ArrayList和LinkedList之间的区别，一个底层基于Object数组，一个底层基于链表实现，ArrayList具有随机访问的能力查找会比较快，但是插入在某一个特定的位置会比较慢，链表的话是查询比较慢，但是插入和删除比较快。</p>
<p>java并发包current有了解吗，我说了ConcurrentHashMap，并发下线程安全使用这个类。HashTable性能太糟糕，HashMap又是不安全的。</p>
<p>给你一个键值对数据，按照键排序，用什么数据结构，我说用HashMap，他说不对，有个更直接的，我说collection？他说treeMap你知道吧？我说知道，瞬间恍然大悟。然后面试官问，你知道TreeSet有什么缺点吗？（应该是只能存一个对象！他说的是treeSet），</p>
<p>SpringBoot中常用的注解：@RestController @Controller @Service @Mapper @Autowired @Resource @ResponseBody</p>
<p>@ResponseBody的作用是啥，<font color="red">没回答上来</font>（这个主要就是使用@ResponseBody返回的数据就是json格式的）<br>@RestController是哪些标签的组合@ResponseBody+@Controller</p>
<p><strong>@autowired 和 @resource的区别  以及@autowired的原理：</strong></p>
<p>@autowired是按照类型注入，@Resource是按照ByName注入，</p>
<ol>
<li>如果同时制定了name和type，则从Spring的上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>
<li>如果指定了name的话，则从上下文中查找名称id匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了type的话，则从上下文找到类似匹配的唯一bean进行装配你，找不到或是找到了多个的话，都会抛出异常。</li>
<li>如果既没有指定那么，又没有指定type的，则自动按照byName的方式进行装配，如果没有匹配，则回退给一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<p>Redis一般用来干什么，一般用来做后端缓存使用的，拿我做的那个秒杀系统来说的话，并发高的时候如果直接访问数据库，数据库的压力是很大的，可能会崩掉，可以将一部分数据放在redis缓存中，访问的时候现在redis数据库中查找，如果找到了就直接返回，如果没有找到，再去数据库中查找。（还有一种策略就是相应的数据库操作在redis中执行，然后通过同步的方式同步达到数据库中，这样会有数据不一致的情况发生，所以有同步的策略）。redis中一般存string对象还是hashmap，对象一般是存储HashMap对象，键值对的对象。</p>
<p>前端了解吗？Bootstrap？React或者Vue有了解吗？没有。</p>
<p>一道算法题。类似于跳台阶问题，1，2，…n步跳n阶梯台阶，问多少种跳法。（这里面试官的题目我也没听懂，我猜可能是跳台阶。。。当时给了个思路，但是没有直接写出来，后面详细问的时候，微信问的，面试官也没有说这件事情。）</p>
<p>自如的面试就这样了，但是他们的面试官希望我去北京再进行现场面试（因为面试之前的时候，电话沟通，他们就说最好现场面，说电话面试招收的人质量不高。）所以估计是不会去了。</p>
<h2 id="6-2020-01-08-滴滴面试—-一面"><a href="#6-2020-01-08-滴滴面试—-一面" class="headerlink" title="6. 2020/01/08 (滴滴面试—-一面)"></a>6. 2020/01/08 (滴滴面试—-一面)</h2><p>自我介绍：xxxxx</p>
<p>项目介绍，工作经历，然后就问的工作之中的项目，里面的一些点，包括其中的项目中出现了什么技术，用到了什么，然后就是其中的数据库啊，多少的用户，用户怎么来的，数据库连接mybatis用的什么插件，为什么用这个插件，这个插件相比于hibernate底层的封装。你遇到的最深刻的问题是什么？写了多少代码解决?然后就开始数据结构了，一个排序数组，查找最中间的数？二分法。第二个问题就是翻转部分的数，然后查找目标值的下标。第三个问题就是一串字符串算数表达式，你怎么把它们转换成真实的数学表达式，最后获得结果。后面两题都没回答出来。</p>
<h2 id="7-2020-01-13-（滴滴面试—-二面"><a href="#7-2020-01-13-（滴滴面试—-二面" class="headerlink" title="7. 2020/01/13 （滴滴面试—-二面)"></a>7. 2020/01/13 （滴滴面试—-二面)</h2><p>全程算法：</p>
<p>1.找出数组中出现一次的一个数 </p>
<p>2.找出数组中出现一次的两个数</p>
<p>3.旋转有序数组的中位数的下标</p>
<p>4.两个有序数组查找中位数（时间复杂度限定O(log(m+n)，不使用额外的内存空间）</p>
<p>5.完整的括号<code>{}[]()</code>如何实现</p>
<h2 id="8-2020-01-14-（阿里健康—-一面）"><a href="#8-2020-01-14-（阿里健康—-一面）" class="headerlink" title="8. 2020/01/14 （阿里健康—-一面）"></a>8. 2020/01/14 （阿里健康—-一面）</h2><p>晚上八点多突然接到电话，电话名字是广告传销，本来不打算接，看见是杭州的座机，心里还是有点担心是面试电话，就接了电话，得知是阿里健康部门打来的电话，然后就问是否现在有时间（之前看面经也是说阿里的面试从来都没有预约。。。），我说有，于是直接自我介绍。先问的我写的项目的秒杀系统，问项目的设计，大致的流程，问与平时的秒杀有哪些区别，我说并发上面输了。他问如何解决这个并发的问题，我说前端按钮置灰，服务器层使用消息队列异步处理，使用redis做缓存，数据库层使用mysql来实现。问我如果10w的请求量进来，你的系统会崩吗？我说应该会崩吧，他问如何解决，我说多加几台服务器，然后负载均衡。她说一台服务器能处理多少请求？我……不太了解。问java基础感觉怎么样，我说还行。问list和set的区别，list可以容纳重复的，set不能容纳重复的，list是有序的，set是无序的。于是问hashmap看过源码吧，我说看过，put的流程，哈希冲突怎么解决，链地址法。问hashmap是否是并发安全，否，那么用什么来代替，ConcurrentHashMap来代替。还有其他的吗？不知道。然后就问线层一块知道吧，线程的几个状态，new runnable running blocked terminated，什么时候会阻塞，我说sleep wait join，问synchronized会造成阻塞吗，会，如何解决？一个主线程，一个子线程，主线程需要确保子线程执行完毕才能执行，我说睡眠。。。能想到靠谱一点的不睡眠的方法吗？我说伴随线程？他问我信号量一类作用的你知道哪些，我说Semaphore,CountLatch,CyclicBarrier，写过例子吗，写过。线程池知道吗？知道，怎么实现的？ThreadPoolExecutor，自定义线程池，有哪几个参数？五个参数。如果我定义了一个10个核心线程的线程池，当第一个线程执行完毕任务后，第二个任务进来，线程池是怎么安排线程执行的？我说复用，她说你觉得会复用？我……..，然后问SQL了解多少，我说还行。。。表的连接有哪几种方法，inner join，left join, right join.left join 与right join的区别。问还有那种连接？如果两个5条数据的表，怎么合成一个具有十条数据的表？如果id age，中age有很多个年龄段的人，如何查找具体年龄段的人有多少，再筛选出20-30岁的呢？怎么操作？后面问最近有看什么技术书籍？我说JVM，计算机网络，架构有看一点点。她说JVM看了多少，我说70%…….于是问我如何自定义类加载器？类加载器怎么使用？类加载的几个步骤虚拟机都在干些什么？然后我就废了。（Class文件在方法区，方法区中有运行时常量池）。最后就是职业规划，我说先开发干几年，然后想往架构走。最后没了。</p>
<h2 id="9-2020-01-15-（滴滴—三面）"><a href="#9-2020-01-15-（滴滴—三面）" class="headerlink" title="9. 2020/01/15 （滴滴—三面）"></a>9. 2020/01/15 （滴滴—三面）</h2><p>今天主要是沟通了一下自己的项目问题，如何处理高并发，如果实在是高并发，怎么处理？对Id做区分，对Id求%操作，使得ID被打散在不同的机器上，然后问了对于高并发下出现的类似于淘宝中的你抢到了商品，但是付款却没有，退出然后再进入，却发现自己其实没抢到的错误是否有办法能够解决，实质是这种情况可以不用解决的，因为你再次下单的时候服务端发现这个库存为0，直接给你打回去了。问题不大，对于消费者来说问题不大不用解决。还有就是手机号去重的问题，大数据量去重，使用bitmap，bitmap的映射实现方式是什么，（这个需要了解一下）。然后问了一个1T的8为手机号数据，如何在只有64G的内存机器中查找出哪两个手机号重复，使用外存来协助，将1T分为16份。然后查找，使用桶的思想。然后取出每个桶中的数据进行排序。每次只取出一个桶的。最后问题也就问了这么多，就和面试官聊了一下实习生的培养机制，然后面试官说了内部可以转正，但是50%的概率会被淘汰，不能确保是否能转正。还聊了一下他所负责的部门，告诉我说在他手下实习就要把自己当做正式员工对待，会很累。后面也就这么多了，说道面试结果，他说还需要再部门内沟通一下，有必要的话会有加面，没有加面的话很很快给答复的。</p>
<h2 id="10-2020-03-28-美团一面"><a href="#10-2020-03-28-美团一面" class="headerlink" title="10. 2020/03/28 美团一面"></a>10. 2020/03/28 美团一面</h2><p>1.自我介绍</p>
<p>2.之前的实习是干啥的？说说?</p>
<p>3.看你笔试16分？（还是6分？？），我说做了两题莫名18%，27%，后面三题呢？我说直接略过。我俩相视一笑(手动捂脸笑哭)</p>
<p>4.介绍一下整体项目的结构，每一部分做了啥，是否上线。难点是什么，如何解决这些难点。</p>
<p>5.redis和数据库的数据不一致该如何解决？</p>
<p>6.对java哪一块的技术比较熟悉，或者深刻研究过。用的多的SpringBoot吧。说说SpringBoot的中的Bean的生命周期吧，说的细节一点，每一部分有哪些对应的操作，干了啥？</p>
<p>7.线程池参数说一下吧？具体是干啥的？默认的阻塞队列是哪个？核心线程数和最大线程数的区别？</p>
<p>8.核心线程数5，最大线程数10，此时7个任务，当前工作线程多少个？如果7个任务完了又来了10个任务呢，工作线程多少个？如果又来了20个线程呢，这个时候呢？(这里说了挺久，说你们看的博客都是面上的，离开了应用场景，你们就分析不到了。)</p>
<p>9.TCP的四次挥手？服务器在挥手的时候的三个状态是什么？四次挥手对吧，但是实际抓包三次挥手有时候就可以解决了，分析原因在哪？</p>
<p>10.算法题，求x的n次方根，结果至少2位小数。如何优化，二分法。二分法优化之后呢，还有什么优化？</p>
<p>11.有啥想问的吗？部门业务？评价和建议？</p>
<p>12.啥时候能来实习？实习多久？能转正可以一直实习，否则8-9我要跑路了。我问有hc吗，面试官说按照往年极个别优秀的可以转正的，hc今年的还没出来，往年都是个别</p>
<p>13.终，一面凉经，透心凉，心飞扬~</p>
<blockquote>
<p>Keep thinking，keep coding~ 荆棘满布的路，翻滚着走过。</p>
</blockquote>
<h2 id="11-腾讯IEG测开一面二面"><a href="#11-腾讯IEG测开一面二面" class="headerlink" title="11. 腾讯IEG测开一面二面"></a>11. 腾讯IEG测开一面二面</h2><p>投递的wxg测开，到现在还没有本wxg捞起来。之前面了pcg的开发，被二面无情挂了。</p>
<p>问题点基本都不难，基本都是基础的问题，一面有算法很简单，二面没有算法。具体问题不清楚，只知道大多问题不是很难。</p>
<p>IEG又给捞起来了。只不过这次运气不好，是测开。</p>
<p>一面：</p>
<p>1.自我介绍</p>
<p>2.做的项目</p>
<p>3.考察游戏相关，20亿数据排出前100的排名。如果分数相同可以重复排列，如何获取前100的完整名单。</p>
<p>3.考察了一个算法两数之和，leetcode写的</p>
<p>二面：</p>
<p>1.自我介绍</p>
<p>2.实习干了啥，做了啥，自己做了项目有没有上线，难点在哪，怎么解决，怎么优化？</p>
<p>3.redis知识点说了一下</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试项目准备</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h2 id="1-秒杀中如何解决商品超卖问题"><a href="#1-秒杀中如何解决商品超卖问题" class="headerlink" title="1. 秒杀中如何解决商品超卖问题"></a>1. 秒杀中如何解决商品超卖问题</h2><p>首先面对高并发问题，前端常用 扩容，静态化（CDN），限流来解决（采用Ip级别的限流，或者活动入口增加小游戏或者问题环节削峰处理）。</p>
<p>后端的话主要是减库存操作。多个用户同时操作MySQL数据库的话很容易导致出现负数的情况。</p>
<p>当减库存和高并发操作碰到一起，由于操作的库存数量是同一行，就会出现争抢InnoDB行级锁的问题，导致相互等待甚至死锁，从而大大降低了MySQL的处理性能，最终导致前端页面出现异常。</p>
<p>操作代码使用<code>update number set x = x-1 where (x-1) &gt; 0</code>，这种只能减少超卖的数量，不能完全避免超卖。</p>
<p>解决方案1：</p>
<p>将库存从MySQL迁移到redis中，将所有的写操作放在内存中，由于redis不存在锁所以不会出现互相等待，并且有redis的写性能和读性能远远高于MySQL，这就解决了高并发下的性能问题。然后通过队列一步手段，将变化的数据异步写入到DB中</p>
<p>优点：解决了性能问题</p>
<p>缺点：没有解决超卖的问题，同时由于异步写入DB，在某一时刻会导致Db和redis数据不一致的风险。</p>
<p>解决方案2：</p>
<p>引入队列，然后将所有Db操作在单队列中排队，完全串行处理。当达到库存阈值的时候就不存在消费队列，并关闭购买功能。这就解决了超卖问题。</p>
<p>优点：解决了超卖问题，略微提升性能。</p>
<p>缺点：性能受限队列处理性能和DB写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。</p>
<p>解决方案3:</p>
<p>将写操作迁移到Memcached中，同时利用Memcached的轻量级的锁机制CAS来实现减库存操作。</p>
<p>优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存操作。</p>
<p>缺点：没有实测。</p>
<p>解决方案4：</p>
<p>将提交操作成两段式操作，先申请后操作，然后利用redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阈值的号的人都可以成功提交订单。然后数据异步写入DB</p>
<p>优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。</p>
<p>缺点：由于异步写入DB，可能造成数据不一致问题出现，另外可能存在少买。也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单并没有达到库存阈值。</p>
<h2 id="2-优化方案"><a href="#2-优化方案" class="headerlink" title="2. 优化方案"></a>2. 优化方案</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><strong>方向：将请求尽量拦截在系统上游，进来的时候使用Nginx负载均衡，对于承受不住的直接返回，不进行处理。</strong></p>
<p><strong>限流和削峰</strong></p>
<p>限流，屏蔽掉无用的流量，前端要做按键置灰操作，一个用户不能多次请求。</p>
<p>削峰，瞬间大流量的话容易压垮系统，此时可以采用异步处理，缓存和消息中间件。异步处理感觉挺难实现，一般使用缓存和消息中间件。秒杀本身是读多写少。因为是秒杀，实际操作减库存的人不多。</p>
<p>消息队列可以实现削峰，将拦截大量的并发请求，是异步处理的，先进入消息队列，后台从消息队列中主动拉取处理。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端的话首先需要做页面静态化，页面存在html，动态数据是接口从服务器中获取，实现前后端分离。静态页面只有第一次请求的时候加载。</p>
<p>或者使用CDN缓存静态资源，加载快。</p>
<p>利用缓存，使用令牌桶算法实现限流。（桶里发令牌，如果没有令牌，拒绝执行任务。直接打回去）</p>
<p>秒杀业务放在高配服务器上，采用消息队列缓存请求，利用缓存应对读请求，利用缓存应对写请求（redis的写操作）</p>
<p><strong>方案</strong></p>
<p>秒杀阶段的时候使用本地标记对用户秒杀过的商品做标记，若被标记过直接返回重复秒杀，未被标记查询redis，通过本地标记减少对redis的访问</p>
<p>抢购开始，将商品和库存数据同步到redis中，所有的抢购操作都在redis中进行处理，通过redis预减少库存，减少对数据库的访问。</p>
<p>为了保护系统不受高流量的冲击而导致系统崩溃，使用MQ消息队列进行异步处理下单，实际做了一层缓冲保护层。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题</title>
    <url>/2020/03/22/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring之Bean的生命周期学习</title>
    <url>/2020/03/22/Spring%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p><strong>Bean创建===&gt;初始化===&gt;销毁</strong></p>
<h2 id="1-Bean指定初始化和销毁方法"><a href="#1-Bean指定初始化和销毁方法" class="headerlink" title="1. @Bean指定初始化和销毁方法"></a>1. @Bean指定初始化和销毁方法</h2><p>构造(对象创建)：</p>
<ul>
<li>单实例：在容器启动的时候创建对象</li>
<li>多实例：在每次获取的时候创建对象</li>
</ul>
<p>初始化：</p>
<ul>
<li>对象创建完成，并赋值好，调用初始化方法</li>
</ul>
<p>销毁：</p>
<ul>
<li>单实例：容器关闭的时候销毁</li>
<li>多实例：容器不会管理这个bean，容器不会调用销毁方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Bean的含义就是意味着当前的方法可以生产一个被Spring容器管理的实例对象</span></span><br><span class="line">    <span class="comment">// @Scope("prototype") 多实例</span></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建IOC容器</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"容器创建完成!"</span>);</span><br><span class="line">        <span class="comment">// 多实例的时候只有使用的时候才会加载</span></span><br><span class="line">        <span class="comment">// applicationContext.getBean("car");</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Bean使用InitializingBean和DisposableBean"><a href="#2-Bean使用InitializingBean和DisposableBean" class="headerlink" title="2. @Bean使用InitializingBean和DisposableBean"></a>2. @Bean使用InitializingBean和DisposableBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat destroy...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用@Component标签的话，需要使用@ComponentScan标签来将此类注入。</p>
<h2 id="2-PostConstruct和-PreDestory"><a href="#2-PostConstruct和-PreDestory" class="headerlink" title="2. @PostConstruct和@PreDestory"></a>2. @PostConstruct和@PreDestory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog constructor...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象创建并赋值之后使用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog...@PostConstruct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除之后给的反馈信号</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog...@PreDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4. @BeanPostProcessor"></a>4. @BeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postProcessBeforeInitialization()  <span class="comment">// 在初始化调用之前</span></span><br><span class="line">postProcessAfterInitialization()   <span class="comment">// 在初始化调用之后</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBeforeInitialization...."</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfterInitialization...."</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个方法是在类的初始化前后进行作用。</p>
<h2 id="5-BeanPostProcessor原理"><a href="#5-BeanPostProcessor原理" class="headerlink" title="5. BeanPostProcessor原理"></a>5. BeanPostProcessor原理</h2><p>源码断点Debug</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 给Bean属性赋值</span></span><br><span class="line">initializeBean(beanName, exposedObject, mbd); <span class="comment">// 初始化Bean</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// Bean初始化之前调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// 执行自定义初始化</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// Bean初始化之后调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Spring底层对BeanPostProcessor的使用"><a href="#6-Spring底层对BeanPostProcessor的使用" class="headerlink" title="6. Spring底层对BeanPostProcessor的使用"></a>6. Spring底层对BeanPostProcessor的使用</h2><p>Bean赋值，属性注入，@AutoWired注解，生命周期注解功能，@Async，xxx，都是由BeanPostProcessor来完成的。</p>
<h2 id="7-Spring的IOC源码"><a href="#7-Spring的IOC源码" class="headerlink" title="7. Spring的IOC源码"></a>7. Spring的IOC源码</h2><p>首先如果基于xml配置文件的话需要使用如下获取Application方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext1 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"xxx.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>如果是基于<code>@Configuration</code>配置的话，可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>此时进入到内部方法，此时可以看见<code>refresh()</code>方法，整个Bean的实例化的过程都在这里了。</p>
<h3 id="7-1-refresh"><a href="#7-1-refresh" class="headerlink" title="7.1 refresh()"></a>7.1 refresh()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 准备刷新</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告知子类刷新内部的实例化bean工厂</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备在当前的上下文中使用的BeanFactory</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 允许后置处理，在beanFactory的上下文中</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用工厂处理器在上下文中注册为实例</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册拦截Bean创建的处理器</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 初始化当前的messageSource</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 注册事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 初始化一些特定的bean实例</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册时间监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 实例化非懒加载的所有的单例类</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 最后一步，发布相应的事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-prepareRefresh"><a href="#7-2-prepareRefresh" class="headerlink" title="7.2 prepareRefresh()"></a>7.2 prepareRefresh()</h3><p><strong>创建Bean容器前的准备工作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    <span class="comment">// 初始化所有放置的属性资源</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties 检验xml文件</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-常见Bean容器，加载注册Bean，获取BeanDefinition"><a href="#7-3-常见Bean容器，加载注册Bean，获取BeanDefinition" class="headerlink" title="7.3 常见Bean容器，加载注册Bean，获取BeanDefinition"></a>7.3 常见Bean容器，加载注册Bean，获取BeanDefinition</h3><p><strong>创建Bean容器，并加载注册Bean</strong></p>
<p><code>obtainFreshBeanFactory()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    refreshBeanFactory();<span class="comment">// 刷新bean，见下</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line">-- refreshBeanFactory()</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();<span class="comment">// 之前有的话就销毁</span></span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 创建beanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory); <span class="comment">// 自定义BeanFacotry</span></span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 很重要下面详细介绍</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">== customizeBeanFactory(beanFactory) </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置是否能被覆写，bean名称相同的时候操作</span></span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;<span class="comment">// 是否允许循环依赖（面试题！Spring循环依赖怎么解决？）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red">最重要的方法loadBeanDefinitions(beanFactory);</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);<span class="comment">// 解析beanfactory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">== loadBeanDefinitions(beanDefinitionReader)</span><br><span class="line"><span class="comment">// 主要就是从xmlBeanDefinitioniReader加载Bean的definitions</span></span><br><span class="line"><span class="comment">// 里面的操作有很多，有把xml加载成一颗DOM树，从其中读数据。树中的数据主要是读取&lt;/bean&gt;等一系列标签中的数据，如果要跟的话，进入到loadBeanDefintions方法即可。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有个很重要的类BeanDefinition</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">	String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getInitMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getDestroyMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRole</span><span class="params">(<span class="keyword">int</span> role)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ResolvableType <span class="title">getResolvableType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Bean的容器已经初始化了，主要的操作都是在loadBeanDefintions中实现的。<code>&lt;bean&gt;</code>标签都转换为BeanDefinition了，然后注册到了BeanDefinition注册中心。</p>
<h3 id="7-4-prepareBeanFacotry准备Bean容器"><a href="#7-4-prepareBeanFacotry准备Bean容器" class="headerlink" title="7.4 prepareBeanFacotry准备Bean容器"></a>7.4 prepareBeanFacotry准备Bean容器</h3><p><strong>Bean容器实例化之后，准备Bean容器prepareBeanFactory(beanFactory);</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());<span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks. 添加后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean. 为特殊的bean赋值</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">	<span class="comment">// 这个处理器负责回调。</span></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 注册默认的bean容器</span></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-完成Bean实例的初始化finishBeanFactoryInitialization"><a href="#7-5-完成Bean实例的初始化finishBeanFactoryInitialization" class="headerlink" title="7.5 完成Bean实例的初始化finishBeanFactoryInitialization()"></a>7.5 完成Bean实例的初始化finishBeanFactoryInitialization()</h3><p><strong>初始化所有的SingleTon的beans</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">		<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">		<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">		<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 冻结当前的配置，初始化不希望其他的发生变化</span></span><br><span class="line">		<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line">		<span class="comment">// 实例化所有的单实例非懒加载bean</span></span><br><span class="line">		<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">== preInstantiateSingletons()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 非抽象的懒加载且是单实例的进行加载</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                    getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 普通的bean直接获取即可</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="comment">// 所有单实例的bean已经初始化完毕进行回调</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getBean(beanName)</strong></p>
<p>准备创建bean，对于SingleTon的bean来说，容器中没创建过，对于prototype的bean来说，本来就需要创建新的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// doGetBean是校验相应的条件，然后获取Bean，创建bean，然后执行createBean()方法</span></span><br><span class="line"><span class="comment">// createBean方法执行由doCreatebean实现。</span></span><br><span class="line"><span class="comment">// doCreateBean中方法的话有两个比较重要的</span></span><br><span class="line"><span class="comment">// 一个是poplulateBean()主要是对bean中的属性进行赋值操作，因为之前进行了初始化操作，但是没有进行赋值操纵。</span></span><br><span class="line"><span class="comment">// 另外一个就是initilizeBean方法，执行各种回调。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// </span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行成功，Bean创建成功。</p>
<h3 id="7-6-小结"><a href="#7-6-小结" class="headerlink" title="7.6 小结"></a>7.6 小结</h3><p>Spring IOC的过程也就是控制反转的过程，实质就是Bean的创建过程，Bean的创建过程有依据xml创建的，有依据注解创建的。</p>
<p>主要的实现方法都是配置完之后获取到ApplicationContext的时候的refresh()方法来实现的。</p>
<p>refresh方法：</p>
<p>prepareRefresh方法，用以对相应启动的设置校验xml文件参数的合法性。</p>
<p>obtainRefreshBeanFactory方法，首先需要将之前存在的BeanFactory给销毁，然后创建BeanFactory，其中包含了对BeanFactory的相关定制（设置相应的参数）操作，以及给当前的BeanFactory加载相应的Bean的定义loadBeanDefinition()方法。加载完这些定义之后所有的Bean的相关信息都被加载如BeanDefinition中了（就是加载XML中的数据，主要是解析那些标签的数据，最后将数据装入到BeanDefinition中），到了这一步就完成了Bean容器的初始化操作，所有的<code>&lt;bean&gt;</code>配置都转换为一个个BeanDefinition了。</p>
<p>注册完上面的内容之后，Spring会手动注册看起来比较智能的Bean，此时prepareBeanFactory()就是用来配置工厂的标准环境特征的，如上下文的类加载器和后置处理器。</p>
<p>然后就到了最后的最重要的环节完成Bean工厂的初始化工作。finishBeanFactoryInitializatioin()方法，这里会负责初始化所有的SingleTon beans，主要实现是通过<code>preInsantiateSingletons()</code>来实现的，主要是<code>getBean()</code>，执行<code>doGetBean</code>操作，然后就是对bean实例的创建，<code>createBean()</code>方法就可以实现对Bean的创建，由<code>doCreateBean()</code>来实现创建(<font color="red">注意循环依赖的解决发生在这</font>)，然后由<code>populateBean</code>给初始化的bean属性赋值操作，最后初始化bean，使用<code>initializeBean()</code>方法，初始化的时候需要调用相关方法，我们定义的一些初始方法就在这被调用。所有的定义的前置后置处理器的回调也是发生在调用初始化方法前后。</p>
<p>以上就是Spring IOC Bean的初始化过程。</p>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>面试相关技巧掌握学习</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="1-面试的三层架构"><a href="#1-面试的三层架构" class="headerlink" title="1. 面试的三层架构"></a>1. 面试的三层架构</h2><ul>
<li>首轮：面试技术基本功</li>
<li>次轮：架构设计，通过技术解决某些场景下的问题</li>
<li>末轮：稳定性以及未来规划，压工资（可能会）</li>
</ul>
<h2 id="2-备战心仪公司"><a href="#2-备战心仪公司" class="headerlink" title="2. 备战心仪公司"></a>2. 备战心仪公司</h2><ul>
<li><p>认真研究职位要求，提炼出特别需要准备的知识点</p>
</li>
<li><p>主要是针对岗位JD的描述提炼出知识点</p>
</li>
<li><p>通过内部人士打听团队所做的项目的信息，重点备战这些知识点</p>
</li>
</ul>
<h2 id="3-面试中项目介绍如何表达比较好"><a href="#3-面试中项目介绍如何表达比较好" class="headerlink" title="3. 面试中项目介绍如何表达比较好"></a>3. 面试中项目介绍如何表达比较好</h2><p><strong><font color="red">属于面试中的重点，前几天的面试，感觉自己项目介绍的不太好，面试官感觉不是太好，有减分。</font></strong></p>
<ul>
<li>站在码农的角度介绍项目，专注技术指标以及解决思路</li>
<li>自信，脉路要清晰：项目用途-&gt;自己的角色-&gt;如何解决难题</li>
<li>项目如果找不到难点，则谈谈改进，前提是熟悉相关设计的知识点</li>
<li>事前用图形将你的项目勾画清楚(细节不是很重要，但是自己需要掌握，表达出大致模块即可，问到再说细节)</li>
</ul>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>准备面试的过程中，技巧也是很重要的一个部分，虽然能力重要，但是展示出你的能力更加重要，有很多时候面试感觉很糟不是因为我们能力不够，而是因为我们能够展现出来的能力没有机会展示出来，最后面试结果不理想。</p>
<p>面试之前的准备，有技巧的准备很重要，基础知识、算法、项目三大主力面试集需要重点抓牢。</p>
<blockquote>
<p>Keep thinking，Keep coding！加油~</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见SQL语句</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95SQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1-SQL基本语法"><a href="#1-SQL基本语法" class="headerlink" title="1. SQL基本语法"></a>1. SQL基本语法</h2><p><strong>关键语法：</strong></p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT，SUM，MAX，MIN，AVG</li>
</ul>
<p><strong>GROUP BY</strong></p>
<ul>
<li>满足“SELECT子句中的列名必须为分组列或列函数”</li>
<li>列函数对于group by子句定义的每个组各返回一个结果</li>
</ul>
<p><strong>HAVING</strong></p>
<ul>
<li>通常与GROUP BY子句一起使用</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一SQL中的顺序：where&gt;group by&gt;having</li>
<li>如果SQL语句中group by，可以使用having代替where</li>
</ul>
<h2 id="2-SQL语句练习"><a href="#2-SQL语句练习" class="headerlink" title="2. SQL语句练习"></a>2. SQL语句练习</h2><p>三张表</p>
<p><code>student</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`student`</span>(</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="string">'0'</span>,</span><br><span class="line">primary <span class="keyword">key</span> (<span class="string">`student_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">10</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><code>course</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`score`</span>(</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><code>score</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`course`</span>(</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="string">`course_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">5</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>插入的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'zs'</span>,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'ls'</span>,<span class="number">23</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'ww'</span>,<span class="number">26</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span></span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"语文"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"数学"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"英语"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score <span class="keyword">values</span></span><br><span class="line">(<span class="number">10</span>,<span class="number">5</span>,<span class="number">70</span>),(<span class="number">10</span>,<span class="number">6</span>,<span class="number">50</span>),(<span class="number">10</span>,<span class="number">7</span>,<span class="number">56</span>),(<span class="number">10</span>,<span class="number">8</span>,<span class="number">80</span>),(<span class="number">11</span>,<span class="number">5</span>,<span class="number">50</span>),(<span class="number">11</span>,<span class="number">6</span>,<span class="number">60</span>),(<span class="number">11</span>,<span class="number">7</span>,<span class="number">61</span>),(<span class="number">12</span>,<span class="number">6</span>,<span class="number">30</span>),(<span class="number">12</span>,<span class="number">7</span>,<span class="number">55</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-面试常见问题"><a href="#3-面试常见问题" class="headerlink" title="3. 面试常见问题"></a>3. 面试常见问题</h2><h3 id="3-1-查询所有同学的学号、选课数、总成绩"><a href="#3-1-查询所有同学的学号、选课数、总成绩" class="headerlink" title="3.1 查询所有同学的学号、选课数、总成绩"></a>3.1 查询所有同学的学号、选课数、总成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：当前的sql语句需要实现的是查询所有同学的信息，所以需要以同学为分组。其次选课数，COUNT函数，总成绩SUM函数。</p>
<p>GROUP BY的话相当于以当前分组的对象为一个A，一个学生id会对应着多门课程，如果以学生为分组的话，此时所使用的函数会将分组中的多门课程进行一个类似于聚合的操作。</p>
</blockquote>
<h3 id="3-2-查询所有同学的学号、姓名、选课数、总成绩"><a href="#3-2-查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="3.2 查询所有同学的学号、姓名、选课数、总成绩"></a>3.2 查询所有同学的学号、姓名、选课数、总成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.student_id,stu.name,<span class="keyword">count</span>(s.course_id),<span class="keyword">sum</span>(s.score)</span><br><span class="line"><span class="keyword">from</span> student stu,score s</span><br><span class="line"><span class="keyword">where</span> stu.student_id = s.student_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.student_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：因为姓名这个属性在score这张表中没有，所以此时需要使用联合student这张表，通过id作为一个联合的中间节点查询到</p>
</blockquote>
<h3 id="3-3-查询平均成绩大于60分的同学的学号和平均成绩"><a href="#3-3-查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="3.3 查询平均成绩大于60分的同学的学号和平均成绩"></a>3.3 查询平均成绩大于60分的同学的学号和平均成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id, <span class="keyword">avg</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(score) &gt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 附加一点，HAVING可以代理where关键字，前提是没有使用group by</span></span><br><span class="line"><span class="comment">-- 获取id为10的学生的所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">having</span> student_id = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：同样还是id为分组，此时多出了成绩大于60这个条件，HAVING是用来过滤分组的，所以此时需要使用到HAVING这个关键字来过滤查询到的结果</p>
</blockquote>
<h3 id="3-4-查询没有学全所有课的同学的学号、姓名"><a href="#3-4-查询没有学全所有课的同学的学号、姓名" class="headerlink" title="3.4 查询没有学全所有课的同学的学号、姓名"></a>3.4 查询没有学全所有课的同学的学号、姓名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.student_id, stu.name</span><br><span class="line"><span class="keyword">from</span> student stu, score s</span><br><span class="line"><span class="keyword">where</span> stu.student_id = s.student_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.student_id</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line"><span class="keyword">count</span>(*) &lt; (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：学全所有课只需要看当前学生的课程id是否小于course中的总课程即可。姓名的话依旧是根据两表联查。</p>
</blockquote>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>SQL语句的话一般是问上述的相关问题，但不一定是保证问这些，尽量多练习，可以保证在面试中对于SQL语句的考察一次性通过。</p>
<blockquote>
<p>Keep thinking，keep coding！</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习(未完待续)</title>
    <url>/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统学习"><a href="#操作系统学习" class="headerlink" title="操作系统学习"></a>操作系统学习</h1><h1 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h1><h2 id="1-分页和分段有什么区别？"><a href="#1-分页和分段有什么区别？" class="headerlink" title="1. 分页和分段有什么区别？"></a>1. 分页和分段有什么区别？</h2><h3 id="1-1-页式存储"><a href="#1-1-页式存储" class="headerlink" title="1.1 页式存储"></a>1.1 页式存储</h3><p>用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配内存时以页为单位，按照进程需要的页数分配，逻辑上相邻的页，物理上不一定相邻。原因是逻辑上是连续的，而物理上不一定是连续的。(物理内存被分为大小相等的帧)</p>
<p>页帧：把物理地址空间划分为大小相同的基本分配单位。大小为2的n次方。</p>
<p>页面：把逻辑地址空间划分为相同大小的基本分配单位。</p>
<p>页：进程逻辑地址空间被划分成大小相等的页。</p>
<p>页面到页帧：逻辑地址到物理地址的转换。</p>
<p><strong>页式存储中的地址映射</strong></p>
<ul>
<li>页到帧的映射（逻辑地址到物理地址的映射）</li>
<li>逻辑地址中的页号是连续的</li>
<li>物理地址中的页号是不连续的</li>
<li>不是所有的页都有页帧（缺页的情况，后面会介绍，虚拟内存技术）</li>
</ul>
<p><font color="red">页表page table</font>保存了逻辑地址-物理地址之间的映射关系。</p>
<p><strong>页式存储管理机制的性能问题</strong></p>
<ul>
<li><p>内存访问性能问题</p>
<ul>
<li>访问一个内存单元需要2次内存访问</li>
<li>第一次访问：获取页表项</li>
<li>第二次访问：访问数据</li>
</ul>
</li>
<li><p>页表大小问题</p>
<ul>
<li>页表可能非常大</li>
</ul>
</li>
</ul>
<p>处理办法：缓存？间接访问？</p>
<ul>
<li>块表（Translation Look-aside Buffer，TLB）<ul>
<li>缓存近期访问的页表项目</li>
</ul>
</li>
<li>多级页表<ul>
<li>通过间接引用将页号分为k级</li>
<li>建立页表“树”</li>
<li>减少每级页表的长度</li>
</ul>
</li>
</ul>
<h3 id="1-2-段式存储"><a href="#1-2-段式存储" class="headerlink" title="1.2 段式存储"></a>1.2 段式存储</h3><p>用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态的划分成长度不同的区域，分配时以段位单位，每段在内存中占据连续空间，各段可以不相邻。</p>
<h3 id="1-3-段页式存储"><a href="#1-3-段页式存储" class="headerlink" title="1.3 段页式存储"></a>1.3 段页式存储</h3><p>用户进程先按照段划分，段内按照页划分，内存划分和分配按照页</p>
<p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。</p>
<p>在段式存储管理基础上，给每个段加一级页表。通过指向相同的页表基址，实现进程间的段共享</p>
<h3 id="1-4-区别"><a href="#1-4-区别" class="headerlink" title="1.4 区别"></a>1.4 区别</h3><ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定</li>
<li>地址空间维度不同：分段是二维空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多个页表，通过一个逻辑地址就能找到对应的物理地址）</li>
<li>分段便于信息的保护和共享；分页的共享受到限制</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（页没有填满）</li>
</ul>
<h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2. 虚拟内存"></a>2. 虚拟内存</h2><h3 id="2-0-虚拟内存的目标"><a href="#2-0-虚拟内存的目标" class="headerlink" title="2.0 虚拟内存的目标"></a>2.0 虚拟内存的目标</h3><ul>
<li>只把部分程序放到内存中，从而运行比物理内存大的程序<ul>
<li>由操作系统自动完成，无需程序员的干涉</li>
</ul>
</li>
<li>实现进程在内存和外存之间的交换，从而获得更多的空间内存空间<ul>
<li>在内存和外存之间只交换进程的部分内容</li>
</ul>
</li>
</ul>
<h3 id="2-1-局部性原理"><a href="#2-1-局部性原理" class="headerlink" title="2.1 局部性原理"></a>2.1 局部性原理</h3><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一个区域</p>
<ul>
<li>时间上：最近被访问的页在不就的将来还会被访问</li>
<li>空间上：内存中被访问的页周围的页在不就的将来也可能被访问</li>
<li>分支局部性：一条跳转指令的两次执行，很可能跳到相同的内存地址</li>
</ul>
<p><strong><font color="red">局部性原理的意义：从理论上来说，虚拟内存技术是能够实现的，且能够取得满意的效果。</font></strong></p>
<h3 id="2-2-虚拟内存的基本概念"><a href="#2-2-虚拟内存的基本概念" class="headerlink" title="2.2 虚拟内存的基本概念"></a>2.2 虚拟内存的基本概念</h3><ul>
<li>思路：将不常用的部分内存块暂存到外存</li>
<li>原理：<ul>
<li>装载程序时：只将当前指令执行需要的部分页面或段装入内存</li>
<li>指令执行中需要的指令或数据不存在内存（缺页或者缺段）时：处理器将通知操作系统将相应的页面或段调入页面</li>
<li>操作系统将内存中暂时不用的页面或段保存到外存</li>
</ul>
</li>
<li>实现方式：<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
</li>
</ul>
<p><strong><font color="red">物理内存+磁盘=虚拟内存</font></strong></p>
<p><strong>虚拟内存的支持技术</strong></p>
<ul>
<li>硬件：页式或段式存储中的地址转换机制</li>
<li>操作系统：管理内存和外存间页面或段的换入换出</li>
</ul>
<h3 id="2-3-虚拟页式存储管理"><a href="#2-3-虚拟页式存储管理" class="headerlink" title="2.3 虚拟页式存储管理"></a>2.3 虚拟页式存储管理</h3><p>在页式存储管理的基础上，增加请求调页和页面置换</p>
<p>思路：</p>
<ul>
<li>当用户程序要装载到内存中运行的时候，只装入部分页面，就启动程序运行</li>
<li>进程在运行中发现有需要的代码或者数据不存在时，则向系统发出缺页异常请求（可以从用户态切换到内核态进行 ）</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li>
</ul>
<h3 id="2-4-什么是虚拟内存"><a href="#2-4-什么是虚拟内存" class="headerlink" title="2.4 什么是虚拟内存"></a>2.4 什么是虚拟内存</h3><p>每个程序都拥有自己的地址空间，这些地址空间被分成大小相等的页，这些页被映射为物理内存；但不需要所有的页都在物理内存当中，当程序引用到不再物理内存当中的页的时候，由操作系统将确实的页装入物理内存。这样对程序来说似乎有很大的内存空间，但实际上有一部分存储在磁盘上，所以被称为虚拟内存。</p>
<h3 id="2-5-如何进行地址空间到物理内存的映射？"><a href="#2-5-如何进行地址空间到物理内存的映射？" class="headerlink" title="2.5 如何进行地址空间到物理内存的映射？"></a>2.5 如何进行地址空间到物理内存的映射？</h3><p>通过MMU内存管理单元来实现，MMU管理着逻辑地址和物理地址的转换，其中的页表(page table)存储页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含有效位（在内存or磁盘）、访问位（是否被访问过）、修改位（是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
<h3 id="2-6-页面置换算法"><a href="#2-6-页面置换算法" class="headerlink" title="2.6 页面置换算法"></a>2.6 页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不再内存中，就会发生缺页中断从而将该页调入到内存中。此时如果内存无空间空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要的目标是是页面置换频率最低（即缺页率最低，也就是因缺页导致的中断次数最少）</p>
<ul>
<li><strong>最佳页面置换算法OPT</strong>（Optimal Replacement Algorithm）：置换以后不需要或这最远的将来才需要的页面，是一种理论上的算法，是最优策略</li>
<li><strong>先进先出FIFO</strong>：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面置换出，从而使缺页率提高。（主要是因为FIFO不具备删选的能力）</li>
<li><strong>最近最少使用算法</strong>（LRU Least Recently Used）：置换出未使用时间最长的页面；实现方式：维护一个栈帧或者维护一个所有页面的链表，当一个页面被访问时，将这个页面移动到链表表头。这样就能够保证链表表尾是最近最久未访问的元素。</li>
<li><strong>时钟算法Clock</strong>：SCR需要将页面在链表中移动，时钟算法使用环形链表来实现，在使用一个指针指向最老的页面，避免移动页面的开销。访问之后变为1，找到为0的替换，如果遇到的为1，变为0，下一轮遇到为0的则替换。<ul>
<li><strong>原理</strong><ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面（读/写）时，访问位置置为1</li>
<li>缺页时：从指针当前位置顺序检查环形链表，访问位为0，则置换该页。访问位为1的话，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面位置。</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二次机会算法SCR</strong>：改进的clock算法，这种是在clock算法的基础上，增加了一位修改位。按照FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置为0。相比时钟算法多了一位。1 0表示可写 ，第二位表示访问位，如果访问为1，给二次机会，并将访问置为0</li>
<li><strong>最近未使用算法LFU</strong>：缺页时置换访问次数最少的页面。实现：每个页面设置一个访问技计数，访问页面时，访问计数+1，缺页时，置换计数最小的页面。</li>
</ul>
<h3 id="2-7-Belady现象"><a href="#2-7-Belady现象" class="headerlink" title="2.7 Belady现象"></a>2.7 Belady现象</h3><p>采用FIFO算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象。</p>
<p><strong>产生的原因：</strong></p>
<ul>
<li>FIFO的置换特征与进程访问内存的动态特征矛盾</li>
<li>被它置换出去的页面并不一定是近期不会访问的（注意FIFO）</li>
</ul>
<p><strong>为什么LRU算法没有此现象？FIFO有？</strong></p>
<p>因为FIFO是先进先出，不记录置换的页面是否近期被访问过。而LRU算法是将最近最久没有使用的页面置换出去，所以不会出现Belady现象。</p>
<h3 id="2-8-抖动问题"><a href="#2-8-抖动问题" class="headerlink" title="2.8 抖动问题"></a>2.8 抖动问题</h3><p><strong>抖动</strong>：</p>
<ul>
<li>进程物理页面太小，不能包含工作集</li>
<li>造成大量缺页，频繁置换</li>
<li>进程运行速度变慢</li>
</ul>
<p><strong>产生抖动原因：</strong></p>
<ul>
<li>随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升</li>
</ul>
<p><strong>解决：</strong></p>
<ul>
<li>操作系统需要在并发水平和缺页率之间达到一个平衡</li>
<li>选择一个适当的进程数目和进程需要的物理页面数</li>
</ul>
<h2 id="3-用户态和内核态"><a href="#3-用户态和内核态" class="headerlink" title="3. 用户态和内核态"></a>3. 用户态和内核态</h2><p>为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，CPU划分了用户态和内核态两个权限等级</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他资源获取</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换</li>
</ul>
<p>所有的用户程序工作在用户态，但有时需要一些内核态操作，比如从硬盘或者磁盘读数据，这时就需要进行系统调用使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h3 id="3-1-为什么要区分用户态和内核态？"><a href="#3-1-为什么要区分用户态和内核态？" class="headerlink" title="3.1 为什么要区分用户态和内核态？"></a>3.1 为什么要区分用户态和内核态？</h3><ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源</li>
<li>封装性：用户程序不需要实现更加底层的代码</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要调度；统一交给操作系统会更加方便</li>
</ul>
<h3 id="3-2-如何从用户态切换到内核态？"><a href="#3-2-如何从用户态切换到内核态？" class="headerlink" title="3.2 如何从用户态切换到内核态？"></a>3.2 如何从用户态切换到内核态？</h3><ul>
<li>系统调用：比如读取命令行输入。本质上是通过中断实现的。<font color="red">系统调用指代的是系统函数调用。</font>这是发生在用户态主动请求切换到内核态的过程中的。</li>
<li>用户程序发生异常：比如发生缺页异常。会触发当前运行的进程切换到处理此内核异常的内核相关程序中，即切换到内核态。</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会先CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</li>
</ul>
<h2 id="4-进程"><a href="#4-进程" class="headerlink" title="4. 进程"></a>4. 进程</h2><p>进程：指一个具有一定的<font color="red">独立功能</font>的程序在一个<font color="red">数据集合</font>上的一次<font color="red">动态执行过程。</font></p>
<h3 id="4-1-进程的组成及特点"><a href="#4-1-进程的组成及特点" class="headerlink" title="4.1 进程的组成及特点"></a>4.1 进程的组成及特点</h3><p>进程包含了正在运行的一个程序的<strong>所有状态</strong>信息</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器</li>
<li>通用寄存器</li>
<li>进程占用系统资源：打开文件、已分配内存….</li>
</ul>
<p>进程的特点：</p>
<ul>
<li>动态性：动态的创建、结束进程</li>
<li>并发性：进程可以被独立调度并占用处理机运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据/资源或进程间同步而产生制约</li>
</ul>
<h3 id="4-2-进程与程序的联系及区别"><a href="#4-2-进程与程序的联系及区别" class="headerlink" title="4.2 进程与程序的联系及区别"></a>4.2 进程与程序的联系及区别</h3><p><strong>进程与程序的联系：</strong></p>
<ul>
<li>进程是操作系统中处于执行状态程序的抽象<ul>
<li>程序=文件</li>
<li>进程=执行中的程序=程序+执行状态</li>
</ul>
</li>
<li>同一个程序的多次执行过程对应为不同进程<ul>
<li>命令<code>ls</code>多次执行对应多个进程</li>
</ul>
</li>
<li>进程执行需要的资源<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
</li>
</ul>
<p><strong>进程和程序的区别：</strong></p>
<ul>
<li>进程是动态的，程序是静态的<ul>
<li>程序是有序序代码的集合</li>
<li>进程是程序的执行，进程有核心态/用户态</li>
</ul>
</li>
<li>进程是暂时的，程序是永久恶<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可以长久保存</li>
</ul>
</li>
<li>进程与程序的组成不同<ul>
<li>进程包括程序、数据和进程控制块（PCB）；而程序只包含有序代码</li>
</ul>
</li>
</ul>
<h3 id="4-3-进程控制块"><a href="#4-3-进程控制块" class="headerlink" title="4.3 进程控制块"></a>4.3 进程控制块</h3><p>进程控制块（PCB Process Control Block）：操作系统管理控制进程运行所用的信息集合。</p>
<ul>
<li>操作系统使用PCB来描述进程的基本情况以及运行变化的过程</li>
<li>PCB是进程存在的唯一标识<ul>
<li>每个进程在操作系统中都有一个对应的PCB</li>
</ul>
</li>
</ul>
<p><strong>进程控制块的作用</strong></p>
<ul>
<li>进程创建：生成该进程的PCB</li>
<li>进程终止：回收它的PCB</li>
<li>进程的组织管理：通过对PCB的组织管理来实现</li>
</ul>
<p><strong>进程控制块的组成：</strong></p>
<ul>
<li>进程标识信息</li>
<li>处理机保护现场</li>
<li>进程控制信息</li>
</ul>
<p><strong>进程控制信息：</strong></p>
<ul>
<li>调度和状态信息：<ul>
<li>调度进程和处理机使用情况</li>
</ul>
</li>
<li>进程间通信信息<ul>
<li>进程间通信相关的各种标识</li>
</ul>
</li>
<li>存储管理信息<ul>
<li>指向进程映像存储空间数据结构</li>
</ul>
</li>
<li>进程所用资源<ul>
<li>进程使用的系统资源，如打开文件等</li>
</ul>
</li>
<li>有关数据结构连接信息<ul>
<li>与PCB相关的进程队列</li>
</ul>
</li>
</ul>
<p><strong>进程控制块的组织</strong></p>
<ul>
<li>链表<ul>
<li>同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li>
</ul>
</li>
<li>索引表<ul>
<li>同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表</li>
</ul>
</li>
</ul>
<h3 id="4-4-进程的生命周期"><a href="#4-4-进程的生命周期" class="headerlink" title="4.4 进程的生命周期"></a>4.4 进程的生命周期</h3><p>进程的生命周期可以分为：</p>
<ul>
<li>进程创建</li>
<li>进程执行</li>
<li>进程等待</li>
<li>进程抢占</li>
<li>进程唤醒</li>
<li>进程结束</li>
</ul>
<p><strong>进程创建，如何会引起进程创建？</strong></p>
<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新的进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
<p><strong>进程执行</strong></p>
<ul>
<li>内核选择一个就绪的进程，让它占用处理机并执行</li>
<li>如何选择？相应的调度算法会解决这个问题</li>
</ul>
<p><strong>进程等待：进程进入等待（阻塞）的状态</strong></p>
<p>进入阻塞的情况发生场景：</p>
<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据还没有到达</li>
</ul>
<p><font color="red">注意，只有进程自身才能知道何时需要等待某种时间的发生</font></p>
<p><strong>进程抢占</strong></p>
<ul>
<li>高优先级进程就绪</li>
<li>进程当前执行时间用完</li>
</ul>
<p><strong>进程唤醒</strong></p>
<ul>
<li>被阻塞的进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
</ul>
<p><font color="red">注意：进程只能被操作系统或者其他进程唤醒</font></p>
<p><strong>进程结束</strong></p>
<ul>
<li>正常退出（自愿的）</li>
<li>错误退出（自愿的）</li>
<li>致命错误（强制性的）</li>
<li>被其他进程所杀（强制性的）</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583218452994.png" alt="1583218452994"></p>
<h3 id="4-5-进程挂起"><a href="#4-5-进程挂起" class="headerlink" title="4.5 进程挂起"></a>4.5 进程挂起</h3><p>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存。</p>
<p><strong>等待到等待挂起</strong></p>
<ul>
<li>没有进程处于就绪状态或就绪进程要求更多内存资源</li>
</ul>
<p><strong>就绪到就绪挂起</strong></p>
<ul>
<li>当有高优先级等待（系统会认为很快就绪的）进程和低优先级就绪进程</li>
</ul>
<p><strong>运行到就绪挂起</strong></p>
<ul>
<li>对抢先式分时系统当有高优先级等待挂起进程因时间而进入就绪挂起</li>
</ul>
<p><strong>在外存时的状态转换</strong></p>
<ul>
<li>等待挂起到就绪挂起<ul>
<li>当有等待挂起进程因相关时间出现</li>
</ul>
</li>
</ul>
<p><strong>激活Active</strong></p>
<ul>
<li>把一个进程从外存转到内存</li>
<li>就绪挂起到就绪：没有就绪进程或者挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并由高优先级等待挂起进程</li>
</ul>
<h2 id="5-线程"><a href="#5-线程" class="headerlink" title="5. 线程"></a>5. 线程</h2><p>在进程内部增加一类实体，满足以下特性：</p>
<ul>
<li>实体之间可以并发执行</li>
<li>实体之间共享相同的地址空间</li>
</ul>
<p>这种实体就是线程</p>
<h3 id="5-1-线程的概念"><a href="#5-1-线程的概念" class="headerlink" title="5.1 线程的概念"></a>5.1 线程的概念</h3><p>线程是进程的一部分，描述指令执行状态。它是进程中执行指令流的最小单元，是CPU<font  color="red">调度</font>的基本单位。</p>
<ul>
<li>进程的资源分配角色：进程由一组相关资源构成，包括地址空间（代码段、数据段等）、打开文件等各种资源。</li>
<li>线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态</li>
</ul>
<p><strong>线程=进程-共享资源</strong></p>
<p><strong>线程的优点：</strong></p>
<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
<p><strong>线程的缺点：</strong></p>
<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
<h3 id="5-2-线程和进程的区别"><a href="#5-2-线程和进程的区别" class="headerlink" title="5.2 线程和进程的区别"></a><font color="red">5.2 线程和进程的区别</font></h3><ul>
<li>进程是资源的分配单位，线程是CPU的调度单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可以不通过内核直接进行通信（进程的读取资源是需要进入内核的。）</li>
</ul>
</li>
</ul>
<h3 id="5-3-线程的三种实现方式"><a href="#5-3-线程的三种实现方式" class="headerlink" title="5.3 线程的三种实现方式"></a>5.3 线程的三种实现方式</h3><p><strong>用户线程：在用户空间中实现</strong></p>
<p>由一组用户级的线程库函数来完成线程的管理。包括线程的创建、终止、调度和同步等</p>
<h4 id="5-3-1-用户线程"><a href="#5-3-1-用户线程" class="headerlink" title="5.3.1 用户线程"></a>5.3.1 用户线程</h4><p><strong>用户线程的特征：</strong></p>
<ul>
<li>不依赖于操作系统的内核<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
</li>
<li>在用户空间实现的线程机制<ul>
<li>每个进程有私有的线程控制块（TCB）列表</li>
<li><font color="red">TCB由线程库函数维护</font></li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快<ul>
<li>无需用户态/内核态切换</li>
</ul>
</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
<p><strong>用户线程的不足</strong></p>
<ul>
<li>线程发起系统调用而阻塞时，则整个进程进入等待（IDEA跑程序多线程死锁之后的等待）</li>
<li>不支持基于线程的处理机抢占<ul>
<li>除非当前运行线程主动放弃，否则它所在的进程的其他线程无法抢占CPU</li>
</ul>
</li>
<li>只能按进程分配CPU时间<ul>
<li>多个线程的进程中，每个线程的时间片较少</li>
</ul>
</li>
</ul>
<h4 id="5-3-2-内核线程"><a href="#5-3-2-内核线程" class="headerlink" title="5.3.2 内核线程"></a>5.3.2 内核线程</h4><p><strong>内核线程：在内核中实现</strong></p>
<p>由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</p>
<p><strong>内核线程的特征</strong></p>
<ul>
<li>由内核维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止、切换开销相对较大<ul>
<li>通过系统调用/内核函数，在内核中实现</li>
</ul>
</li>
<li>以线程为单位进行CPU时间分配<ul>
<li>多线程的进程可获得更多CPU时间</li>
</ul>
</li>
</ul>
<h4 id="5-3-3-轻权进程（Light-Weight-Process）"><a href="#5-3-3-轻权进程（Light-Weight-Process）" class="headerlink" title="5.3.3 轻权进程（Light Weight Process）"></a>5.3.3 轻权进程（Light Weight Process）</h4><p><strong>轻量级线程：在内核中实现，支持用户线程</strong></p>
<p>内核支持的用户线程。一个进程可以拥有一个或者多个轻量级线程，每个轻权进程由一个单独的内核线程来支持。</p>
<p><strong>用户线程和内核线程的对应关系</strong></p>
<ul>
<li>一对一</li>
<li>多对一</li>
<li>多对多</li>
</ul>
<h2 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6. 进程控制"></a>6. 进程控制</h2><h3 id="6-1-进程切换"><a href="#6-1-进程切换" class="headerlink" title="6.1 进程切换"></a>6.1 进程切换</h3><p><strong>进程切换</strong></p>
<ul>
<li>暂停当前运行进程，从运行状态变成其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
<p><strong>进程切换要求</strong></p>
<ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
<p><strong>进程生命周期信息</strong></p>
<ul>
<li>寄存器（PC、SP）</li>
<li>CPU状态</li>
<li>内存地址空间</li>
</ul>
<p><strong>进程控制块PCB：内核的进程状态记录</strong></p>
<ul>
<li>内核为每个进程维护了对应的进程控制块PCB</li>
<li>内核将相同状态的进程的PCB放置再同一队列</li>
</ul>
<h3 id="6-2-进程的创建"><a href="#6-2-进程的创建" class="headerlink" title="6.2 进程的创建"></a>6.2 进程的创建</h3><p><strong>Windows创建进程API：CreateProcess(fileName)</strong></p>
<p><strong>Unix创建进程：fork/exec</strong></p>
<ul>
<li>fork()将一个进程复制为两个进程</li>
<li>exec()用新程序来重写当前进程，PID没有改变</li>
<li>fork()创建一个继承子进程<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有CPU寄存器（一个例外）</li>
</ul>
</li>
<li>fork()的返回值<ul>
<li>子进程的fork()返回0</li>
<li>父进程的fork()返回子进程标识符</li>
<li>fork()返回值可方便后续使用，子进程可使用getpid()获取PID</li>
</ul>
</li>
</ul>
<p><strong>fork()的开销</strong></p>
<ul>
<li>由于再fork过程中涉及到大量的数据复制，内存分配，开销昂贵</li>
<li>在99%的情况下，调用了fork之后需要调用exec</li>
</ul>
<p><strong>vfork()</strong></p>
<ul>
<li>创建进程时，不再创建一个同样的内存映像</li>
<li>轻量级fork()</li>
<li>子进程应该几乎立即调用exec</li>
<li>现在使用Copy On Write技术（高并发）</li>
</ul>
<h3 id="6-3-进程加载及进程的等待与退出"><a href="#6-3-进程加载及进程的等待与退出" class="headerlink" title="6.3 进程加载及进程的等待与退出"></a>6.3 进程加载及进程的等待与退出</h3><p>程序加载和执行系统调用exec()</p>
<p><strong>父进程等待子进程</strong></p>
<ul>
<li>wait()系统调用用于父进程等待子进程的结束<ul>
<li>子进程结束时通过exit()向父进程返回一个值</li>
<li>父进程通过wait()接受并处理返回值</li>
</ul>
</li>
<li>wait()系统调用的功能<ul>
<li>有子进程存活时，父进程进入等待状态，等待子进程的返回结果（<font color="blue">当某子进程调用exit时，唤醒父进程，将exit()返回值作为父进程中wait的返回值</font>）</li>
<li>有僵尸子进程等待时，wait()立即返回其中一个值</li>
<li>无子进程存活时，wait()立即返回</li>
</ul>
</li>
</ul>
<p><strong>进程的有序终止exit()</strong></p>
<ul>
<li>进程结束执行时调用exit()，完成进程资源回收</li>
<li>exit()系统调用的功能<ul>
<li>将调用参数作为进程的结果</li>
<li>关闭所有打开的文件等占用的资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查是否父进程是存活着的<ul>
<li>如果存活，保留结果的值直到父进程需要它，进入僵尸状态</li>
<li>如果没有，释放所有的数据结构，进程结果</li>
</ul>
</li>
<li>清理等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集（资源回收）</li>
</ul>
<p><font color="orange">僵尸进程：一个子进程结束后，她的父进程并没有得等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被摧毁。它已经放弃了几乎所有的内存空间，没有任何可以执行的代码，也不能够被调度，仅仅是再进程表中保留一个位置，记录着该进程的id，终止状态以及资源利用信息（CPU时间、内存使用量等），供父进程收集，除此之外，僵尸进程不再占有任何内存空间，这个僵尸进程可能会一直保留在系统中直到系统重启。</font></p>
<p><font color="red">僵尸进程危害：占用进程号，系统的进程号是有限的；占用内存</font></p>
<h2 id="7-处理机调度"><a href="#7-处理机调度" class="headerlink" title="7. 处理机调度"></a>7. 处理机调度</h2><p><strong>CPU资源的时分复用</strong></p>
<ul>
<li>进程切换：CPU资源的当前占用者切换<ul>
<li>保存当前进程在PCB中的知行上下文（CPU状态）</li>
<li>恢复下一个进程的知执行上下文</li>
</ul>
</li>
<li>处理机调度<ul>
<li>从就绪队列中挑选下一个占用CPU运行的进程</li>
<li>从多个可用CPU中挑选就绪进程可使用的CPU资源</li>
</ul>
</li>
<li>调度程序：挑选就绪进程的内核函数</li>
</ul>
<h3 id="7-1-调度时机"><a href="#7-1-调度时机" class="headerlink" title="7.1 调度时机"></a>7.1 调度时机</h3><ul>
<li>内核运行调度程序的条件<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
</li>
<li><strong>非抢占系统</strong><ul>
<li>当前进程主动放弃CPU时间片</li>
</ul>
</li>
<li><strong>可抢占系统</strong><ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程时间片用完</li>
<li>进程从等待切换到就绪</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>处理机资源的使用模式</strong></p>
<ul>
<li>进程在CPU计算和I/O操作间交替<ul>
<li>每次调度决定再下一个CPU计算时将哪个工作交给CPU</li>
<li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li>
</ul>
</li>
</ul>
<h3 id="7-2-比较调度算法的原则"><a href="#7-2-比较调度算法的原则" class="headerlink" title="7.2 比较调度算法的原则"></a>7.2 比较调度算法的原则</h3><ul>
<li>CPU使用率<ul>
<li>CPU处于忙状态的时间百分比</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间内完成的进程数量</li>
</ul>
</li>
<li>周转时间<ul>
<li>进程从初始化到结束（包括等待）的总时间</li>
</ul>
</li>
<li>就绪等待时间<ul>
<li>进程在就绪队列中的总时间</li>
</ul>
</li>
<li>响应时间<ul>
<li>从提交请求到产生响应所花费的总时间</li>
</ul>
</li>
</ul>
<p><strong>吞吐量与延迟</strong></p>
<ul>
<li>调度算法的要求：希望获取“更快”的服务</li>
<li>更快的含义<ul>
<li>传输文件时的高带宽，调度算法的高吞吐量</li>
<li>玩游戏时的低延迟，调度算法的低相应延迟</li>
</ul>
</li>
</ul>
<p><strong>处理机调度策略的响应时间目标</strong></p>
<ul>
<li>减少响应时间（响应时间是操作系统的计算延迟）</li>
<li>减少平均响应时间的波动</li>
</ul>
<p><strong>处理机调度策略的吞吐量目标</strong></p>
<ul>
<li>增加吞吐量（吞吐量是操作系统的计算带宽）<ul>
<li>减少开销（操作系统开销、上下文切换）</li>
<li>系统资源的高效利用（CPU、I/O设备）</li>
</ul>
</li>
<li>减少等待时间<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
<li>操作系统需要保证吞吐量不受用户交互的影响<ul>
<li>操作系统必须不停的进行调度，即使存在许多交互任务。</li>
</ul>
</li>
</ul>
<p><strong>处理机调度的公平性目标</strong></p>
<ul>
<li>公平的定义<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>保证每个进程的等待时间相同</li>
</ul>
</li>
<li>公平通常会增加平均响应时间</li>
</ul>
<h3 id="7-3-调度算法"><a href="#7-3-调度算法" class="headerlink" title="7.3 调度算法"></a>7.3 调度算法</h3><p><strong>先来先服务算法（First Come  First Served，FCFS）</strong></p>
<ul>
<li>依据进程进入就绪状态的先后顺序排列<ul>
<li>进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>平均等待时间波动较大<ul>
<li>短进程可能排在长进程后面</li>
</ul>
</li>
<li>I/O资源和CPU资源的利用率较低<ul>
<li>CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也会等待</li>
</ul>
</li>
</ul>
<p><strong>短进程优先算法（Shortest Process Next）</strong></p>
<ul>
<li>选择执行队列中执行时间最短进程占用CPU进入运行状态<ul>
<li>就绪队列按预期的执行时间来排序</li>
</ul>
</li>
<li><font color="red">短剩余时间优先算法SRT</font>：SPN算法的可抢占改进</li>
</ul>
<p>缺点</p>
<ul>
<li>可能导致饥饿<ul>
<li>连续的短进程流会使长进程无法获得CPU资源</li>
</ul>
</li>
<li><font color="red">需要预知未来：主要是预估下一个进程需要的CPU计算的持续时间</font>：询问用户</li>
</ul>
<p><strong>最高响应比优先算法（Highest Response Ratio Next）</strong></p>
<ul>
<li>选择就绪队列中相应时间比R值最高的进程（R=(w+s)/s w：等待时间，s：执行时间）</li>
<li>在短进程优先算法的基础上改进</li>
<li>不可抢占</li>
<li>关注进程的等待时间</li>
<li>防止无限期推迟</li>
</ul>
<p><strong>时间片轮训算法（RR，Round-Robin）</strong></p>
<ul>
<li>时间片<ul>
<li>分配处理机资源的基本时间单元</li>
</ul>
</li>
<li>算法思路：<ul>
<li>时间片结束时，按照FCFS算法切换到下一个就绪进程</li>
<li>每隔(n-1)个时间片进程执行一个时间片q</li>
</ul>
</li>
</ul>
<p><strong>时间片轮转算法中的时间片长度</strong></p>
<ul>
<li>RR算法开销<ul>
<li>额外的上下文切换</li>
</ul>
</li>
<li>时间片太大<ul>
<li>等待时间过长</li>
<li>极限情况退化为FCFS</li>
</ul>
</li>
<li>时间片太小<ul>
<li>反应迅速，会产生大量上下文切换</li>
<li>大量上下文切换开销影响到系统吞吐量</li>
</ul>
</li>
<li>时间片长度选择目标<ul>
<li>选择一个合适的时间片长度</li>
<li>经验规则：维持上下文切换开销处于1%以内</li>
</ul>
</li>
</ul>
<p><strong>多级队列调度算法（MQ）</strong></p>
<ul>
<li>就绪队列被划分为多个独立的子队列</li>
<li>每个队列拥有自己的调度策略</li>
<li>队列间的调度<ul>
<li>固定优先级<ul>
<li>先处理前台，然后处理后台</li>
<li>可能导致饥饿（前台太多）</li>
</ul>
</li>
<li>时间片轮转<ul>
<li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>多级反馈队列算法（MLFQ Multi Level Feedback Queues）</strong></p>
<ul>
<li>进程可在不同队列间移动的多级队列算法<ul>
<li>时间片大小随优先级级别增加而增加</li>
<li>如进程再当前的时间片没有完成，则降到下一个优先级</li>
</ul>
</li>
<li>MLFQ算法的特征<ul>
<li>CPU密集型进程的优先级下降很快</li>
<li>I/O密集型进程停留在高优先级</li>
</ul>
</li>
</ul>
<p><strong>公平共享调度（FSS，Fair Share Scheduling）</strong></p>
<ul>
<li>FSS控制用户对系统资源的访问<ul>
<li>一些用户组比其他用户组更加重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照比例分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
</li>
</ul>
<h3 id="7-4-调度算法总结"><a href="#7-4-调度算法总结" class="headerlink" title="7.4 调度算法总结"></a>7.4 调度算法总结</h3><ul>
<li>先来先服务算法<ul>
<li>不公平、平均等待时间较差</li>
</ul>
</li>
<li>短进程优先算法<ul>
<li>不公平、平均周转时间最小</li>
<li>需要精确预测计算时间</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li>最高响应比优先算法<ul>
<li>基于SPN（短进程优先）调度</li>
<li>不可抢占</li>
</ul>
</li>
<li>时间片轮转算法<ul>
<li>公平，但是平均等待时间较差</li>
<li>多级反馈队列</li>
</ul>
</li>
<li>公平共享调度<ul>
<li>公平是第一要素</li>
</ul>
</li>
</ul>
<h3 id="7-5-实时操作系统"><a href="#7-5-实时操作系统" class="headerlink" title="7.5 实时操作系统"></a>7.5 实时操作系统</h3><p><strong>定义</strong>：正确依赖于其时间和功能两方面的操作系统</p>
<p><strong>性能指标</strong></p>
<ul>
<li>时间约束的及时性</li>
<li>速度和平均性能的相对不重要</li>
</ul>
<p><strong>实时操作系统的特性</strong></p>
<ul>
<li>时间约束的可预测性</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>强实时操作系统<ul>
<li>要求在指定的时间内必须完成重要的任务</li>
</ul>
</li>
<li>弱实时操作系统<ul>
<li>重要进程有高优先级，要求尽量但非必须完成</li>
</ul>
</li>
</ul>
<p><strong>实时任务</strong></p>
<p>任务：即工作单元，一次计算，一次文件读取，一次消息传递等。</p>
<p><strong>可调度性</strong></p>
<p>表示一个实时操作系统能够满足任务时限要求</p>
<h3 id="7-6-优先级返转-Priority-Inversion"><a href="#7-6-优先级返转-Priority-Inversion" class="headerlink" title="7.6 优先级返转(Priority Inversion)"></a>7.6 优先级返转(Priority Inversion)</h3><ul>
<li>操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象。</li>
<li>基于优先级的可抢占调度算法存在优先级反转现象</li>
</ul>
<p><font color="red">优先级反转的通俗含义理解：T1、T2、T3是三个优先级从高到低的进程，然而T1处理完之后，T3获得时间片，此时T3处理完之后，T2执行，然而再这时间内T1想要执行，却被T2给拦住，此时出现优先级反转的行为，导致程序重新启动。</font></p>
<p><strong>优先级继承(Priority Inheritance)</strong></p>
<ul>
<li>占用资源的低优先级进程继承申请资源的高优先级进程的优先级<ul>
<li>只有再占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级</li>
</ul>
</li>
</ul>
<p><font color="red">通俗理解：T1、T2、T3是三个优先级从高到低的进程，当T1要请求T3当前占有的资源的时候，此时T3就直接继承T1的优先级。由此可避免优先级反转的现象发生。</font></p>
<p><strong>优先级天花板协议(Priority Ceiling Protocol)</strong></p>
<ul>
<li>占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同<ul>
<li>不管是否发生等待，都提升占有资源进程的优先级</li>
<li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的常见面试点</title>
    <url>/2020/03/21/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h2><p>JVM也就是java虚拟机，运行时的数据区域分为：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存。</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的为本地方法则为空）</p>
<h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3><p>每个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完毕的过程，对应每一个栈帧在Java虚拟机中入栈和出栈的过程</p>
<p>可能会抛出的异常：</p>
<ul>
<li>线程请求的栈深度超过最大值，会抛出StackOverflowError异常</li>
<li>栈进行动态扩展时如果无法申请到足够的内存，会抛出OutOfMemoryError异常</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈与Java虚拟机栈类似，区别在于本地方法栈是为本地方法服务的。</p>
<p>本地方法一般使用其他语言（C++/C/汇编等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特殊处理。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>堆的主要作用就是给所有对象分配内存，是垃圾收集的主要区域。（GC堆）</p>
<p>堆为了方便回收，加上现代的垃圾收集器都是分代回收的，堆可以划分为新生代（Young Generation）和老年代（Old Generation）</p>
<p>堆不需要连续的内存，并且可以动态的增加其内存，增加失败会抛出OutOfMemoryError异常。</p>
<p>可以使用<code>-XMs20M  -XMx40M</code>设置堆内存大小，第一个是初始值，第二个是最大值</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存。并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。</p>
<p>对这块区域的回收主要是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>JDK1.8以后方法区被移至元空间，它位于本地内存中，而不是虚拟机内存中。因为在之前的HotSpot虚拟机都是将方法区的回收当成永久代进行回收，但是很难确定回收内存的大小，因为它们受到很多因素的影响，并且每次FullGC之后永久代的空间都会变，所以经常会抛出OutMemoryError异常。</p>
<p>方法区是JVM的一个规范，永久代和元空间都是它的实现方式，在JDK1.8之后，原来永久代的数据被分到元空间中，元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p>运行时常量池是方法区的一部分。</p>
<p>Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><p>在JDK1.4之后新引入了NIO类，它可以使用native函数库直接分配堆外内存，然后通过java堆里的 DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景下显著提升性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h3 id="8-线程所属"><a href="#8-线程所属" class="headerlink" title="8. 线程所属"></a>8. 线程所属</h3><p>上述属于线程私有的：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p>属于线程共有的：</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ul>
<h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><p>线程私有的部分都只存在于线程的生命周期之内，线程结束之后就消失。所以一般的垃圾回收主要是针对堆和方法区而言的。</p>
<p>既然要进行垃圾回收，就需要判断哪些是JVM中认定的可回收的“垃圾”。</p>
<h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><p>为对象添加一个引用计数器，当对象增加一个计数+1，引用失效时计数器-1，引用计数为0的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收，正是因为循环引用的存在，因此Java虚拟机不使用引用计数法。</p>
<h4 id="1-可达性分析算法"><a href="#1-可达性分析算法" class="headerlink" title="1. 可达性分析算法"></a>1. 可达性分析算法</h4><p>以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots一般包含一下内容：</p>
<ul>
<li>虚拟机栈局部变量表中引用的对象</li>
<li>本地方法栈JNI中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h4 id="2-方法区的回收"><a href="#2-方法区的回收" class="headerlink" title="2. 方法区的回收"></a>2. 方法区的回收</h4><p>因为方法区主要存放永久代对象，而永久代的回收率比新生代低很多，所以在方法区进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足三大条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li>
</ul>
<h4 id="3-finalize"><a href="#3-finalize" class="headerlink" title="3.  finalize()"></a>3.  finalize()</h4><p>类似C++的析构函数，用于关闭外部资源。但是try-finally等方式可以做的更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法让对象重新被引用，从而实现自救，自救只能进行一次，如果回收的对象之前调用finalize()方法自救，后面回收时不会再调用该方法。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java提供了四种强度不同的引用类型。</p>
<h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p>被强引用关联的对象不会被回收</p>
<p>使用 new一个新对象的方式来创建引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收</p>
<p>使用SoftReference类来创建软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(object);</span><br><span class="line">    <span class="comment">// 使对象只被软引用关联</span></span><br><span class="line">    object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</p>
<p>使用WeakReference来创建弱引用。</p>
<h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>又被称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时受到一个系统通知</p>
<p>使用PhantomReference 来构建虚引用</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h4><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这个两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小size的块block，如果它找到的块等于size，会直接返回这个分块；如果找到的块大于size，会将这个块分割成size大小和block-size大小的两块，返回大小为size的分块，并将block-size块返回给空闲链表</p>
<p>存在的不足：</p>
<ul>
<li>标记和清除效率都不高</li>
<li>会产生大量的不连续的内存碎片，导致无法给大对象分配内存</li>
</ul>
<h4 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记-整理"></a>2. 标记-整理</h4><p>标记整理的话，标记与上面1的标记相同，只是在回收之前会有一个整理过程，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点：</p>
<p>不会产生内存碎片</p>
<p>缺点：</p>
<p>需要移动大量对象，处理效率比较低</p>
<h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h4><p>将内存划分为两块大小相等的块，每次只使用其中一块，当这一块的内存使用完了就将还存活的对象复制到另一块上面，然后把使用过的内存空间一次清理。</p>
<p>主要存在的不足就是使用了内存的一半空间</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的块，而是划分为一块较大的Eden和两块较小的Survivor块，每次使用Eden空间和Survivor中的一块，在回收时，将Eden和Survivor中还存活着的对象全部复制到另一块Survivor上去，最后清理Eden和使用过的那一块的Survivor空间即可。</p>
<p>HotSpot虚拟机有Eden和Survivor大小比例默认为8:1，保证了内存的利用了达到90%，如果每次回收有多于10%的对象存活的话，那么一块Survivor对象就不够用了，此时需要依赖老年代进行 空间分配担保，就是借用老年代的空间存储放不下的对象。</p>
<h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h4><p>现在的商业虚拟机使用分代收集算法，它根据对象存货周期将内存分为几块，不同块采用适当的收集算法。</p>
<p>一般是分为新生代和老年代：</p>
<ul>
<li>新生代一般使用复制算法，因为回收的内存空间大，存活的对象少</li>
<li>老年代一般使用标记-清除或者标记-整理算法</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581662395801.png" alt="1581662395801"></p>
<p>以上是HotSpot的7个垃圾收集器，连线表示收集器之间可以配合使用</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，多线程表示使用多个线程</li>
<li>串行和并行：串行是指垃圾收集器与用户线程交替执行，这意味着再执行垃圾收集线程的时候需要停顿用户线程；并行是指垃圾收集器线程与用户线程一起执行。除了CMS和G1收集器之外其他的垃圾收集器都是以串行的方式执行</li>
</ul>
<h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h4><p>串行收集器，以串行的方式执行。它是单线程垃圾收集器，只会使用一个垃圾收集线程执行垃圾的回收。</p>
<p><strong>优点</strong>：简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是Client场景下默认的新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆的垃圾的停顿时间可以控制在100多毫秒之内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h4><p>它是Serial收集器的多线程版本。</p>
<p>它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了Serial收集器，只有它能与CMS收集器配合使用。</p>
<h4 id="3-Parallel-Scavenger收集器"><a href="#3-Parallel-Scavenger收集器" class="headerlink" title="3. Parallel Scavenger收集器"></a>3. Parallel Scavenger收集器</h4><p>与ParNew一样是多线程收集器。</p>
<p>其他收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制吞吐量，因此它被称为“吞吐量优先”的收集器，这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来实现的：新生代空间变小，垃圾回收频繁，导致吞吐量下降。（这里的原因是新生代空间如果大的话，一次收集需要停顿的时间可能是100ms，但是如果小的话，停顿时间可能只需要30ms，停顿时间缩短了，但是吞吐量也下降了）</p>
<p>可以通过一个开关参数打开GC自适应调节策略（GC Ergonomics），就不需要手动指定新生代的大小（-Xmn）、Eden和Survivor大小比例、晋升老年代的年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h4><p>Serial收集器的老年代版本，也是Client场景下使用的，如果在Server场景下：</p>
<ul>
<li>在JDK1.5以及之前版本（Parallel Old诞生之前）中与Parallel Scavenge收集器搭配使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本</p>
<p>在注重吞吐量以及CPU敏感的场合，都可以优先考虑Paralllel Scavenge结合Parallel Old收集器使用</p>
<h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h4><p>CMS（Concurrent Mark Sweep），并发标记清除。</p>
<p>分为四个流程来进行：</p>
<ul>
<li>初始标记：仅仅只是标记一下GC Roots能够关联到的对象，速度很快，<strong>需要停顿</strong></li>
<li>并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong></li>
<li>重新标记：为了修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿（不停顿就可能需要一直循环标记了:smile:）</li>
<li>并发清除：<strong>不需要停顿</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高</li>
<li>无法处理浮动垃圾，可能出现Concurrent Mode Failure。浮动垃圾指的是在并发清除阶段由于用户线程继续运行而产生的垃圾，这部分的垃圾只能到下一次的垃圾回收才能够被回收，由于浮动垃圾的存在，因此需要预留出一部分内存，以为这CMS收集器不能像其他垃圾收集器一样等到老年代内存快满的时候再进行回收。如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将启用Serial Old来替代CMS。</li>
<li>标记-清除算法将会导致产生大量的空间碎片，往往出现老年代空间剩余，但是没有足够大的空间来分配当前对象，以致于不得不提前触发一次Full GC</li>
</ul>
<h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的应用场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。</p>
<p>堆被分成新生代和老年代，其他收集器进行收集的范围都是新生代或者老年代，但是G1可以对新生代和老年代一起回收。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></p>
<p>G1把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></p>
<p>通过引入Region的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种回收方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验所得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的空间。</p>
<p>每个Region都有一个 Remembered Set，用来记录该Region对象的引用所在的Region，通过Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发期间由于用户线程工作导致标记产生变动的那一部分的标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs数据合并到Remembered Set中，这个阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个Region中的回收价值和回收成本进行排序，根据用户所期望的GC停顿时间来指定回收计划，此阶段其实也可做到与用户线程一起并发执行，但是因为只回收一部分Region，时间是用户控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体上来看是基于“标记-整理”算法实现的收集器，从局部的Region上来看是基于复制算法来的，这意味着在运行期间不会产生空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC的时间不得超过N毫秒。</li>
</ul>
<h2 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h2><h3 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h3><ul>
<li>Minor GC：回收新生代，因为新生代对象存活的时间很短，因此Minor会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象器存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很少。</li>
</ul>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在Eden上分配"><a href="#1-对象优先在Eden上分配" class="headerlink" title="1. 对象优先在Eden上分配"></a>1. 对象优先在Eden上分配</h4><p>大多数情况下，对象在新生代Eden上分配，当Eden上空间不足时，发动Minor GC</p>
<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数组</p>
<p>经常出现大对象会提前触发垃圾收集以获得足够的连续空间分配给大对象</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制</p>
<h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在Eden上出生并经历Minor GC后依然存活，将移动到Survivor中，年龄增加一岁，增加到一定年龄的对象移动到老年代中。默认是15岁</p>
<p>-XX:MaxTenuringThreshold，用来定义年龄的阈值</p>
<h4 id="4-动态对象年龄判断"><a href="#4-动态对象年龄判断" class="headerlink" title="4. 动态对象年龄判断"></a>4. 动态对象年龄判断</h4><p>虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor中相同年龄的所有对象大小的总和超过Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立的话，那么Minor GC可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure的值是否允许担保失败，如果允许的话就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于的话，将尝试着进行一次Minor GC操作；如果小于的话，或者HandlePromotionFailure的值不允许冒险，则需要进行以此Full GC</p>
<h3 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h3><p>对于Minor GC的话，其触发条件非常简单，当Eden空间满的时候，将触发一次Minor GC操作，而Full GC相对比较复杂。有以下条件：</p>
<h4 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1. 调用System.gc()"></a>1. 调用System.gc()</h4><p>只是建议虚拟机执行Full GC，但是虚拟机不一定真正的去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的场景如上文中的大对象直接进入老年代，长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的Full GC，应当尽量不要创建过大的对象以及数组，除此之外，可以通过-Xmn虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过-XX:MaxTenuringThreshold调大进入老年代的年龄，让对象在新生代中存活时间长一点。</p>
<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>Minor GC后存活的对象没有足够的空间可以容纳它，此时需要担保进入老年代，如果担保失败此时会触发Full GC</p>
<h4 id="4-JDK1-7及以前的永久代空间不足"><a href="#4-JDK1-7及以前的永久代空间不足" class="headerlink" title="4. JDK1.7及以前的永久代空间不足"></a>4. JDK1.7及以前的永久代空间不足</h4><p>在JDK1.7之前，HotSpot虚拟机中的方法区是永久代实现的，永久代存放的是Class的信息，常量，静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能被占满，在未配置CMS GC的时候也会执行Full GC，如果经过Full GC仍然回收不了，那么虚拟机会抛出<code>java.lang.OutOfMemoryError</code></p>
<p>为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或者转变为使用CMS GC</p>
<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC</p>
<h2 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，因为如果一次性加载，那么会占用很多的内存。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>七个阶段：</p>
<ol>
<li>加载-Loading</li>
<li>验证-Verficiation</li>
<li>准备-Preparation</li>
<li>解析-Resolution</li>
<li>初始化-Initialization</li>
<li>使用-Using</li>
<li>卸载-Unloading</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载过程包括：加载、验证、准备、解析、初始化五个过程</p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>加载是类加载的第一个阶段，不要混淆加载与类加载的概念，加载只是类加载的一个部分。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的全限定名获取定义该类的二进制字节流</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时的存储结构</li>
<li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li>
</ul>
<p>其中二进制文件流可以从如下途径中获取：</p>
<ul>
<li>从ZIP包中读取，成为JAR，EAR、WAR格式的基础</li>
<li>从网络中获取，最典型的就是Applet</li>
<li>运行时计算生成。例如动态代理技术，在java.lang.reflect.proxy使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li>
<li>由其他文件生成，例如由JSP生成对应的Class类</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>确保Class的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>如果是被static修饰的类变量，准备阶段会为类变量分配内存以及设置初始值，使用的是方法区的内存</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例初始化之前，并且类加载只有一次，实例化可以有多次。</p>
<p>初始值一般为0，但是如果用final修饰的变量为表达式赋予的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">123</span>; <span class="comment">// 初始值0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">123</span>; <span class="comment">// 初始值123</span></span><br></pre></td></tr></table></figure>

<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段开始之后再开始，是为了支持Java的动态绑定。</p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>初始化阶段才真正开始执行类中定义的Java程序代码，初始化阶段是虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</p>
<p><code>&lt;clinit&gt;()</code>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的先后顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量。定义在它之后的类变量只能赋值。不能访问。</p>
<p>JDK1.8下运行如下代码会输出0. JDK1.7的看代码中注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i); <span class="comment">// 编译器提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTest test = <span class="keyword">new</span> ClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块的执行要优先于子类。（继承）</p>
<p>接口中不能使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法，但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父类接口中的<code>&lt;clinit&gt;()</code>方法。只有在父接口中定义的变量被使用的时候，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程的环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都会阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中这种阻塞很隐蔽。</p>
<h3 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h3><h4 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规范了有且只有下列五种情况必须对类进行初始化（加载、验证、准备、解析都会随之发生）</p>
<ul>
<li>遇到new，getstatic，putstatic，invokestatic这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：使用new关键字实例化对象的时候；读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类还没有初始化，则需要先触发初始化</li>
<li>当初始化一个类的时候，发现其父类还没有初始化，则需要先初始化其父类</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法的句柄所对应的类没有初始化，则需要先触发其先初始化</li>
</ul>
<h4 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h4><p>上述五种场景的行为被称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用如下：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类被初始化。下列代码会输出”父类初始化…..”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String s = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类初始化....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类初始化......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承字Object的子类，其中包含了数组的属性和方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Son[] son = <span class="keyword">new</span> Son[<span class="number">10</span>]; <span class="comment">// 不会初始化Son</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Father.s);<span class="comment">// 不会初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器加载，这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的Class对象的equals()方法，isAaaignableFrom()方法，isInstance()方法的返回结果为true，也包括使用instanceOf关键字做对象所属关系判定结果为true</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>从Java虚拟机的角度来说，只存在一下两种类加载器：</p>
<ul>
<li>启动类加载器（Boostrap ClassLoader）：使用C++实现，是虚拟机自身的一部分</li>
<li>所有其他类加载器，使用Java实现，独立于虚拟机，继承自抽象类java.land.ClassLoader</li>
</ul>
<p>从java开发人员的角度来看，类加载器可以划分的更细：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader） ：此类加载器负责将存放在<code>JRE_HOME\lib</code>目录中的或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是被虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在目录下也不会被加载）类库加载到虚拟机内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器的时候，如果需要把加载请求委派给启动类加载器，直接说过null即可</li>
<li>扩展类加载器（Extension ClassLoader）：这个启动类加载器是由ExtClassLoader实现的，它负责将<code>JAVA_HOME/lib/ext</code>或者被java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器是由AppClassLoader实现的，这个类加载器是ClassLoader中的getClassLoader()方法的返回值，因此一般称为系统类加载器，他复杂加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下就是这个程序中的默认的类加载器。</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自定定义的类加载器。</p>
<p>下图就是双亲委派模型（Parents Delegation Model）的实现，该模型要求除了顶层的启动类加载器之外，其他的类加载器都要有自己的父加载器，这里的父子关系一般通过组合关系（表示我这个类由上一个类加载器，而我并不依赖他。所以非继承，是组合，has-a关系）来实现，而不是继承关系。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581672815558.png" alt="1581672815558"></p>
<h4 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成加载时才尝试自己加载</p>
<h4 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h4><p>使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h4><p>代码中很明显父类加载失败，才尝试自己去加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>一般自定义类加载器都是覆写findClass方法，然后通过defineClass将字节码转换成java.lang.Class类的实例。</p>
<p>自定义文件系统类加载器</p>
<p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、JVM优化"><a href="#五、JVM优化" class="headerlink" title="五、JVM优化"></a>五、JVM优化</h2><table>
<thead>
<tr>
<th>操作命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>打印HotSpot VM的进程</td>
</tr>
<tr>
<td>jstat</td>
<td>查看HotSpot VM运行时信息</td>
</tr>
<tr>
<td>jinfo</td>
<td>查看和修改虚拟机各项参数</td>
</tr>
<tr>
<td>jmap</td>
<td>heapdump：生成VM堆转储快照、查询finalize执行队列、Java堆和永久代详细信息</td>
</tr>
<tr>
<td>jstack</td>
<td>查看VM当前时刻的线程快照：当前VM内每一条线程正在执行的方法堆栈集合</td>
</tr>
<tr>
<td>javap</td>
<td>查看经javac编译后产生的JVM字节码代码</td>
</tr>
<tr>
<td>jcmd</td>
<td>多功能工具，可以用来导出堆，查看java进程、导出线程信息，执行GC、查看性能相关数据</td>
</tr>
<tr>
<td>jconsole</td>
<td>基于JMX的可视化监视、管理工具</td>
</tr>
<tr>
<td>jvisualvm</td>
<td>JDK中最强大运行监视和故障处理工具</td>
</tr>
</tbody></table>
<p><code>jps -l</code>：显示线程id和执行线程的主类名</p>
<p><code>jps -v</code>：显示线程id和执行线程的主类名和JVM配置信息</p>
<p><code>jstat -参数 线程id 执行时间 执行次数</code> =&gt; <code>jstat -gc 4488 30 10</code>：表示查看线程4488，30秒内执行10此的GC信息。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见算法题</title>
    <url>/2020/03/21/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1. 最长公共子序列(Leetcode 1143)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/23 22:10</span></span><br><span class="line"><span class="comment"> * 最长公共子序列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 找出两个字符串的最长公共子序列长度</span></span><br><span class="line"><span class="comment"> * "abcde" "ace" 3</span></span><br><span class="line"><span class="comment"> * "bcde"  "de" 2 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubsequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果第一个都不相等怎么解决这个问题？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (text1.length() == <span class="number">0</span> || text2.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = text2.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果相等的话,即1的前i-1与2的前j-1的基础上加1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果不能的话就看1的前i个与2的前j-1个，与1的前i-1个与2的前j个之间的大小情况</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongestCommonSubsequence test = <span class="keyword">new</span> LongestCommonSubsequence();</span><br><span class="line">        <span class="keyword">int</span> i = test.longestCommonSubsequence(<span class="string">"abcde"</span>, <span class="string">"ace"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 硬币组合问题（Leetcode面试题）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/23 21:49</span></span><br><span class="line"><span class="comment"> * 换硬币问题，典型的背包问题</span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示第i个物品是j空间的总数</span></span><br><span class="line"><span class="comment"> * dp[i][j] 一方面等于没有取第i个物品，此时背包空间j</span></span><br><span class="line"><span class="comment"> * 另一方面的等于去了第i个物品，此时背包空间为j-coins[i]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaysToChange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 第一列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>; <span class="comment">// 第一行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个硬币值开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; <span class="comment">// 空间为n</span></span><br><span class="line">                <span class="comment">// 前提是硬币需要大于当前适配的硬币值</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i]]) % <span class="number">1000000007</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果当前硬币值不大于适配的硬币面值，则只能顺应上一级的</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]; <span class="comment">// 放不下，价值没法增加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 零钱兑换(Leetcode 322)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选的面额，一定的钱，用最少的硬币个数凑成面额值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &gt; i)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">// 背包装不下，直接下一个</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 否则的话，判断背包装了这个硬币+1，之后与之前的大小，取最小的</span></span><br><span class="line">                    dp[i] = Math.min(dp[i],<span class="number">1</span>+dp[i-coin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ输入输出学习</title>
    <url>/2020/03/21/OJ%E5%9C%A8%E7%BA%BF%E5%88%A4%E9%A2%98%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="OJ在线判题学习"><a href="#OJ在线判题学习" class="headerlink" title="OJ在线判题学习"></a>OJ在线判题学习</h1><h2 id="1-正确处理输入格式"><a href="#1-正确处理输入格式" class="headerlink" title="1. 正确处理输入格式"></a>1. 正确处理输入格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预先不知道数据的组数---直接读到文件结尾</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事先知道数据组数---读数据组然后循环</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数据的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的只有一组数据---直接读</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line"><span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">System.out.println(a+b);</span><br></pre></td></tr></table></figure>

<h2 id="2-正确处理输出格式"><a href="#2-正确处理输出格式" class="headerlink" title="2. 正确处理输出格式"></a>2. 正确处理输出格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要输出case数</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数据的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要输出case数</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">" "</span> + (a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个case之后要有空行</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">" "</span> + (a + b)+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个case之间有空行</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">"结果为: "</span> + (a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-处理细节和技巧"><a href="#3-处理细节和技巧" class="headerlink" title="3. 处理细节和技巧"></a>3. 处理细节和技巧</h2><ul>
<li><p>不用实现可以保存所有输入，读一组计算一组，Java建议使用BufferedInputStream</p>
</li>
<li><p>注意输出格式</p>
<ul>
<li>字母大小写</li>
<li>换行的时刻</li>
<li>输出“case”之后有没有”#”或者”:”之类的</li>
<li>每行末尾有”\n”，但一般没有空白</li>
<li>java尽量使用BufferedOutputStream</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码</title>
    <url>/2020/03/21/ConcurrentHashMap%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap源码"><a href="#ConcurrentHashMap源码" class="headerlink" title="ConcurrentHashMap源码"></a>ConcurrentHashMap源码</h1><h2 id="1-JDK1-7版本"><a href="#1-JDK1-7版本" class="headerlink" title="1. JDK1.7版本"></a>1. JDK1.7版本</h2><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>ConcurrentHashMap与HashMap在实现上差距不大，最主要的区别在于ConcurrentHashMap采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段中的桶，从而提高并发度，并发度就是Segment的个数。</p>
<p>segment的定位是按照偏移量来定位的，底层使用了Unsafe类的相关方法。</p>
<p><code>HashEntry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Segment</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的并发级别是16，创建16个segment</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-size操作"><a href="#2-size操作" class="headerlink" title="2. size操作"></a>2. size操作</h3><p>每个Segment维护了一个count变量来统计该Segment中键值对的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行size操作的时候，需要遍历所有Segment然后把count累计起来</p>
<p>ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次尝试不加锁操作得到的结果一致，就认为这个结果是正确的。否则的话，就需要对每个Segment执行加锁，然后执行size操作。</p>
<p>这里加锁操作主要是因为ConcurrentHashMap是并发操作，你在获取size的同时可能还在插入元素，会导致获取到的结果出现问题。第一种方法是计算前后两次获取到的值是否相等，相等的话，表明没有元素插入，结果准确。否则一旦超过三次表明结果不准备需要给当前的segment加锁执行size操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 如果retries==2，执行++之后为3，此时加锁</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// sum size置0操作，主要是为了验证前后是否等。</span></span><br><span class="line">                <span class="comment">// last是不清零的，所以只要两次对等，表明没有数据插入。</span></span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// 表名没有数据插入，直接break，可以返回size</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3. put操作"></a>3. put操作</h3><p>put操作中涉及到两个参数<code>segmentShift\segmentMask</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line"><span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这两个参数定义在ConcurrentHashMap构造器中：</p>
<p>下面大致构造即使构造出segmentShift的大小以及segmentMask大小。至于初始的<code>c</code>这个主要是用来辅助构建有多少个Segment的。从下面可以看到MIN_SEGMENT_TABLE_CAPACITY=2，这个为2，表示最少每个Segment中的数组需要由两个坑位。至于cap与c之间的关系，可以看到，如果c为3的话此时cap需要从2翻倍到4，ssize是segment的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">// 从这里可以看出ssize=2^sshift次方</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">// 这里主要是为了获取取多少位的问题！</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0] 其余的延迟初始化</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"><span class="comment">// 这一句操作其实看完上面的也很好理解了，为什么需要左移segmentShift位呢</span></span><br><span class="line"><span class="comment">// 因为你的segmentMask是根据ssize-1来的，而根据ssize = 2^sshift可以知道</span></span><br><span class="line"><span class="comment">// sshift比ssize少32-sshift位(segmentShift)</span></span><br></pre></td></tr></table></figure>

<p>所以的话此时如果左移segmentShift位的话，再与的话正好取到高位相与的值就是下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    	<span class="comment">// 求下标</span></span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    	<span class="comment">// 如果偏移量不能定位的话，调用ensureSegment来定位</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put真正的实现，实质是在Segment中完成put操作的，因为分段锁的缘故。</p>
<p>put操作主要是因为加了锁！tryLock()方法一旦获取成功则意味着lock()，而scanAndLockForPut明确了最后推出只能lock()之后break退出。无论是否找到，出口只有<code>lock();break;return node;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试是否能够拿到锁，拿到则取null值，否则通过scanAndLockForPut自旋获取node</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Segment对应的HashEntry</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取在第几个hashEntry中</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取到tab的第一个值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k; <span class="comment">// 如果找到了的话，此时替换掉值即可</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value; </span><br><span class="line">                    <span class="comment">// 管你有没有，我都直接覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="comment">// 没找到则一直遍历下去</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125; <span class="comment">// 如果遇到了tab中为null的元素。</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 看看node是否为null，不为null的话，表明已经新建了节点</span></span><br><span class="line">                <span class="comment">// 只需要把自己的next设置为first头即可。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) <span class="comment">// 因为first==null</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">               <span class="comment">// 相当于直接将node这个节点作为当前HashEntry的第一个节点，下一个节点为null(first)</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// count是记录元素个数的</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 元素个数过多执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 一切顺利，将此node放入到当前的HashEntry中</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount; <span class="comment">// 修改次数++</span></span><br><span class="line">                count = c; <span class="comment">// 元素个数为c</span></span><br><span class="line">                oldValue = <span class="keyword">null</span>; <span class="comment">// 老的值记录为null，因为需要返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanAndLockForPut其中使用自旋获取锁。这一段的逻辑操作为：首先获取当前key-hash=hash(key)对应的节点链的头节点，然后持续遍历该链，如果节点中不存在该节点，则预创建一个新的节点，retries=0，意味着增加1，直到retries操作达到了最大值，进入阻塞等待状态，终止！否则的话在自旋过程中如果发现头节点发生了变化，此时头节点也相应的跟随变化，并将retries置为-1，意味着从头开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 自旋获取锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">// 预创建节点</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="comment">// 表示找到了，retries置为0，下一轮必结束，break，返回node即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next; <span class="comment">// 即不为空也不等，证明在其中则一直下去。</span></span><br><span class="line">        &#125;<span class="comment">// 尝试次数如果大于1了 采用阻塞锁获取</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; <span class="comment">// 只要链表头不改变，执行下去，否则同步链表头，重新再来</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-rehash操作"><a href="#3-rehash操作" class="headerlink" title="3. rehash操作"></a>3. rehash操作</h3><p><code>rehash</code>操作的话是对Segment中存储元素的扩容，也就是对table的扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 直接扩容一倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 直接构建新的table，这是为了使得并发get拿到值是没有问题的</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 使用新的掩码</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 由于是2的倍数，基本上之前的位置上的索引hash值是不会变的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i]; <span class="comment">// 取值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask; </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e; <span class="comment">// 如果是一个节点的话直接存，这是Doug Lea大神的一个优化点</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;<span class="comment">// 如果是多个节点的话</span></span><br><span class="line">                <span class="comment">// 表示在当前槽位上</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 遍历找到可重用的那个点，一般来说也不会发生变化。除非还有新的操作</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="comment">// lastRun之后的左右的节点都是可重用的。如果一开始就没变的话那就直接重用</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes </span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">// 保证所有不可重用点都是new出来的，不会对原有结构进行改变</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-get操作"><a href="#4-get操作" class="headerlink" title="4. get操作"></a>4. get操作</h3><p>get操作比较简单，由于在存入或者put操作的时候都是新创建一个新的表，所以获取只需要定位然后根据key值以及hash值判断即可，相等就取出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123; <span class="comment">// 定位segment,然后获取到HashEntry的位置</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-remove操作"><a href="#5-remove操作" class="headerlink" title="5. remove操作"></a>5. remove操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock()) <span class="comment">// 加锁失败，则采取自旋获取锁lock()</span></span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>; <span class="comment">// 移除之后需要返回的值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到当前segment的table</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取当前删除元素的下标位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 找到当前下标的头节点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;<span class="comment">// 记录前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k; <span class="comment">// 三个节点 pred 当前节点 next</span></span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value; <span class="comment">// hash与key都相等，取出值value判断是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">// 如果pred为null，正好是首节点，就将next设置为首节点</span></span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 否则直接跨过当前节点即可</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// 不然大家一起前进啊</span></span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-JDK1-8版本"><a href="#2-JDK1-8版本" class="headerlink" title="2. JDK1.8版本"></a>2. JDK1.8版本</h2><h3 id="1-基本结构-1"><a href="#1-基本结构-1" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>ConcurrentHashMap第一个的区别就是在于使用了Node来代替Segment存储数据，使用Node代替了HashEntry&lt;K,V&gt;，从Node的结构上我们可以看到，现在的粒度更细，之前Segment锁住的是所有的HashEntry&lt;K,V&gt;[]，现在锁住的仅仅是一个Node&lt;K,V&gt;，粒度更细，并发度更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中几个比较重要的方法：后面用得着</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前数组以及指定下标的节点的原子操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cas操作，比较并交换，在特定位置设置值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在某个下标处设置值的原子操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有个比较中要的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制初始化和扩容的，默认值为0，初始化的时候如果制定了大小，则这个值会保存在sizeCtl中</span></span><br><span class="line"><span class="comment"> * 大小为数组长度的0.75，当为负的时候，说明表正在初始化或在扩张，</span></span><br><span class="line"><span class="comment"> * -1 表示初始化</span></span><br><span class="line"><span class="comment"> * -(1+n):其中n表示正在活动的扩张线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<p>构造方法：空构造就不看了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化的时候如果指定了容量的话，此处就将sizeCtl=cap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法：初始化table，使用sizeCtl中记录的大小。初始化方法主要用于第一次put操作时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0的话表示别的线程正在初始化，自己进行线程礼让</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 否则的话比较 SIZECTL：表示当前对象的内存偏移量</span></span><br><span class="line">        <span class="comment">// 期望值sc，符合就将sc替换为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 指定了大小的话就按照指定大小来，否则默认16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// n-n/4=3n/4</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 长度为3/4,即0.75</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2. put操作"></a>2. put操作</h3><p>传入key-value，实际调用putVal方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第三个参数onlyIfAbscent: false的话表示value一定会被设置</span></span><br><span class="line">    <span class="comment">// true：表示value为null时才会被设置</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>putVal()</code>方法，从第一句<code>if (key == null || value == null) throw new NullPointerException();</code>可以看出，ConcurrentHashMap键值都不能为空。</p>
<p><strong>总结put操作的过程</strong>：</p>
<p>首先判断键值是否为null，不为null获取当前key的hash值，获取当前table，如果当前tab没有被初始化，则先调用initTable()方法先初始化表（顺便初始化sizeCtl）；已经初始化的话，此时判断当前位置的元素是否为null，是的话，利用CAS操作以key创建新节点Node插入当前位置即可。否则的话，判断当前的hash值是否为-1，看看是否有其他线程在执行扩容的复制过程，是的话自己要去帮忙，然后再回来处理put过程。都不是的话，此时可以知道当前位置是存在元素的，此时利用synchronized关键字加锁，由于允许并发操作，为防止之前取出的头节点发生变化，再次取出比较，如果还相等，证明当前Node没有插入新的元素，否则表明已经插入，直接返回null即可。</p>
<p>如果头节点没有发生变化，判断当前的hash值是否大于0，（-2是树化的hash值），此时就遍历Node，binCount=1，依次累加，如果找到了元素，直接覆盖。如果之前树化了，则利用putTreeVal的方法添加节点。最后判断bitCount的数量是否超过了树化的门限，超过则调用treeifyBin方法判断是扩容还是树化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 记录当前桶的元素个数（可以理解为坑位）</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果tab没有初始化，则执行initTable()方法初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 否则获取到当下下标处的Node节点，如果为null的话</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过CAS将当前新创建的节点放入即可</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 跳出循环，结束put操作</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125; <span class="comment">// MOVED：-1 用于转发节点的hash</span></span><br><span class="line">        <span class="comment">// 如果是MOVED状态的话，表示正在进行数组扩张的数据复制阶段。</span></span><br><span class="line">        <span class="comment">// 当前线程也会参与复制，通过允许多线程复制的功能，以此来减少数组的复制所带来的性能损失。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// fh如果在这里没有命中，往后走只有&gt;=0 以及 -2可取</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置有元素的话，采用synchronized加锁</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次取出值与之前取出的对比</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 取出的hash值大于0，如果转化为树则为-2</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">// 桶个数置为1，表示从1开始</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果找到了，则直接值覆盖，put成功</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 否则将之前的节点定为pred，看看后面是否为null</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 是的话，直接创建新的Node节点拼接在pred.next处</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">// 小于0的话。表示已经树化，此时判断是否为树的类型</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用putTreeVal方法，存入值</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// binCount发生变化之后，判断是否大于树化的门限值8，是的话，树化。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// binCount执行+1操作，返回null</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-treeifyBin操作"><a href="#3-treeifyBin操作" class="headerlink" title="3. treeifyBin操作"></a>3. treeifyBin操作</h3><blockquote>
<p>Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.</p>
</blockquote>
<p>将其中的给定了index的节点替换为树中节点（链表转为树），超过64就要转，除非表太小，这种情况就参与扩容操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;<span class="comment">// 如果表不为null且大小小于64，执行扩容操作。</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>); <span class="comment">// 直接扩成2倍即可</span></span><br><span class="line">        <span class="comment">// 否则的话取出当前index下的Node节点并在hash值大于0的情况下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">// 使用synchronized加锁，取出再次比较</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 只有一个节点的话，则head=p,当前节点为头结点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span> <span class="comment">// 否则将其放在数的最后一个节点next处</span></span><br><span class="line">                            tl.next = p; </span><br><span class="line">                        tl = p; <span class="comment">// tl变到下面。</span></span><br><span class="line">                    &#125;<span class="comment">// 将当前表放入TreeBin中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容实现方法：tryPresize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果size大于1 &lt;&lt; 30的一半，则直接使用最大的。否则的话调用tableSizeFor来扩容</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">    tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">// 无论怎么扩都要是2的整次幂</span></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 假如之前是16的容量需要扩到32，那么sizeCtl就需要从12扩到24</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 如果没有被初始化，则此时创建一个n大小为sc与c中的更大值的Node[]</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">// 比较置为-1.</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 确认其他线程没有对此表进行修改</span></span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">// 完成之后还是设置为3/4大小</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;<span class="comment">// 3/4大小</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 扩容到容量小于等于sizeCtl大小，或者n大于最大容量，终止扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则获取到tab</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果也在初始化扩容的话，则帮助扩容，否则开始新的扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="comment">// 第一个判断是判断右移这么多位之后与之前的n是否是同一个容量下进行扩容</span></span><br><span class="line">                <span class="comment">// 第二个和第三个判断是判断当前扩容数是否到达最大的限制</span></span><br><span class="line">                <span class="comment">// 第四和第五个判断是确保transfer()方法初始化完毕</span></span><br><span class="line">                <span class="comment">// 如果都不符合，直接判定break;退出扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 线程数+1，sc在扩容的时候表示transfer的工作线程数</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;<span class="comment">// 否则开始新的扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-transfer操作"><a href="#4-transfer操作" class="headerlink" title="4. transfer操作"></a>4. transfer操作</h3><p>这一节的代码解释可以参看：<a href="https://www.jianshu.com/p/2829fe36a8dd" target="_blank" rel="noopener">并发编程——ConcurrentHashMap#transfer() 扩容逐行分析</a></p>
<ul>
<li><input disabled="" type="checkbox"> 扩容这里Doug Lea有点天秀的感觉。（先Mark，等以后能力足了再来补充！）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 设定线程处理桶的个数NCPU获取的CPU核心数</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 初始化 扩容两倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;<span class="comment">// 占位节点</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 为true表示可以推进</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 保证完成状态</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// transferIndex为转移时的下标，扩容前的tab的length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;<span class="comment">// 向前推进</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-get操作"><a href="#5-get操作" class="headerlink" title="5. get操作"></a>5. get操作</h3><p>get操作和jdk1.7基本一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode()); <span class="comment">// 获取哈希值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 拿到当前的Node节点</span></span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前key的哈希值与当前获取到的节点哈希值相等</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 判断值是否相等，相等的话就返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 如果小于0的话，此时遍历寻找，不存在返回null</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 既不等于头结点的hash值，也不小于0,遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-ConcurrentHashMap1-7与1-8的区别"><a href="#3-ConcurrentHashMap1-7与1-8的区别" class="headerlink" title="3. ConcurrentHashMap1.7与1.8的区别"></a>3. ConcurrentHashMap1.7与1.8的区别</h2><ul>
<li>JDK1.7中采用分段锁来实现并发更新操作，核心类为Segment，它继承自ReentrantLock，并发度为Segment的数量，采用的是数组+链表</li>
<li>JDK1.8使用了CAS操作以此支持更高的并发度，在CAS操作失败之后使用内置锁synchronized，JDK1.8的实现在链表过长时也会转化为红黑树。底层是数组+链表+红黑树。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>ConcurrentHashMap支持并发操作，从get方法中我们可以看出，没有任何任何的同步机制，所以读操作支持并发操作。</p>
<p>写操作的话一般是put操作，放入元素时发生写的操作，这个时候会进行相应的加锁过程（jdk1.7），在jdk1.8中主要是利用synchronized以及cas+Unsafe底层的操作来实现的同步操作。</p>
<p>多个线程同步处理的过程通过synchronized和unsafe两种方式来实现的。</p>
<ul>
<li>在取得sizeCtl、Node节点的时候，使用的都是Unsafe方法实现，以达到并发安全的目的。</li>
<li>当需要在某个位置设置节点的时候，一般是值覆盖的时候，会使用synchronized同步机制来锁定该位置的节点</li>
<li>在数组扩容的时候，则通过处理的步长和fwd节点来控制达到并发安全的目的，通过设置hash值为MOVED</li>
<li>当把某个位置的节点复制到扩张后的table的时候，也是通过synchronized同步机制来实现</li>
</ul>
<p>[参考]([<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8]" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8]</a>(<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器))</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码|并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识</title>
    <url>/2020/03/21/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><h2 id="1-Redis与Memcache的区别"><a href="#1-Redis与Memcache的区别" class="headerlink" title="1. Redis与Memcache的区别"></a>1. Redis与Memcache的区别</h2><ul>
<li>Memcache代码层类似hash</li>
<li>Memcache支持简单数据类型，Redis支持丰富的数据类型</li>
<li>Memcache不支持数据持久化存储，Redis支持数据磁盘持久化存储</li>
<li>Memcache不支持主从，Redis支持主从</li>
<li>Memcahce不支持分片，Redis支持分片</li>
</ul>
<h2 id="2-Redis为什么这么快？"><a href="#2-Redis为什么这么快？" class="headerlink" title="2. Redis为什么这么快？"></a>2. Redis为什么这么快？</h2><p>官方给出的数据是100000+QPS，redis快的原因：</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li>
<li>数据结构简单，对数据操作也简单</li>
<li>采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例</li>
<li>使用多路I/O复用模型，阻塞IO</li>
</ul>
<h2 id="3-多路I-O复用模型"><a href="#3-多路I-O复用模型" class="headerlink" title="3. 多路I/O复用模型"></a>3. 多路I/O复用模型</h2><p>FD：File Descriptor，文件描述符</p>
<p>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的数据。</p>
<p><strong>Redis采用的I/O多路复用函数：epoll、kqueue、evport、select</strong></p>
<ul>
<li>因地制宜</li>
<li>优先选择时间复杂度为O(1) 的I/O多路复用函数作为底层实现</li>
<li>以时间复杂度为O(n)的select作为保底</li>
<li>基于react设计模式监听I/O事件</li>
</ul>
<h2 id="4-Redis常用的数据类型"><a href="#4-Redis常用的数据类型" class="headerlink" title="4. Redis常用的数据类型"></a>4. Redis常用的数据类型</h2><p>String：最基本的数据类型，二进制安全。</p>
<p>底层实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len; <span class="comment">// buf数据已占用的长度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// buf中剩余可用空间的长度</span></span><br><span class="line">	<span class="keyword">char</span> buf[]; <span class="comment">// 数据空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Hash：String元素组成的字典，适合存储对象。底层实现：字典</p>
<p>List：列表，按照String元素插入顺序排序（有序）。底层实现：链表</p>
<p>Set：String元素组成的无序集合，通过哈希实现，不允许重复（无序）：底层使用整数集合来存储</p>
<p>Sorted Set：通过分数来为集合中的成员进行从小到大的排序。（按照分数高低排序，也就是由分数权重）：跳跃表。时间复杂度O(logn)（最坏的情况下是O(n)）,跟二叉树有的一拼，时常用来代替二叉树。</p>
<h2 id="5-跳跃表"><a href="#5-跳跃表" class="headerlink" title="5. 跳跃表"></a>5. 跳跃表</h2><p>Sorted Set底层是基于跳跃表实现的。什么是跳跃表呢。其实就是链表，但是与链表不同的是，这是有层次的链表，什么意思呢，因为链表的查找很费时间，O(n)，查询效率低下，一旦用到数据量大的查询上面，性能不佳。此时为了提升查询的速度，提出了跳跃表的这种结构，从链表中提取出关键节点，一般是上一层是下一层的一半，提取的极限是那一层不大于2个节点时（≤2）停止提取。</p>
<p><img src="https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528210921601-949409375.png" alt="img"></p>
<h2 id="6-面试题：从海量key中查询出某一固定前缀的key"><a href="#6-面试题：从海量key中查询出某一固定前缀的key" class="headerlink" title="6. 面试题：从海量key中查询出某一固定前缀的key"></a>6. 面试题：从海量key中查询出某一固定前缀的key</h2><p>使用keys pattern来匹配，但是如果数据量巨大的话，会造成客户端卡段。keys指令一次性返回所有匹配的key。键的数量过大会造成服务的卡段，对于内存的消耗是一个隐患，对于redis这样的内存型数据库。</p>
<p><strong>scan cursor [MATCH pattern] [COUNT count]</strong>，基于游标的迭代器</p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li>
<li>一次返回的数量不可控，只能是大概率符合count参数</li>
</ul>
<p><code>scan 0 match n* count 1</code> 表示查询从0开始的以n开头的数据的一条记录。</p>
<h2 id="7-Redis实现分布式锁"><a href="#7-Redis实现分布式锁" class="headerlink" title="7. Redis实现分布式锁"></a>7. Redis实现分布式锁</h2><p>分布式锁需要解决的问题：</p>
<ul>
<li>互斥性</li>
<li>安全性</li>
<li>死锁</li>
<li>容错</li>
</ul>
<p><strong>第一种方案：使用SETNX+EXPIRE方案</strong></p>
<p>SETNX key value 如果这个key不存在，则设置这个value，时间复杂度O(1)，成功返回1，失败返回0</p>
<p>一般利用setnx来获取到锁，一旦获取到锁之后，采用expire的时间来释放锁，从而实现分布式锁。</p>
<p>解决setnx长期有效的问题采用的是expire来实现的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 大致的伪代码</span><br><span class="line">long num = setnx(key,value)</span><br><span class="line">if(num==1)&#123;expire key time;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的缺点在于一旦发生了某个节点的宕机，而此节点正好获取到了锁，此时未能设置expire造成原子性得不到满足。</p>
<p>setnx是原子操作，expire也是原子操作，但是两者在一起却不是原子操作</p>
<p><strong>第二种方案：使用SET+EXPIRE方案</strong></p>
<p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<ul>
<li>EX：设置的是存活的秒数</li>
<li>PX：设置的是存活的毫秒数</li>
<li>NX：只有键不存在的时候，才设置值</li>
<li>XX：只有键存在的时候，才设置值</li>
</ul>
<p>SET方法可以满足原子性，设置成功返回1，设置失败返回nil，由此实现Redis的分布式锁。</p>
<h2 id="8-Redis如何实现消息队列"><a href="#8-Redis如何实现消息队列" class="headerlink" title="8. Redis如何实现消息队列"></a>8. Redis如何实现消息队列</h2><p><strong>第一种方案使用lpush+rpop</strong></p>
<p>使用<code>lpush testlist &quot;aaa&quot;</code>实现从左向右推元素，完成消息的生产。</p>
<p>使用<code>rpop testlist</code>实现从右边弹出，完成消息的消费。</p>
<p><strong>存在的缺点：</strong></p>
<ul>
<li>没有等待队列中有值就直接消费</li>
<li>弥补：可以通过在应用层中引入sleep机制去调用lpop重试</li>
</ul>
<p><strong>第二种方法使用blpop+rpush</strong></p>
<p>BLPOP key[key] timeout：阻塞直到队列有消息或者超时</p>
<p>BLPOP使用的话是用来精确定时，也就是在设置的timeout中看阻塞队列中是否有消息。</p>
<p>缺点：每次生产的消息只能够供一个消费者消费。</p>
<p><strong>多个消费者的问题，使用pub/sub模式来解决：主题订阅者模式</strong></p>
<ul>
<li>发送者（pub）发送消息，订阅者（sub）接收消息</li>
<li>订阅者可以订阅任意数量的频道</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582621048095.png" alt="1582621048095"></p>
<p>使用pub/sub主题订阅者模式实现一个消息多个消费者消费的问题。</p>
<p><strong>缺点：</strong></p>
<p>消息的发布是无状态的，无法保证可达。</p>
<p>消息发布的时候下线，然后上线，这个消息，订阅者是接收不到的。如果要保证可达需要使用kafka，专业的消息队列</p>
<h2 id="9-Redis如何实现持久化"><a href="#9-Redis如何实现持久化" class="headerlink" title="9. Redis如何实现持久化"></a>9. Redis如何实现持久化</h2><h3 id="9-1-RDB"><a href="#9-1-RDB" class="headerlink" title="9.1 RDB"></a>9.1 RDB</h3><p>RDB快照持久化：保存某个时间点的全量数据快照。</p>
<ul>
<li>save：阻塞Redis的服务器进程，直到RDB文件被创建完毕</li>
<li>BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器</li>
</ul>
<p><strong>自动触发RDB持久化的方式：</strong></p>
<ul>
<li>根据redis.conf中配置的save m n定时触发，用的是bgsave</li>
<li>主从复制的时候，主节点自动触发</li>
<li>执行Debug Reload</li>
<li>执行shutdown且没有开启AOF持久化</li>
</ul>
<p>BGSAVE的工作原理：</p>
<ul>
<li>检查子进程（看是否有RDB或者AOF的子进程正在工作），存在的话返回错误</li>
<li>触发持久化，调用rdbSaveBackground</li>
<li>fork出一个子进程完成save操作，当前进程继续响应其他操作</li>
</ul>
<p>系统调用fork()，创建进程，实现copy-on-write:</p>
<p>如果有多个调用者同时要求相同资源（如内存或者磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用视图修改资源的内容时，系统才会真正复制一份专用副本给调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p><strong>RDB持久化的缺点：</strong></p>
<ul>
<li>内存数据的全量同步，数据量大会由于I/O而严重影响性能。</li>
<li>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据。</li>
</ul>
<h3 id="9-3-AOF"><a href="#9-3-AOF" class="headerlink" title="9.3 AOF"></a>9.3 AOF</h3><p><strong>AOF：append-only-file ：保持写状态</strong></p>
<ul>
<li>记录下除了查询以外所有变更数据库的指令</li>
<li>以append的形式追加保存到AOF文件中（增量）</li>
</ul>
<p><strong>由于AOF文件是不断追加形式的，日志重写解决AOF文件不断增大的问题，步骤如下：</strong></p>
<ul>
<li>调用fork()，创建一个子进程</li>
<li>子进程把新的AOF写到一个临时文件中，不依赖原来的AOF文件</li>
<li>主进程持续将新的变动写到内存和原来的AOF文件中</li>
<li>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动</li>
<li>使用新AOF文件替换掉旧的AOF文件</li>
</ul>
<p><strong>Redis数据的恢复：</strong>一般是RDB和AOF文件共存时候的问题。</p>
<ul>
<li>存在AOF，则加载AOF文件，否则加载RDB，如果两者都不存在，报加载失败。</li>
</ul>
<p><strong>RDB和AOF的对比：</strong></p>
<ul>
<li>RDB优点：全量数据快照，文件小，恢复快</li>
<li>RDB缺点：无法保存最近一次快照以后的数据</li>
<li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li>
<li>AOF缺点：文件体积大，恢复时间长</li>
</ul>
<p><strong>Redis如何做持久化</strong>：现在支持RDB-AOF混合持久化</p>
<ul>
<li>BGSAVE做镜像全量持久化，AOF做增量持久化</li>
</ul>
<h2 id="10-Pipeline"><a href="#10-Pipeline" class="headerlink" title="10. Pipeline"></a>10. Pipeline</h2><p>使用Pipeline的好处：</p>
<ul>
<li>Pipeline和Linux的管道相似</li>
<li>Redis基于请求/响应模式，单个请求处理需要一一应答</li>
<li>Pipeline批量执行指令，节省多次I/O往返的时间</li>
<li>有顺序依赖的指令建议分批分送</li>
</ul>
<h2 id="11-Redis的同步机制"><a href="#11-Redis的同步机制" class="headerlink" title="11. Redis的同步机制"></a>11. Redis的同步机制</h2><p><strong>主从同步的全同步过程：</strong></p>
<ul>
<li>Slave发送sync命令到Master</li>
<li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li>
<li>Master将保存数据快照期间接收到的写命令缓存起来（此时写命令属于增量）</li>
<li>Master完成写操作之后，将该文件发送给slave</li>
<li>使用新的AOF替换掉旧的AOF文件</li>
<li>Master将这期间收集到的增量写命令发送给slave端</li>
</ul>
<p><strong>增量同步过程</strong>：</p>
<ul>
<li>Master接收到用户的操作指令，判断是否需要传播到slave</li>
<li>将操作记录追加到AOF文件</li>
<li>将操作传播到其他slave：1. 对齐主从库；2.往响应缓存写入指令</li>
<li>将缓存中的数据发送给slave</li>
</ul>
<p><strong>Redis Sentinel哨兵：高可用</strong></p>
<ul>
<li>监控：检查主从服务器是否运行正常</li>
<li>提醒：通过API向管理员或者其他应用程序发送故障通知</li>
<li>自动故障迁移：主从切换</li>
</ul>
<p><strong>流言协议Gossip</strong>：在杂乱无章中寻求一致</p>
<ul>
<li>每个节点都随机地与对方通信，最终所有节点的状态达成一致</li>
<li>种子节点定期随机向其他节点发送节点列表以及需要传播的消息</li>
<li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li>
</ul>
<h2 id="12-Redis的集群原理"><a href="#12-Redis的集群原理" class="headerlink" title="12. Redis的集群原理"></a>12. Redis的集群原理</h2><p><strong>从海量的数据中找到所需：</strong></p>
<ul>
<li>分片：按照某种规则去划分数据，分散存储在多个节点上</li>
<li>常规的按照哈希划分无法实现节点的动态增减。</li>
</ul>
<p><strong>一致性哈希算法</strong>：对2<sup>32</sup>取模，将哈希值组织成虚拟的圆环</p>
<p><strong>将数据key使用相同的函数Hash计算出hash值，由于是环状的，所有的节点计算出的hash值都会按照顺时针归属为自己最近的节点。无论是节点宕机还是增加节点都比较方便。但是这样不可避免的会出现节点过少，此时由于节点分布不均匀，将会导致数据的倾斜问题产生，此时需要引入虚拟节点来解决数据倾斜的问题，也就是同一节点再细分成不同的编号组，以此使得数据倾斜问题被解决。</strong></p>
<h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>本章主要介绍的是redis的相关知识，首先从基础的结构将其，redis作为内存型数据库，操作数据的能力是非常快的，且有丰富的数据类型，数据操作简单。连接Memcache与Redis的区别，随后为什么redis这么快，主要是直接操作内存，数据操作简单，单线程，多了I/O复用，随后通过从海量的key中找出固定前缀的key，引出keys pattern和scan基于游标的迭代获取结果数据方式。</p>
<p>随后介绍分布式锁，分布式锁需要解决的问题是，互斥性，安全性，死锁以及容错四个特性，使用SETNX+EXPIRE实现分布式锁，由于存在破坏原子性的可能，使用SET直接设置可以实现原子性，实现分布式锁。随后通过list中的常用的lpush+rpop实现消息队列，使用BLPOP+RPUSH+timeout实现定时获取消息的机制。但是这存在一个消息只能有一个消费者。</p>
<p>如果一个消息需要被多个消费者消费的话，需要使用pub/sub模式，订阅发布模式来实现，虽然能够实现一个消息被多个消费者消费，但是不能够保证消息的可达性，也就是发布者不能保证订阅者一定能够接收到消息。（一个是发送的无状态，不能保证可达，还有一个就是如果发布消息的时候订阅者上线，然后上线，这条消息也是接收不到的。如果需要解决需要依赖于专业的消息队列中间件KafKa）</p>
<p>随后介绍持久化的实现基于BGSAVE的快照RDB实现，以及操作数据的AOF文件追加实现，现在支持两种方案并行使用。</p>
<p>然后就是介绍Pipeline的机制，节省多次I/O往返时间。介绍了Redis的主从同步机制以及增量的同步机制。Redis哨兵的高可用性以及流言协议Gossip对于同步的最后趋于一致性的作用。</p>
<p>最后就是介绍Redis的集群原理，主要是通过分片，对数据Hash取模值，最后形成hash环以此将数据相对比较均匀的分散到各个节点之上。如果遇到节点数过少，此时数据可能产生倾斜，此时需要使用单个节点多次编号来解决这个问题，使得数据分布相对均匀。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备知识</title>
    <url>/2020/03/21/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="字节面试准备"><a href="#字节面试准备" class="headerlink" title="字节面试准备"></a>字节面试准备</h1><h2 id="1-常见的算法题"><a href="#1-常见的算法题" class="headerlink" title="1. 常见的算法题"></a>1. 常见的算法题</h2><h3 id="1-1-链表"><a href="#1-1-链表" class="headerlink" title="1.1 链表"></a>1.1 链表</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>1.找出两个链表的第一个公共节点，复杂度要求O(n)，空间复杂度O(1)</strong></p>
<p>找出两个链表的长度，长的先走，然后一起走，相遇的时候就是公共节点</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2.检测链表是否有环？如果要查找入换的节点呢？</strong></p>
<p>快慢链表，只要相遇就有环。</p>
<p>输出入环的节点只需要在相遇的时候，快指针回到链表头部，快慢指针同步前进，一旦相遇就是入环节点。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>3.链表对折</strong></p>
<p>找到终点，然后将前后两部分翻转，最后将两个链表合起来即可。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>4.K链表反转（Leetcode25）</strong></p>
</li>
</ul>
<p><strong>5. 封装一个单链表，要求实现添加、删除、反转方法？</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>6.链表奇数位升序，偶数位降序，如何改为有序链表？</strong></li>
</ul>
<p>​    第一种方法遍历将偶数存一个链表，将奇数存一个链表，最后合并。</p>
<p>​    不用额外空间的方法：</p>
<p>​    第二种方法：奇数构成一个链表，偶数构成一个链表，翻转偶数链表，两个链表合并即可。</p>
<h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2 字符串"></a>1.2 字符串</h3><p><strong>1.最长不重复子序列长度</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2. 反转url：<a href="http://www.toutiao.com变成com.toutiao.www" target="_blank" rel="noopener">www.toutiao.com变成com.toutiao.www</a> 采用两次翻转</strong></p>
<p>先执行总的反转，然后根据’.’作为分隔符，将每一部分的单词顺序翻转即可。总共两次翻转</p>
</li>
</ul>
<h3 id="1-3-数组"><a href="#1-3-数组" class="headerlink" title="1.3 数组"></a>1.3 数组</h3><p><strong>1.将数组所有的0都放到数组末尾</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2.三十六进制加法，要求不能转换为十进制？</strong></p>
<p>利用一个进位符号来记录进位，对两个数分别取最后一位进行相加以36为基准，判断是否大于36或者小于36采用不同的拼接方式。字母的拼接可以采用一个记录了36个字母的字符串来表示，直接从字符串中获取。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>3.求下一个大的数</strong></p>
</li>
</ul>
<p><strong>4.相交区间合并：[1,5] [2,7] [4,9]…把有相交的区间合并为一个？</strong></p>
<p><strong>5.一个数组里面含有正负数，</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>6.输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</strong></li>
</ul>
<p>这一题主要是比较器的重写问题。组合组合。</p>
<p><strong>7.给一个函数返回0和1，概率为p或者p-1，请你实现一个函数，使得返回0和1概率相同</strong></p>
<p><strong>8.两数相加 leetcode 2</strong></p>
<p><strong>9.数组中每个数右边第一个比它大的元素leetcode 1019</strong></p>
<p><strong>10.一个无序数组一个target，找出数组中两个和为target的数，并输出下标。（不能使用Hash）</strong></p>
<p><strong>11.给两对有序的数组，给出合并后有序的数组（归并）</strong></p>
<p><strong>12.汉诺塔</strong></p>
<p><strong>13.数组反转</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>14. 最长连续子序列</strong></p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>15. 数组反转给定一个target，每target长度反转一次</strong></p>
</li>
</ul>
<h3 id="1-4-二叉树"><a href="#1-4-二叉树" class="headerlink" title="1.4 二叉树"></a>1.4 二叉树</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <strong>1.二叉树的公共祖先，不用递归如何实现？写出如何找出这条路径的算法？</strong></li>
</ul>
<p><strong>2.二叉树中和为某一值的路径，为什么要removeLast？</strong></p>
<p><strong>3.给一棵二叉树，根为root，请你删除一条边，使二叉树分裂成两颗子树，且他们的子树和乘积尽可能大，返回最大的乘积？（Leetcode 1339）</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>4.树的右视图，递归和非递归实现？</strong></li>
</ul>
<p><del><strong>5.寻找p1和p2节点两颗树的最近公共祖先节点</strong></del></p>
<p><del><strong>6.二叉树的最近公共祖先Leetcode 236</strong></del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要不都大于</span></span><br><span class="line">    <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">// 要不都小于</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要不就在两边,返回当前的</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树的最近公共祖先（使用递归解决）</span></span><br><span class="line"><span class="keyword">private</span> TreeNode ans = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    findNode(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNode</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 直接到最深处</span></span><br><span class="line">    <span class="keyword">int</span> left = findNode(root.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 看看右边有没有找到</span></span><br><span class="line">    <span class="keyword">int</span> right = findNode(root.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (root.val == p.val || root.val == q.val) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到了两个</span></span><br><span class="line">    <span class="keyword">if</span> (left + right + mid &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否找到的结果</span></span><br><span class="line">    <span class="keyword">return</span> (left + right + mid) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用非递归解决</span></span><br><span class="line"><span class="comment">// 利用map记录节点和指针。利用队列实现广度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用以放置节点和父指针</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parent.put(root,<span class="keyword">null</span>);</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 如果同时包含两个Node的话终止</span></span><br><span class="line">    <span class="keyword">while</span>(!parent.containsKey(p) || !parent.containsKey(q))&#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent.put(pop.left,pop);</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent.put(pop.right,pop);</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这主要是对祖先节点去重</span></span><br><span class="line">    Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从上到下取出得到的所有的祖先节点，还不带重复</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ancestors.add(p);</span><br><span class="line">        p = parent.get(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取共同的祖先节点</span></span><br><span class="line">    <span class="keyword">while</span>( !ancestors.contains(q))&#123;</span><br><span class="line">        <span class="comment">// 从上到下获取父节点</span></span><br><span class="line">        q = parent.get(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-堆"><a href="#1-5-堆" class="headerlink" title="1.5 堆"></a>1.5 堆</h3><p><strong>1.百万的数据，找出最大的100个，如果数据100亿太大怎么办？</strong></p>
<p>使用小顶堆即可。如果数据太大的话，可以采用数据分割，分次读取即可。</p>
<h3 id="1-6-栈"><a href="#1-6-栈" class="headerlink" title="1.6 栈"></a>1.6 栈</h3><p><strong>1.Min栈的实现</strong></p>
<p><strong>2.手上握有一堆牌，分两步 1.把顶上的牌发出去  2.把顶上的牌放到底部, 重复1-2步，直到手上没牌。给出桌子上的发牌顺序，求原来手牌顺序</strong></p>
<h3 id="1-7-动态规划"><a href="#1-7-动态规划" class="headerlink" title="1.7 动态规划"></a>1.7 动态规划</h3><p><strong>1.上楼梯，给定一个n，从0开始，每次只能加6或者8，输出到达n最小的操作次数？</strong></p>
<p><strong>2.m*n的方格。从方格的一端到另一端有多少种方法？</strong></p>
<p><strong>3.有1 2 5 这种走法，n块的话有多少种走法？</strong></p>
<h2 id="2-常问的知识点"><a href="#2-常问的知识点" class="headerlink" title="2. 常问的知识点"></a>2. 常问的知识点</h2><h3 id="2-1-计算机网络"><a href="#2-1-计算机网络" class="headerlink" title="2.1 计算机网络"></a>2.1 计算机网络</h3><p><strong>1.三次握手是什么，为什么需要三次？TCP四次挥手，为什么需要等待2MSL？</strong></p>
<p>三次握手发生在TCP建立连接的时候，假设A为客户端，B为服务器，A发送SYN=1，seq=x的连接请求到B，A进入SYN-SENT状态；B如果同意建立连接，发送SYN=1，ACK=1，seq=y，确认号ack=x+1给A，B进入SYN-RCVD状态；A收到请求之后再次向B进行确认，发送SYN=1,ACK=1,seq=x+1,ack=y+1给B，双方进入到ESTABLISHED状态。三次的话主要是为了消除A发送的在网络中的滞留的请求到达B，而使得B发送确认，但此时A不再接受，B会一直发送确认报文。假如是两次的话，一旦滞留请求连接到达B此时B就要打开额外的连接。</p>
<p>四次挥手主要用于通信双方连接的释放：</p>
<p>A发送FIN=1,seq=u的连接释放请求给B，此时A进入FIN-WAIT1状态，B收到A的连接释放请求之后，需要发出确认，ACK=1，seq=v，ack=u+1,此时B进入CLOSED-WAIT状态，A收到报文之后，进入FIN-WAIT2状态，此时双方处于半关闭状态，如果此时B还有属于要发送给A的话，A还是可以接收的，当数据发送完毕，B发送FIN=1，ACK=1,seq=w，ack=u+1的连接释放报文给A，此时B进入LAST-ACK状态，等待最终确认，A收到后，发送确认报文ACK=1，seq=u+1,ack=w+1,此时A进入TIME-WAIT状态，等待2MSL进入CLOSED状态，B接收到A的确认之后就进入CLOSED状态。</p>
<p>等待2MSL，MSL是报文最长存活时间，1.保证B能够接收到确认报文，进入CLOSED状态。2.使得在释放过程中产生的所有的报文在网络中消失，使得下一次连接不会出现旧的连接请求报文。</p>
<p><strong>2.滑动窗口是什么，干什么用的？</strong></p>
<p>RTT：发送一个数据报到收到一个对应的ACK所花费的时间</p>
<p>RTO：重传时间间隔</p>
<p>TCP使用滑动窗口做<strong>流量控制</strong>和<strong>乱序重排</strong>。</p>
<p>第一个是提供TCP的可靠性，第二个是提供TCP的流控特性。</p>
<p>滑动窗口体现了TCP传输字节流的特性。</p>
<p>（TCP滑动窗口具体的实现，是发送方有一个滑动窗口，接收方也有一个滑动窗口，发送的时候需要已经发送并得到接收方确认的滑动窗口才可以从左向右滑动。而接收方需要获取到对方已接受并已经确认才可以继续从左向右滑动。）</p>
<p><strong>3.TCP和UDP的区别？</strong></p>
<ul>
<li>TCP是面向连接的，UDP是无连接的（TCP有三次握手，UDP适合消息的多播发布，单点向多点发布）</li>
<li>TCP是可靠交付的，UDP是尽最大努力交付的，不保证可靠性</li>
<li>TCP传输的数据是有序的，UDP是无序的（TCP利用序列号，数据有序）</li>
<li>TCP速度慢（创建连接），UDP快（适合在线视频媒体，电视广播，游戏直播，多人在线游戏）</li>
<li>量级，TCP头部有20个字节重量级，UDP只有8个字节轻量级</li>
</ul>
<p><strong>4. HTTP协议是什么样的？</strong></p>
<p>HTTP协议是应用层的协议，是一种基于请求与响应模式的无状态的协议，采用TCP进行连接，在1.1中引入了长连接keep-alived。</p>
<ul>
<li>支持C/S模式</li>
<li>简单快速（传送请求方法和路径即可 请求方法有 get  head post三种）</li>
<li>灵活：可以传输任意类型的数据使用Content-Type加以标记</li>
<li>无连接：限制每次连接只处理一个请求。可以节省传输时间。长连接可以理解为下层实现对上层透明。</li>
<li>无状态</li>
</ul>
<p>HTTP的请求结构：</p>
<p>请求头+回车/换行（/r/n）+请求正文</p>
<p>响应头+回车/换行（/r/n）+响应正文</p>
<p>HTTP请求响应的步骤：</p>
<ul>
<li>客户端连接Web服务器</li>
<li>发送HTTP请求</li>
<li>服务器接受请求并返回HTTP响应</li>
<li>释放TCP连接</li>
<li>客户端浏览器解析HTML内容</li>
</ul>
<p><strong>5.GET和POST的区别？</strong></p>
<ul>
<li>http报文层面：GET将请求信息放在URL中，POST放在报文主体</li>
<li>数据库层面：GET符合幂等性和安全性的，POST不符合（因为POST会对数据库的访问的内容进行修改）</li>
<li>其他层面：GET可以被缓存、被存储，POST不行</li>
</ul>
<p><strong>6.HTTPS的加密过程?为什么传输要用到对称加密？</strong></p>
<p>对称加密+非对称加密，非对称加密很安全，一般用于传输加密的相关信息。因为非对称加密可以传输的字节有大小限制，但是对称加密适合大数据量的传输。</p>
<p><strong>7.HTTP与HTTPS的区别，HTTPS建立连接的过程？</strong></p>
<p><strong>区别:</strong></p>
<ul>
<li>http使用80端口，https使用443端口，使用的是完全不同的连接方式</li>
<li>http是没有加密运行在tcp之上，https是运行在ssl/tls之上，ssl/tls运行在tcp上加密</li>
<li>https需要申请CA证书，一般需要付费，http不需要</li>
<li>https可以有效地防止运营商劫持，解决了防劫持的一个大问题</li>
</ul>
<p>或者</p>
<ul>
<li>https需要申请CA证书，一般需要付费，http不需要</li>
<li>HTTP密文传输，HTTP明文传输</li>
<li>连接方式不同，端口不同https 443 ，而HTTP是80</li>
<li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP更加安全</li>
</ul>
<p><strong>HTTPS数据传输流程：</strong></p>
<ul>
<li>浏览器将支持的加密算法发给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，以证书的形式返回给浏览器</li>
<li>浏览器验证证书的合法性，并结合证书中给出的公钥加密信息发送给服务器</li>
<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发给浏览器</li>
<li>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</li>
</ul>
<p><strong>8. TCP的拥塞控制？</strong></p>
<p>TCP的拥塞控制与TCP的流量控制比较类似，但是TCP的流量控制是针对发送方和发送方之间的流量控制。拥塞控制是减轻整个网络的拥塞。TCP的拥塞一旦发生，分组将会丢失，此时发送方会继续执行重传，将会导致网络拥塞程度更高，因此当出现拥塞时，应该采用TCP的拥塞控制。</p>
<p>主要有慢开始和拥塞避免，已经快开始与拥塞避免。</p>
<p>慢开始，开始增加，每次确认翻倍，等到了门限值sshthresh的时候，采用拥塞避免算法。如果发生拥塞的话，此时门限值sshthreash=cwnd/2，此时重新冲0开始执行慢开始算法。</p>
<p>而快恢复算法的话，只是到了发生拥塞的时候门限值变化为cwnd/2，才是开始也从这个点开始执行拥塞避免算法。</p>
<p>（注意还有一个快重传算法，就是每收到三次同样的确认报文，就直接重发下一个报文给接收方）</p>
<p><strong>9.DNS，输入URL之后到展示出页面发生了哪些流程？</strong></p>
<p>一、</p>
<ul>
<li>DNS域名解析系统先解析域名到IP地址</li>
<li>获得IP地址之后建立TCP连接，发送HTTP请求</li>
<li>服务器收到HTTP请求之后，返回HTTP响应报文</li>
<li>浏览器收到响应报文之后对页面HTML进行渲染，展示页面</li>
<li>连接结束</li>
</ul>
<p>二、</p>
<ul>
<li>DNS解析（DNS缓存查询：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，）</li>
<li>TCP连接（三次握手）</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
<li>TCP释放连接，连接结束</li>
</ul>
<p><strong>10.traceroute作用</strong></p>
<p>用来跟踪一个分组从源点到终点的路径。ICMP网际报文控制协议。经过路由器后，生存时间TTL改变了。</p>
<p><strong>11.socket编程</strong></p>
<p>TCP与UDP实现消息的传输</p>
<p><strong>12.xss跨域是什么？</strong></p>
<p>XSS攻击指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</p>
<p><strong>13.什么是数字签名，有什么作用？</strong></p>
<p>数字签名主要是用来存放公钥和私钥以及摘要的，作用就还是在进行HTTPS进行连接的时候进行数据秘钥协商的。数字签名=数字摘要+非对称加密技术。数字证书就是第三方提供的一个信任证书，用以对服务器的身份安全认证。</p>
<p><font color="red">流程：客户端向服务器发送协议版本号，随机数1，支持的加密算法，服务器确认双方的加密算法，然后服务器向客户端发送随机数2，以及自己的数字证书CA（含有公钥），客户端接收到证书之后验证服务器身份，随后生成随机数3，利用数字证书中的公钥进行加密发送给服务器，服务器接收到之后利用私钥解密获取到第三个数字，然后双方使用3个随机数字利用约定好的加密算法，生成双方对话的对称私钥。</font></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581993368392.png" alt="1581993368392"></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092003.png" alt="img"></p>
<p><strong>14.知道DNS吗，如何减少DNS的传输时间？host是啥，如何减少host的查询时间？</strong></p>
<p>DNS域名系统服务，减少DNS查找的时间，使用UDP进行传输。</p>
<p>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。所以减少唯一主机名的数量就可以减少DNS查找的数量。（减少host文件中的唯一主机名）</p>
<p><strong>15.交换机和路由器分别处于哪一层？</strong></p>
<p>交换器处于数据链路层，主要是维护MAC表</p>
<p>路由器处于网络层，主要是IP寻址和路由选择。</p>
<p><strong>16.什么是缓存溢出？</strong></p>
<p>是指存在缓存溢出漏洞的计算机中，攻击者用超出常规长度的字符数来填满一个域，通常是内存区地址。</p>
<p><strong>17.HTTP1.0和HTTP1.1区别，HTTP1和HTTP2的区别？</strong></p>
<p>HTTP1.0与HTTP1.1的区别主要在于：</p>
<ul>
<li><p>长连接：1.1支持长连接keep-alived</p>
</li>
<li><p>缓存处理：1.1的缓存策略更多</p>
</li>
<li><p>带宽优化及网络连接的使用：带宽主要是1.1中引入了range，控制文件对象大小。</p>
</li>
<li><p>错误通知的处理：1.1新增了状态码，更好的执行错误通知</p>
</li>
<li><p>Host头的处理：1.1中请求头和响应头都支持Host头域</p>
</li>
</ul>
<p>HTTP1.x与HTTP2的区别：</p>
<ul>
<li>新的二进制文件：HTTP1.x的解析是基于文本。HTTP2.x则是基于二进制</li>
<li>多路复用：连接共享</li>
<li>header压缩：HTTP2.0使用encoder来减少传输的header大小。</li>
<li>服务端推送：HTTP2.0具有server push功能</li>
</ul>
<p><strong>18. HTTP常见的状态码？</strong></p>
<ul>
<li>1XX：请求已接受并继续处理</li>
<li>2XX：表示成功，请求被成功接收、理解、接受</li>
<li>3XX：重定向，要完成请求必须进行更进一步的操作</li>
<li>4XX：客户端错误-请求有语法错误或请求无法实现</li>
<li>5XX：服务器错误，服务器未能实现合法的请求</li>
</ul>
<p><strong>19. Cookie和Session的区别</strong></p>
<p>Cookie：</p>
<ul>
<li>是由服务器发送给客户端的特殊的信息，以文本的形式存放在客户端</li>
<li>客户端再次请求的时候，会把Cookie回发</li>
<li>服务器接收到之后，会解析Cookie生成与客户端相对应的内容 </li>
</ul>
<p>Cookie流程：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582011572513.png" alt="1582011572513"></p>
<p>Session：</p>
<ul>
<li>服务器端的机制，在服务器上保存的信息</li>
<li>解析客户端请求并操作Session_id，按需保存状态信息</li>
</ul>
<p>Session的实现方式：</p>
<ul>
<li>使用Cookie来实现，在服务器发送过去的时候Set-Cookie中设置JSESSIONID=xxx，客户端的Cookie中的JSESSIONID=xxx给服务器，服务器返回响应</li>
<li>URL回写来实现。隐式的下载请求的URL中，这样在访问同一个网站的所有页面都可以直接有权操作。</li>
</ul>
<p>两者的区别：</p>
<ul>
<li>Cookie的数据存放在客户端的浏览器上，Session的数据放在服务器上</li>
<li>Session相对Cookie来说比较安全</li>
<li>若考虑减轻服务器的负担，应当使用Cookie</li>
</ul>
<p><strong>20. HTTP中有哪些加密方式</strong></p>
<ul>
<li>对称加密：加密和解密都用同一个秘钥</li>
<li>非对称加密：加密和解密使用不用的秘钥</li>
<li>哈希算法：将任意长度的信息转化为固定长度的值，不可逆</li>
<li>数字签名：证明某个消息或者某个文件是某人发出的</li>
</ul>
<h3 id="2-2-操作系统"><a href="#2-2-操作系统" class="headerlink" title="2.2 操作系统"></a>2.2 操作系统</h3><p><strong>1.进程和线程的区别</strong></p>
<ul>
<li>进程是资源分配与调度的基本单位，线程是CPU调度和分派的基本单位</li>
<li>进程拥有独立地址空间，线程共享所属进程的地址空间</li>
<li>进程是拥有系统资源的一个独立单位，而线程基本上不拥有资源，与其他线程共享本进程的相关资源如内存，I/O，CPU等</li>
<li>进程切换，涉及到当前整个CPU环境的保护环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器内容，并不涉及存储器管理方面的操作。可见进程切换的开销远远大于线程切换的开销</li>
<li>线程之间的通信更加方便，同一进程下的线程共享全局变量等数据。而进程之间的通信需要以进程之间通信（IPC）的方式进行</li>
<li>多线程只要有一个线程崩溃，整个程序就崩溃了，但是多进程如果有一个程序崩溃不会影响到其他进程，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<p><strong>2.操作系统为什么有用户态和内核态，用户级线程和内核级线程如何转换？</strong></p>
<p>拥有用户态和内核态主要是为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，所以CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他程序获取</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这是就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的任务，在切换为用户态并返回系统调用的结果。</p>
<p><strong>如何切换</strong>：</p>
<ul>
<li>系统调用：比如读取命令行输入，本质还是通过中断实现的。</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会想CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ul>
<p><strong>为什么要分内核态和用户态？</strong></p>
<p>答：</p>
<ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源</li>
<li>封装性：用户程序不需要实现更加底层的代码</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度会更加方便</li>
</ul>
<p><strong>3.epoll了解吗？</strong></p>
<p>epoll是Linux内核中为处理大批量文件描述符而做了改进的poll，在Linux下多了复用IO接口select/poll的增强版本，他能显著的提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<p><strong>4.进程有哪些通信方式？</strong></p>
<ul>
<li>管道</li>
<li>共享内存 </li>
<li>信号量</li>
<li>消息队列</li>
<li>套接字</li>
</ul>
<p><strong>5.操作系统中的spin lock和Java中锁的区别</strong></p>
<p><strong>6. 操作系统的分页分段管理？虚拟内存？</strong></p>
<p><strong>分页分段的区别</strong></p>
<ol>
<li><p>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配是以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻。</p>
</li>
<li><p>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个segment（如代码段，数据段，堆栈段），内存空间被动态的分成为长度不同的区域，分配时以段为单位，每段在内存中占连续空间，各段可以不相邻</p>
</li>
<li><p>段页式存储：用户进程先按段划分，段内按页再分，内存划分和分配按页</p>
</li>
</ol>
<p><strong>区别：</strong></p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存获得更大的地址空间；分段的目的就是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间。</li>
<li>大小不同：段的大小不固定，由其所完成的功能所决定；页的大小固定，由系统决定</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）</li>
<li>分段便于信息的保护和共享；分页的共享受到限制</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会有内碎片（一个页填不满）</li>
</ul>
<p><strong>虚拟内存是什么？</strong></p>
<p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射为物理的页；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样对于程序来说，逻辑上似乎有很大的内存空间，但实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<p><strong>如何进行地址空间到物理内存的映射？</strong></p>
<p><strong>内存管理单元（MMU）</strong>管理着逻辑地址和物理地址的转换，其中的页表（page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含有效位（判断是在内存还是磁盘）、访问位（是否被访问）、被修改（内存中是否被修改）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
<p><strong>7.线程同步有哪些方式？为什么要进行线程同步？</strong></p>
<ul>
<li><strong>互斥量Mutex</strong>：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
<li><strong>信号量Semaphore</strong>：信号量是内核对象，它允许同一时刻多个线程访问对象，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源访问，当前可用资源计数就减1，只要当前信号量的可用资源计数大于0，就可以发出信号量，如果为0，则将线程放入一个队列中等待。线程处理完共享资源以后，应当在离开的同时通过<code>ReleaseSemaphore</code>函数，将当前可用资源计数加1。如果信号量的取值只能为0或者1，信号量就变成了互斥量。</li>
<li><strong>事件Event</strong>：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。时间分为手动重置事件和自动重置事件；手动重置事件被设置为激活状态之后会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激活状态。自动重置状态被设置为激活状态之后，会唤醒一个等待中的线程，然后自动恢复为未激活状态。</li>
<li><strong>临界区 Critical Section</strong>：任意时刻只允许一个线程对临界资源进行访问，拥有临界区对象的线程，可以访问该临界资源，其他试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<p>进行线程同步主要是为了对共享资源访问的同步性，避免出现操作冲突。</p>
<h3 id="2-3-数据库"><a href="#2-3-数据库" class="headerlink" title="2.3 数据库"></a>2.3 数据库</h3><p><strong>1.Mysql事务隔离级别有哪些？</strong></p>
<p>读未提交：读取其他事务未提交的数据，可能发生脏读，不可重复读，幻读</p>
<p>读已提交：读取其他事务已提交的数据，可能发生不可重复读，幻读</p>
<p>可重复读：同一个事务多次读取数据结果是一样的，可能发生幻读</p>
<p>可串行化：事务串行执行，这是最安全的，可以避免上述所有问题</p>
<p><strong>2.事务隔离级别的实现？</strong></p>
<p>实现事务隔离级别的方式：</p>
<p>1.一级封锁协议：对应读未提交，指代事务在需要修改的事务上面（就是在发生修改的瞬间）对其加共享锁（其他事务不能更改，但是可以读取，导致“脏读”发生），直到事务结束才释放。事务结束包括提交和回滚</p>
<p>2.二级封锁协议：对应读已提交，指代事务对需要更新的数据加排它锁，防止其他事务读取未提交的数据，避免了脏读。事务在对应读取的数据上加共享锁，读完则释放锁。</p>
<p>3.三级封锁协议：对应可重复读，指代二级封锁协议在读取数据的瞬间必须对其添加共享锁，直到事务结束释放，这样保证了可重复读（其他事物能读取数据，但是不能更新数据）</p>
<p>4.四级封锁协议：三级封锁协议的增强版，实现机制最为简单，直接对事务中所读取或者更改的数据所在的表加表锁，也就是说，其他事务不能读写该表中的任何数据。可以避免上述所有的问题。</p>
<p><strong>3.Mysql有哪些锁，如何加锁？</strong></p>
<p>表级锁和行级锁。</p>
<p><strong>4.数据库的主键索引和普通索引的区别？哪个查询更快？</strong></p>
<p>主键索引只需要查询一次即可，但是普通索引的话可能涉及回表，所以一般来说主键索引速度会更快！</p>
<p>主键索引的叶子节点放置了本行的记录，普通索引的节点存放了主键的id，查询的时候需要做一次回表查询，但是也不一定必须要回表，当查询的字段刚好是索引的字段或者是索引的一部分，就可以不用回表，这也是索引覆盖的原理。</p>
<p><strong>5.索引越多越好吗？索引建多了会有什么问题？对操作有什么影响？</strong></p>
<p>不是，当对表中的数据进行增删改的时候，索引也要动态的维护，这样就降低了数据的维护速度。而且索引需要占物理空间，处理数据表占数据空间之外，每一个索引还需要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会很大。创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增加。</p>
<p><strong>6.聚簇索引和非聚簇索引的区别？</strong></p>
<p><strong>非聚簇索引</strong>：B+Tree的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree的搜索算法搜索索引，如果指定的key存在，则取出对应的data域的值，然后把data域的值为地址读取相应的记录。索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，</p>
<p><strong>聚簇索引</strong>：这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，被称为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。进行索引搜索时，直接找到key所在的节点即可取出数据；而根据辅助索引查找时，则需要取出主键的值，再走一遍主键索引。因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p><strong>7.幻读的概念，幻读和不可重复读的区别？</strong></p>
<p>幻读指的是第一个事务读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中当第一个事务再去读的时候，就会发现多了一些原本不存在的记录。像出现了幻觉一样。</p>
<p>不可重复读是指读的数据第一次和第二次不一样。</p>
<p>幻读和不可重复读的区别：幻读是指事务插入或者删除操作过程中发生的，而不可重复读是指事务的修改动作。</p>
<p><strong>8.说一下MVCC的概念，实现的原理，解决的问题？</strong></p>
<p><strong>MVCC简单来说是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>，主要的作用就是为了让读写不冲突！</p>
<p>MVCC（Multi Version Concurrency Control）多版本并发控制。MVCC并没有简单的使用数据库的行锁，而是使用了行级锁。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p>
<p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。（在操作的时候保存了一个版本号）。存在的特征：每行数据都有一个版本，每次数据更新时都更新该版本号。保存时比较版本号，成功的话，则覆盖原记录；失败则rollback</p>
<p>InnoDB中的实现，有一个创建版本号和一个删除版本号。crud过程中通过比较数据版本号来实现对数据版本的控制。</p>
<p>解决的问题：解决了在可重复读，和读已提交两个隔离级别下读同一行和写同一行的两个事务的并发。</p>
<ul>
<li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li>
<li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）。</li>
</ul>
<p>下面的例子确实好理解：</p>
<blockquote>
<p><strong>举个简单的例子：</strong></p>
<ol>
<li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li>
<li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li>
<li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li>
<li><strong>事务B又一次读取了X。这时</strong></li>
</ol>
<ul>
<li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li>
<li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li>
</ul>
</blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/73078137" target="_blank" rel="noopener">MVCC解决了什么问题</a></p>
<p><strong>9.MySQL使用什么数据结构存储数据？B树与B+树的区别？为什么使用B+而不用B树？</strong></p>
<p>MySQL使用B+树来存储数据。</p>
<p>B数的话，是节点存储数据和索引文件，而B+树的话，节点只存储索引，可以存储更多的索引文件，查找也更快只需要走一遍即可。且所有数据都在叶子节点，且叶子节点内部维护着链表，有利于范围统计。</p>
<p><strong>10.联合索引</strong></p>
<p><strong>11.最左匹配成因</strong></p>
<p>最左匹配的成因是因为如果第一个order by，对于数据来说正序，如果第二个也order by得话，此时数据就乱序了，这也就是使用最左匹配的成因。</p>
<p><strong>12.MySQL主从复制原理？读写分离如何在代码层实现？</strong></p>
<p><strong>13. B+Tree为什么更好？</strong></p>
<ul>
<li>B+树的磁盘读写代价更低，因为B+数的节点中只存储索引不存储数据，可以从存储更多的关键字信息</li>
<li>B+树的查询效率更加稳定。因为B+树的结构问题，所有数据的查询只需要走一趟即可。</li>
<li>B+树更有利于对数据库的扫描。因为B+树的叶子节点之间形成了链表，且有序对于范围查询更方便。</li>
</ul>
<p><strong>14. 按道理说Hash索引也可以实现数据的查询，且速度很快，为什么Mysql不使用Hash索引？</strong></p>
<ul>
<li><p>仅仅能满足”=”，”IN“，不能使用范围查询</p>
</li>
<li><p>无法被用来避免数据的排序操作</p>
</li>
<li><p>不能利用部分索引键查询</p>
</li>
<li><p>不能避免表扫描（有些键会有相同的hash值，找到了一个以后还是要全表扫描找出所有）</p>
</li>
<li><p>遇到大量Hash值相等的时候性能并不一定会比B-Tree高</p>
</li>
</ul>
<p><strong>15. 索引四个问题？</strong></p>
<ul>
<li>为什么要使用索引？因为使用索引可以避免全表扫描提高检索效率。</li>
<li>什么样的信息能成为索引？主键，唯一键等普通键，具有可区别的信息都可以</li>
<li>索引的数据结构？一般采用B+Tree，也有少部分采用Hash索引，bitMap索引，Mysql不显式支持Hash索引</li>
<li>密集索引和稀疏索引的区别？主要在于密集索引的辅助索引中包含主键，也就是密集索引文件中每个搜索码值都对应一个索引值。稀疏索是辅助索引与主键索引一样可以直接找到记录，只为索引码的某些值建立索引。</li>
</ul>
<p>InnoDB的索引和数据放在一起，而MyISAM是索引和数据分开的。</p>
<p><strong>16. 如何定位并优化慢SQL</strong></p>
<ul>
<li>通过慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或者尽量让sql走索引</li>
</ul>
<h4 id="2-3-1锁小结"><a href="#2-3-1锁小结" class="headerlink" title="2.3.1锁小结"></a>2.3.1锁小结</h4><p><strong>1. MyISAM和InnoDB关于锁方面的区别是什么？</strong></p>
<ul>
<li>MyISAM默认使用的是表级锁，不支持行级锁</li>
<li>InnoDB默认使用的是行级锁，也支持表级锁</li>
</ul>
<p><strong>MyISAM适用的场景：</strong></p>
<ul>
<li>频繁执行全表count语句</li>
<li>对数据进行增删改效率不高，查询非常频繁</li>
<li>没有事务</li>
</ul>
<p><strong>InnoDB适合的场景：</strong></p>
<ul>
<li>数据增删改查都很频繁</li>
<li>可靠性要求比较高，要求支持事务</li>
</ul>
<p><strong>数据库锁的分类</strong></p>
<ul>
<li>按照锁的粒度划分：表级锁，行级锁，页级锁</li>
<li>按照锁级别划分：共享锁，排它锁</li>
<li>按加锁的方式划分：自动锁，显式锁</li>
<li>按照操作划分：DML锁，DDL锁</li>
<li>按照使用方式划分：乐观锁、悲观锁</li>
</ul>
<p><strong>2. 数据库的四大特性</strong></p>
<ul>
<li>A：原子性</li>
<li>C：一致性</li>
<li>I：隔离性</li>
<li>D：持久性</li>
</ul>
<p><strong>3. 事务隔离级别以及各级别下的并发访问问题</strong></p>
<ul>
<li>更新丢失：mysql所有的事务隔离级别在数据库层面上均可避免</li>
<li>脏读：READ-COMMITED事务隔离级别以上可以避免</li>
<li>不可重复读：REPEATED-READ事务隔离级别以上可以避免</li>
<li>幻读：SERIALIZABLE事务隔离级别可以避免</li>
</ul>
<p><font color="red">注意：不可重复读和幻读之间的区别在于，不可重复读侧重在修改更新上，而幻读侧重在插入和删除数据上面。</font></p>
<p><strong>4. InnoDB可重复读隔离级别下如何避免幻读</strong></p>
<ul>
<li>表象：快照读（非阻塞读）– 伪MVCC</li>
<li>内在：next-key锁（行锁+gap锁）<ul>
<li>行锁</li>
<li>gap锁</li>
</ul>
</li>
</ul>
<p><strong>对主键索引或者唯一索引会用Gap锁吗</strong></p>
<ul>
<li>如果where条件全部命中，则不会使用gap锁，只会加记录锁</li>
<li>如果where条件部分命中或者全不命中，则会加gap锁</li>
</ul>
<p><font color="red">Gap锁会用在非唯一索引或不走索引的当前读中</font></p>
<p><strong>当前读和快照读：</strong></p>
<ul>
<li>当前读：selece….lock in share mode，select…for update;</li>
<li>当前读：update，delete，insert</li>
<li>快照读：不加锁的非阻塞读，select</li>
</ul>
<p>避免幻读主要是由快照读来实现的，快照读的数据的准确性由快照读的时机来决定的。（时机不好，容易读到老的数据）</p>
<p><strong>5. RC、RR级别下的InnoDB的非阻塞读如何实现</strong></p>
<ul>
<li>数据行中的 DB_TRX_ID、 DB_ROLL_PTR、 DB_ROW_ID字段</li>
<li>undo日志</li>
<li>read view（可读视图）</li>
</ul>
<h3 id="2-4-SQL基本语法"><a href="#2-4-SQL基本语法" class="headerlink" title="2.4 SQL基本语法"></a>2.4 SQL基本语法</h3><p>关键语法：</p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT，SUM，MAX，MIN，AVG</li>
</ul>
<p><strong>GROUP BY</strong></p>
<ul>
<li>满足“SELECT子句中的列名必须为分组列或列函数”</li>
<li>列函数对于group by子句定义的每个组各返回一个结果</li>
</ul>
<p><strong>HAVING</strong></p>
<ul>
<li>通常与GROUP BY子句一起使用</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一SQL中的顺序：where&gt;group by&gt;having</li>
<li>如果SQL语句中group by，可以使用having代替where</li>
</ul>
<h2 id="3-Java基础知识"><a href="#3-Java基础知识" class="headerlink" title="3. Java基础知识"></a>3. Java基础知识</h2><p><strong>1.面向对象的特性，多态如何实现？</strong></p>
<p>封装、多态、继承。多态的特性通过继承来实现。</p>
<p><strong>2.手写单例模式</strong></p>
<p><strong>3.HashMap</strong></p>
<p><strong>4.深拷贝和浅拷贝</strong></p>
<p>浅拷贝拷贝的只是对象的引用。而深拷贝是重新创建了一个对象的副本。</p>
<p><strong>5. 值传递和引用传递</strong></p>
<p><strong>6.死锁</strong></p>
<p>是指两个或者多个并发的进程中，每个进程持有某种资源又等待其他进程释放它们所保持的资源，在未改变这种状态之前都不能向前推进，则称这一组进程产生了死锁（deadLock）</p>
<p><strong>产生死锁的必要条件</strong>：</p>
<ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程占用</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其他进程占用的资源</li>
<li><strong>非抢占</strong>：已经被分配给一个进程的资源不能被强制性抢占，只能由该进程完成任务之后自愿释放</li>
<li><strong>循环等待</strong>：若干进程之间形成了一种头尾相连的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占用的资源。</li>
</ul>
<p><strong>7.线程之间的同步方式</strong></p>
<ul>
<li>互斥量</li>
<li>信号量</li>
<li>事件</li>
<li>临界区</li>
</ul>
<p><strong>8.java基本数据类型和占用的空间大小</strong></p>
<p><strong>9.重载和重写的是什么？</strong></p>
<p><strong>10.ReentrantLock底层实现？</strong></p>
<p><strong>11.手写阻塞队列？生产者消费者？优化方法？</strong></p>
<p>之前就采用wait/nitify/notifyAll，优化的话采用ReentrantLock的Condition类来实现。</p>
<p><strong>12.说一说你最熟悉的设计模式？</strong></p>
<p>单例模式，代理模式，MVC</p>
<p><strong>13.IO多路复用</strong></p>
<p><strong>14.LRU缓存怎么实现的？</strong></p>
<p>主要是利用双向链表来实现的，LRU称为最近最少使用算法，主要的实现是每访问一次就将此元素移动到链表末尾。每次取出都移除第一个元素，以保证存储的都是热点数据。</p>
<p><strong>15.注解是什么，底层如何实现的？</strong></p>
<p><strong>16.如何保证HashMap是安全的，CurrentHashMap的原理如何加锁的？</strong></p>
<p><strong>17.LinkedHashMap和HashMap的区别？</strong></p>
<p>内部维持着双向链表。</p>
<p><strong>18.互斥锁和同步锁的区别？</strong></p>
<p>互斥是通过竞争对资源的使用，彼此之间不知道对方的存在，执行顺序是一个乱序。</p>
<p>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方的存在，执行顺序往往是有序的。（同步就是信号量的意思）</p>
<p><strong>19.乐观锁和互斥锁的区别？</strong></p>
<p>乐观锁没有加锁，而互斥锁是已经加了锁。互斥锁类似于悲观锁。</p>
<p><strong>20.Java synchronized的类锁和对象锁，哪些是对象锁，那些是类锁？</strong></p>
<p>区别在于一个锁的是当前类，一个锁的是当前对象。</p>
<p>对象锁的话一般是锁代码块。而类锁的话是锁方法</p>
<p><strong>21.了解bitmap的解析吗</strong></p>
<p><strong>22. Java中的泛型，类型擦除，如果说Java的泛型是伪泛型，为什么不直接使用Obect代替？</strong></p>
<p>*<em>23. *</em></p>
<h2 id="4-Redis知识"><a href="#4-Redis知识" class="headerlink" title="4. Redis知识"></a>4. Redis知识</h2><p><strong>1.redis常用数据类型以及底层？Sorted Set的查找插入删除操作的时间复杂度？zset的大小限制？</strong></p>
<p>常用数据类型：String，Hash，List，Set，Sorted Set</p>
<p>String底层就是简单的k-v键值对。Hash底层就是field-(k-v键值对)，List底层就是链表，Set底层类似于Hash。value全为null的数据结构，Sorted Set底层使用了 ziplist，skipList，dict等数据结构</p>
<p><strong>2.redis持久化方式，有什么区别？如果AOF文件过大怎么办？</strong></p>
<p>RDB持久化，快照的方式来实现的在这个时候获取存储在内存里面的数据在某个时间点的副本。默认RDB</p>
<p>AOF文件追加的方式，文件追加就是追加当前执行的命令，然后恢复的时候服务器执行一遍命令即可。</p>
<p>AOF文件过大可以使用AOF重写机制。服务器通过读取数据库当前键值对来实现的，程序无须对现有AOF文件进行任意读入、分析或者写入操作。</p>
<p><strong>3.redis的有序列表怎么实现的？跳表有什么优势？与二叉树相比的话？</strong></p>
<p><strong>4.redis的过期策略？</strong></p>
<p>定期删除和惰性删除</p>
<ul>
<li><p>定期删除：每隔100ms抽取部分过期键删除</p>
</li>
<li><p>惰性删除：是用到的时候看有没有过期，过期了就删除</p>
</li>
</ul>
<p><strong>5.redis内存淘汰机制？</strong></p>
<p><strong>6.redis的mget与pipeline的区别？</strong></p>
<h2 id="5-Spring-SringBoot-SpringCloud"><a href="#5-Spring-SringBoot-SpringCloud" class="headerlink" title="5. Spring+SringBoot+SpringCloud"></a>5. Spring+SringBoot+SpringCloud</h2><p><strong>1.说说SpringCloud的注册中心？</strong></p>
<p><strong>2.负载均衡策略，Ribbon用到的是那种？</strong></p>
<p>轮询</p>
<p><strong>3.运行中注册中心如果有一个实例挂掉了会出现什么情况？</strong></p>
<p><strong>4.服务熔断和服务降级</strong></p>
<p><strong>5.服务中心怎么保证高可用？怎么保证一致性？一致性算法？</strong></p>
<p><strong>6.Spring Bean的生命周期？</strong></p>
<p><strong>7.SpringBoot的启动流程？</strong></p>
<p><strong>8.Spring AOP的实现原理？</strong></p>
<h2 id="6-JVM知识"><a href="#6-JVM知识" class="headerlink" title="6. JVM知识"></a>6. JVM知识</h2><p><strong>1.GC</strong></p>
<p><strong>2.类加载过程</strong></p>
<p>类加载过程主要分为五步：</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
</ul>
<p><strong>3.垃圾回收的方法</strong></p>
<ul>
<li>标记-清除</li>
<li>标记-整理</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ul>
<p><strong>4.类加载器</strong></p>
<p>常见的有启动类加载器Bootstrap ClassLoader，扩展类加载器Extension ClassLoader ，程序应用加载器Application ClassLoader</p>
<p><strong>5.JVM内存模型，各种变量存储的位置问题，垃圾收集器。</strong></p>
<p><strong>6.JVM如何判断对象可被回收？哪些可以作为GC roots</strong></p>
<h2 id="7-Linux知识"><a href="#7-Linux知识" class="headerlink" title="7. Linux知识"></a>7. Linux知识</h2><p><strong>1.Linux查看文件的第N行？</strong></p>
<p>vim file +n</p>
<p><strong>2.Linux文件系统原理？</strong></p>
<p><strong>3.如果一个文件100行，每行一个单词，怎么统计单词个数？</strong></p>
<p><strong>4.中断是什么，Linux的中断命令？</strong></p>
<p>中断是指CPU在执行程序的过程中，出现了某些突发事件急需处理，CPU暂停当前程序的执行，转去处理突发事件，处理完后又返回原程序被中断的地方继续执行。</p>
<p>Linux的中断命令：<code>ctrl+c</code></p>
<h2 id="8-项目"><a href="#8-项目" class="headerlink" title="8. 项目"></a>8. 项目</h2><p><strong>1.分布式锁？分布式锁除了redis还有其他实现吗？数据库和zookeeper实现？如何实现的说说？</strong></p>
<h2 id="9-SQL编写"><a href="#9-SQL编写" class="headerlink" title="9. SQL编写"></a>9. SQL编写</h2><p><strong>1.写一个SQL查询所有平均成绩大于60的同学？如果不用where student.id=score.id会出现什么？</strong></p>
<p><strong>2.写sql 学生成绩教师三个表、 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</strong></p>
<p><strong>3.写sql 找出语文成绩及格平均成绩不及格的学生姓名语文成绩</strong></p>
<p><code>select student,avg() from student stu join score sco where stu.id=sco.id</code></p>
<p><strong>4.手写sql语句，分组查询</strong></p>
<h2 id="10-智力题"><a href="#10-智力题" class="headerlink" title="10. 智力题"></a>10. 智力题</h2><p><strong>1. 有8个物体，其中有一个物体质量较大，如何两次称出它？</strong></p>
<p>8个物体分为A/B/C三组，A有3个，B有3个，C有两个，先AB称</p>
<ul>
<li>A倾斜的话，表名重物在A，此时取出两个即可知道重的</li>
<li>B等同A情况</li>
<li>如果ab一样不倾斜，表明在C中，此时一对一，可得出</li>
</ul>
<h2 id="11-常见算法题"><a href="#11-常见算法题" class="headerlink" title="11. 常见算法题"></a>11. 常见算法题</h2><p>LeetCode 001. Two Sum<br>LeetCode 015. 3Sum (可能会问 LeetCode 18. 4Sum 思路)<br>LeetCode 020. Valid Parentheses<br>LeetCode 021. Merge Two Sorted Lists<br>LeetCode 025. Reverse Nodes in k-Group<br>LeetCode 053. Maximum Subarray<br>LeetCode 066. Plus One<br>LeetCode 098. Validate Binary Search Tree<br>LeetCode 110. Balanced Binary Tree<br>LeetCode 134. Gas Station<br>LeetCode 136. Single Number<br>LeetCode 137. Single Number II<br>LeetCode 146. LRU Cache（变形题：带有过期时间的 LRU 缓存）<br>LeetCode 206. Reverse Linked List<br>LeetCode 215. Kth Largest Element in an Array<br>LeetCode 232. Implement Queue using Stacks<br>LeetCode 328. Odd Even Linked List<br>LeetCode 415. Add Strings<br>LeetCode 470：rand7() rand10()<br>LeetCode 496. Next Greater Element I（时间复杂度O(n)）<br>LeetCode 716. Max Stack（两个栈实现最大栈，要求 pop，push，get_max 都为O(1)）<br>LeetCode 860. Lemonade Change<br>LeetCode 862. Shortest Subarray with Sum at Least K<br>LeetCode 876. Middle of the Linked List<br>LeetCode 946. Validate Stack Sequences</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>备战面试基础知识-2</title>
    <url>/2020/03/21/%E5%A4%87%E6%88%98%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="备战滴滴面试"><a href="#备战滴滴面试" class="headerlink" title="备战滴滴面试"></a>备战滴滴面试</h2><h3 id="———————————–第一部分———————————–"><a href="#———————————–第一部分———————————–" class="headerlink" title="———————————–第一部分———————————–"></a>———————————–第一部分———————————–</h3><p><strong>1.set map list</strong></p>
<p>常见的HashSet HashMap ArrayList</p>
<p>一般是HashMap和LinkedHashMap，然后就是HashSet的实现。以及ArrayList与LinkedList之间的区别。</p>
<p><strong>2.TreeSet和HashSet对比之间的区别？</strong></p>
<p>一个有序一个无序</p>
<p><strong>3.HashMap和ConcurrentHashMap的区别？</strong></p>
<p>HashMap底层是基于数组+链表+红黑树实现的，ConcurrentHashMap的底层是Node+链表+红黑树来实现的，且并发安全的实现是依赖synchronized+CAS来实现的。</p>
<p><strong>4.线程池的参数有哪些？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,       TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>

<p>corePoolSize核心线程个数，最大的线程个数，线程池中线程存活时间，时间的单位，阻塞队列</p>
<p><strong>5.线程池的拒绝策略？</strong></p>
<p>如果超出了线程池的数量限制大小，此时需要使用到线程池的拒绝策略。被拒绝的理由可能是由于：1.线程池异常关闭，2. 任务数量超过线程池的最大限制</p>
<p>其中在ThrealPoolExecutor构建线程池的时候，底层会调用ThreadPoolExecutor来构建线程池。其中有线程策略handler：</p>
<p>默认的拒绝策略为AbortPolicy</p>
<ul>
<li>AbortPolicy：任务到线程池中被拒绝时，将会抛出RejectedExecutionException异常</li>
<li>DiscardPolicy：拒绝任务的处理程序，静默丢弃被拒绝的任务。</li>
<li>DiscardOldestPolicy：线程池会放弃等待最久的未处理任务，然后将被拒绝的任务添加到等待队列中</li>
<li>CallerRunsPolicy：在线程池当前正在运行的Thread线程池中处理被拒绝的任务</li>
</ul>
<p><strong>5.SynchronizedBlockQueue中到底可以存几个？</strong></p>
<p>存一个，他是一个缓存值为1的阻塞队列，但是IsEmpty()方法永远返回true。remove方法返回false，iterator方法永远返回空，peek方法永远返回null</p>
<p><strong>6.锁用过吗？常见的有哪些锁？</strong></p>
<p>用过，乐观锁，悲观锁，synchronized, reentrantLock, 偏向锁，轻量级锁，自旋锁。重量级锁</p>
<p><strong>7.锁的方法：tryLock，lock, lockInterruptily()</strong></p>
<p>lock的方法不能被外部打断，但是lockInterruptily可以，但是会抛出异常</p>
<p><strong>8.lock和tryLock的区别？</strong></p>
<p>一个是直接锁，一个是尝试获取锁。区别就是直接锁也会去做判断，看看自己是否能获取锁，尝试锁的话就要去判断当前的线程的状态值，看看是否锁被占用或者有可重入锁的机会，如果都没有的话，返回false</p>
<p><strong>10.公平锁与非公平锁的实现有什么区别？</strong></p>
<p>公平锁的话就是直接获取锁，出现了在尝试获取锁的时候如果当前对象没有被上锁，需要先判断队列中自己前面是否有线程，保证按照顺序来。</p>
<p>非公平锁的话，就是在调用lock方法的时候如果没有人上锁，就直接上锁了，不然的话就要去tryAcquire获取锁，这个大家都是争抢锁资源。</p>
<p><strong>11.类加载的机制是怎么样的？</strong></p>
<p>类加载过程：加载—连接（验证、准备、解析）—初始化—使用—卸载</p>
<p><strong>12.tomcat的加载过程？</strong></p>
<p>getServer–getConnector–Server.start–startService–启动Engine–启动host–启动context–启动connector–EndPoint启动</p>
<p><strong>13.Spring的生命周期？Spring的源代码一定要看啊！！！**</strong></p>
<p>Bean的生命周期：创建（调用构造函数）—set方法注入属性–BeanNameAware–BeanFactoryAware–ApplicationContextAware–BeanPostProcessor的before方法–InitializingBean—自定义init方法–BeanPostProcessord的after方法–使用–容器的销毁–DisposableBean的destory–自定义销毁方法。</p>
<p><strong>14.AOP</strong></p>
<p>Spring的AOP是面向切面编程，可以通过切面向类或者方法中插入日志，通知等方法。可以通过BaseSchema实现以及AspectJ或者其注解来实现，主要是通过动态代理技术来实现的，动态代理分为JDK动态代理，能够代理实现了其接口的类。还有就是cglib代理，通过字节码构造这个类的一个实例对象进行代理。静态代理和动态代理的区别，静态代理只能代理实现了其接口的一个类，且静态代理在代理之前就知道了代理对象，而动态代理是在运行过程中才知道代理的对象。{jdk动态代理的实现主要是实现了InnovationHandler接口，重写其中的invoke方法来调用。而CGLIB动态代理的话是通过实现接口MethodInterceptor重写intercept方法来实现代理，其中是通过字节码来动态的构建代理对象的子类重写其方法来实现的}</p>
<p><strong>15.ASM怎么实现AOP？</strong></p>
<p>ASM是一个Java字节码操纵框架，能够被用来动态生成类或者增强其持有类的功能。ASM可以直接产生二进制class文件，也可以在类被加载进Java虚拟机之前就动态改变类的行为，Java class被存储在严格格式定义的.class文件中，这些类文件拥有足够的源数据来解析出类中所有元素：类名称、方法、属性以及Java字节码。ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p>
<p><strong>16.MyBatis的插件？</strong></p>
<p>pageHelper，但是一般用的都是MyBatisPlus</p>
<p><strong>17.项目：自己在自己的项目中干了什么？从项目中学习到了什么？复盘自己的项目</strong></p>
<p>首先是在工作中，暑期实习的地方是做电商的B2b，记忆深一点的就是当时做的活动模块，大致的环境配置就是使用SpringBoot来搭建开发的，主要有使用到的的技术有spring,springmvc,redis,mybatis,mysql,等等，使用postman作为测试组件来测试代码的功能完整性。对于在测试环境下的出现的代码错误，会通过linux查看具体错误的心底，定位到具体的错误代码。</p>
<p>在项目java高并发秒杀系统中，主要使用的SSM搭建的环境开发框架，其中使用到了redis做后端的缓存，因为项目不是太大，在慕课网上看的，所以用到的技术不是很多，这个项目分成三个部分，前端模块，后端模块，数据库模块，在这之中的话，因为是高并发项目，所以前端的优化是使用 CDN内容分发网络（Content Delivery Network）将前端的静态资源存储减少并发，同时对于用户多点对于后台造成的并发，使用前端点击之后按钮变灰，对于用户多次刷新页面的可以采用拦截，限制某个账户访问的次数。同时还可以使用中间件例如消息队列，来将高峰时期的请求都存入消息队列中，后端根据自己的处理能力从消息队列中获取请求然后处理。数据库层面的话，如果都直接访问mysql数据库的话，数据库可能会崩掉，可以采用redis对数据库中的部分数据做一个缓存，这样的话可以适当减小数据库的压力，或者使用redis来保存数据库中的数据，在redis中进行相应的数据操作，最后将redis中的数据同步至mysql数据库中即可。</p>
<p><strong>18.数据库中的隔离级别有什么用？</strong></p>
<p>解决数据库<strong>并发</strong>操作中可能出现的脏读，幻读等问题</p>
<p><strong>19.隔离级别什么时候起作用呢？</strong></p>
<p>事务对数据库中的数据进行操作的时候起作用</p>
<hr>
<h3 id="———————————–第二部分———————————–"><a href="#———————————–第二部分———————————–" class="headerlink" title="———————————–第二部分———————————–"></a>———————————–第二部分———————————–</h3><p><strong>1.数据库的索引类型？</strong></p>
<p>唯一索引，聚簇索引，非聚簇索引</p>
<p><strong>2.聚簇索引和非聚簇索引的区别？</strong></p>
<p>在实现上面，都是使用的B+数实现的，但是实现的方式却不同，聚簇索引的话是节点中存储数据索引（键和指针），所有的数据都存储在叶子节点中，比如说一张数据表吧，聚簇索引主索引使用的是主键Row，辅助索引使用的是key+PK cols，也就是找到了当前的辅助索引之后还需要再根据主键来查找，需要查找两次。叶子节点之间通过构成单向链表，适合范围查询</p>
<p>非聚簇索引的话，是每个节点都存储数据索引与数据，主索引使用的是pkcols + rowNumber，辅助索引使用的是key+rowNumber，也就是只需要查一遍。无论是主索引还是从索引，都可以直接定位到数据。</p>
<p><strong>3.二叉树和B+树的区别？</strong></p>
<ul>
<li>B+树所有的数据都是存储在叶子节点上，每次的查找时间稳定</li>
<li>叶子节点都有指向下一个节点的指针，范围查找比较方便</li>
</ul>
<p><strong>4.如果说二叉树的数据都存储在叶子节点上呢？</strong></p>
<p>会线性化成链表</p>
<p><strong>5.平衡二叉树呢？</strong></p>
<p>B+数可以减少磁盘IO次数，如何减少IO次数呢。通过减少构造的树的高度来，B树的高度比平衡二叉树的高度要低，本来是效率更快，但是由于B树对于每一个节点需要比较多次，所以一般来说B树的效率和平衡二叉树是差不多的！</p>
<p>且B树相对于B+树而言，B+树的效率更高磁盘IO更少，因为B+数的data中不存储数据，所以可以存放更多的key，查找肯定更快。一个索引节点只需要一次IO即可</p>
<p><strong>6.磁盘中的文件都是使用B+树格式存储的吗？</strong></p>
<p><strong>7.磁盘怎么存储这些数据？</strong></p>
<p><strong>8.了解哪些文件格式？</strong></p>
<p><strong>9.linux操作系统了解吗？</strong></p>
<p><strong>了解，了解一些它常用的命令。</strong></p>
<p><strong>10.相关的命令用过哪些？</strong></p>
<p>ps -ef/grep/cat/find/netstat -tunpl/-a（表示列出当前网络所有的连接）/vim/tail -f查看日志/tar zxvf 解压缩</p>
<p><strong>11.linux根目录下有哪些文件夹</strong></p>
<p>/etc/bin/var/usr/home/opt/proc/sbin/root</p>
<p><strong>12.手撕翻转二叉树</strong></p>
<p><strong>13.最小路径和</strong></p>
<h3 id="———————————–第三部分———————————–"><a href="#———————————–第三部分———————————–" class="headerlink" title="———————————–第三部分———————————–"></a>———————————–第三部分———————————–</h3><p><strong>1.开源项目了解哪些？</strong></p>
<p>SpringBoot，SpringCloud</p>
<p>2.SpringBoot如何加载源码？</p>
<p>==<strong>待补充</strong>==</p>
<p><strong>3.源码是如何深入学习的？</strong></p>
<p>一般是通过看博客，自己跟着看源码。</p>
<p><strong>4.Spring的启动过程如何了解？</strong></p>
<p>通过Debug的方式来看在启动中都执行了哪些操作</p>
<p><strong>5.tomcat启动的流程，需要加载哪些资源？</strong></p>
<p>getServer–getConnector–Server.start–startService–启动Engine–启动host–启动context–启动connector–EndPoint启动，需要加载服务器资源，连接器资源，host资源，上下文资源，加载web.xml中设置的监听器，过滤器，servlet</p>
<p><strong>6.项目中的收获？</strong></p>
<p><strong>7.负责项目中的哪些点，技术方向的？</strong></p>
<p><strong>8.为什么使用MVC架构？</strong></p>
<p>主要是因为MVC的优点，具有低耦合性，高重用性以及可适用性。拥有较低的生命周期成本，快速的部署，好维护，有利于软件工程化管理。</p>
<p><strong>9.项目中的事务如何实现？</strong></p>
<p>通过加@Transactional注解来实现。</p>
<p><strong>10.事务注解底层是怎么实现的？以及为什么加了这个注解可以实现事务？</strong></p>
<p><strong>源码…..待补充!</strong></p>
<p><strong>11.这个事务和数据库事务的区别？</strong></p>
<p>本质上是一样的，Spring的事务就是对数据库事务的封装，最后本质的实现还是在数据库中实现的，假如数据库不支持事务的话，Spring中的事务是没有任何作用的。数据库的事务简单来说就是开启，回滚和关闭，Spring对数据库事务的包装，原理就是拿一个连接，根据Spring的事务配置，操作这个数据连接对数据库进行事务开启，回滚或者关闭操作。但是Spring除了实现这些功能之外，还配合Spring的传播行为对事务进行了广泛的管理，事务中涉及的隔离级别，以及Spring如何对数据库的隔离级别进行封装，事务与隔离级别放在一起会好理解一点。</p>
<p><strong>12.mybatis你用的是什么数据库连接池c3p0？</strong></p>
<p><strong>13.你还知道其他的数据库连接池吗？</strong></p>
<p>DBCP：依赖Jakarta commons-pool对象池机制的数据库连接池，DBCP可以直接在应用程序中使用，Tomcat中的数据源就是使用的DBCP</p>
<p>c3p0：是一个开源的JDBC连接池，它在lib目录下和Hibernate一起发布，包括实现jdbc3和jdbc2扩展规范说明的Connnection和Statement池的Datasources对象</p>
<p>Durid：阿里出品，淘宝和支付宝专用数据库连接池。Druid的功能十分强大。</p>
<p><strong>14.数据库连接池的功能有哪些？</strong></p>
<ul>
<li>资源重用</li>
<li>更快的系统响应速度</li>
<li>新的资源分配手段</li>
<li>统一的连接管理</li>
<li>避免数据库连接池泄露</li>
</ul>
<p><strong>15.JUC看过哪些，说下AQS实现的机制？</strong></p>
<p>看过Atomic，AQS下的一些类，AQS实现机制。他主要是同步器和锁机制的构建框架。使用AQS能简单高效地构造出应用广泛的大量的同步器。ReentrantLock，Semaphore都是基于AQS。</p>
<p>AQS核心的思想就是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作县策划稿，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS使用CLH队列锁来实现的，即将暂时获取不到锁的线程加入队列中。</p>
<p><strong>16.公平锁与非公平锁的区别？</strong></p>
<p>这个就是一个是按照顺序的，一个不是按照顺序的，这个在尝试获取锁的代码是不同的，公平锁，会先查询队列中是否前面还有节点，而非公平锁不查直接过去锁。</p>
<p><strong>17.lock如何分配线程锁？</strong></p>
<p>看情况而定！没有人占有锁自己就获取锁，如果有人占有锁，看看是不是自己，是的话就重入，如果不是就返回false，获取锁失败。</p>
<p><strong>18.队列呢？了解哪些？</strong></p>
<ul>
<li>ConcurrentLinkedQueue：基础链表同步队列。</li>
<li>LinkedBlockingQueue：阻塞队列，队列容量不足自动阻塞，队列容量为0时自动阻塞</li>
<li>ArrayBlockingQueue：底层数组实现的有界队列，自动阻塞，根据API（add/put/offer）不同，有不同特定，当容量不足的时候，有阻塞能力，add方法在容量不足的时候，能够抛出异常。put方法在容量不足的时候，阻塞等待。offer方法，单参数offer方法不阻塞，容量不足的时候，返回false，当前新增数据操作放弃。三参数offer方法（offer(value,times,timeunit)），容量不足的时候，阻塞times时长，如果在阻塞时长内，有容量空闲，新增数据返回true，如果阻塞时长范围内，无容量空闲，放弃新增数据，返回false。</li>
<li>DelayQueue：延时队列，根据比较机制，实现自定义处理顺序的队列，常用于定时任务。如定时关机，对于缓存超时的数据进行删除，任务超时处理，空闲连接的关闭</li>
<li>LinkedTransferQueue：转移队列，使用transfer方法，实现数据的即时处理。没有消费者就阻塞。</li>
<li>SynchronusQueue：同步队列，是一个容量为0的队列。是一个特殊的TransferQueue。必须现有消费线程等待才可以使用。add方法，无阻塞，若没有消费线程阻塞等待数据，则抛出异常。put方法，有阻塞，若没有消费线程阻塞等待数据，则阻塞。（游戏匹配）</li>
</ul>
<p><strong>19.添加的方法都有哪些？具体讲讲？</strong></p>
<p>add offer put方法</p>
<p><strong>20.各个队列的使用场景：</strong></p>
<p><strong>这一块的东西要实践！</strong></p>
<p><strong>21.JVM看过什么？JVM的常用命令？</strong></p>
<p><font color="red">JVM看过深入理解java虚拟机。常用命令。jstat？如果看一个线程内存回收情况，如何看？</font></p>
<p><strong>22.JVM的类加载解析？如何解析到字节码？</strong></p>
<p><strong>待补充</strong></p>
<p><strong>23.如何验证jdk版本的冲突？jdk.1.6-&gt;1.7</strong></p>
<p><strong>24.类加载器的初始化如何去做？</strong></p>
<p><strong>25.实际运用中的classLoader都有哪些了解？</strong></p>
<p><strong>26.如何实现动态加载，需要使用哪些方法？继承classLoader类，重写findClass方法，调用defineClass方法</strong></p>
<p><strong>27.如何获取当前类的classLoader？</strong></p>
<p><strong>使用getClassLoader方法</strong></p>
<p><strong>28.如何保持建立多个ClassLoader</strong></p>
<p><strong>29.为什么类加载器加载出来的类不一样？</strong></p>
<p>因为每个加载器都有自己的隔离机制</p>
<p><strong>30.jvm的内存模型？</strong></p>
<p>程序计数器，虚拟机栈，本地方法栈，堆，方法区，常量池</p>
<p><strong>31.多线程如何实现主存同步的？</strong></p>
<p>synchronized关键字或者使用锁lock</p>
<p><strong>32.linux通过什么命令去使其他工作内存无效呢？</strong></p>
<p><strong>待补充，没听过的知识点</strong></p>
<p><strong>33.java如何是实现缓存一致性？</strong></p>
<p>volatile，synchronized，lock，wait/notify</p>
<p><strong>34.jvm的锁优化有哪些？</strong></p>
<p>synchronized互斥的重量级锁。（作用：确保线程互斥的访问代码，保证共享变量的修改能够及时可见，可以阻止jvm的指令重排）锁优化的话，采用了锁粗化，锁消除，适应性自旋。不存在多线程竞争，默认是偏向锁。轻量级锁，过渡锁，一般是偏向锁不满足，有多线程并发访问锁定同一个对象的时候，先提升为轻量级锁。只有两个线程争抢锁标记记录的时候，优先使用轻量级锁。适应性自旋，在轻量级锁获取失败的时候，为了避免线程在真实的系统层面被挂起，还会进行一项为自旋锁的优化手段。</p>
<p>锁粗化：一般在使用锁的时候，需要让同步的作用范围尽可能的小，仅在共享数据的操作中才进行。这样做的目的，是为了让同步操作的数量尽可能的小，如果出现锁的竞争，也能尽快的获取锁。但是如果遇到已连续的lock和unlock的操作，会导致性能的不必要损耗。<strong>锁粗化就是将连续的同步操作连在一起，粗化为一个范围更大的锁。</strong>锁消除：所消除是jvm进行的另外一项锁优化，该优化更加的彻底。jvm在进行<em>JIT</em>编译(just-in-time compilation)的时候，通过对上下文的扫描，<strong>JVM检测到不可能存在共享数据的晶振，如果这些资源有锁，就会消除这些资源的锁。可以节省毫无意义的锁请求时间</strong>。锁消除的依据，是逃逸分析的数据支持。</p>
<p><strong>35.网络编程了解多少？TCP、UDP，如何创建网络之间的通信？</strong></p>
<p>udp直接就是创建数据报的DatagramSocket通信即可。传输也是使用DatagramPacket来接收</p>
<p>tcp的话需要使用同一个接口来是的数据的传递是可靠的，服务器端使用的是阻塞式的接收客户端的连接。连接之后获取客户端的发送的数据流，将流读出来即可。</p>
<p><strong>36.java的IO了解吗？他们有什么区别？</strong></p>
<p>javaIo主要分为InputStream、OutputStream和Reader、Writer。他们的区别是Stream结尾的都是用来读取字节流，Reader结尾的都是用来读取字符流。</p>
<p><strong>37.BIO、NIO、AIO响应的类了解吗？</strong></p>
<p>BiO：Blocking IO 同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善</p>
<p>NIO：UNblocking IO 同步非阻塞编程，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都不能会被注册到多路复用器上面，多路复用器轮询到连接有IO请求时才启动一个下线程进行处理。</p>
<p>AIO：Asychronous IO：异步非阻塞IO，可以理解为read/write方法都是异步的，完成后会主动调用回调函数。服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>38.shell命令</strong></p>
<p>ls ll  cd pwd mkdir rmdir  cp mv rm du df cat echo head tail wc grep man logout </p>
<p><strong>39.进程的通信方式？</strong></p>
<p>管道、信号量、消息队列、套接字socket</p>
<p><strong>40.Linux的调度方式？</strong></p>
<p>调度机制分为抢占式内核和非抢占式内核。</p>
<p><strong>41.linux的缓存有几级？</strong></p>
<p><strong>待补充</strong></p>
<p><strong>42.jdbc连接mysql的几个步骤，以及如何读取数据，如何实现statement？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedMySQLTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClassName = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/407?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"cao236476"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; className = Class.forName(driverClassName);<span class="comment">// 加载mysql的驱动</span></span><br><span class="line">            Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            Statement statement = connection.createStatement(); // 这个是先产生statement，然后载入sql语句</span></span><br><span class="line">            String sql = <span class="string">"select * from test_user"</span>;</span><br><span class="line">            PreparedStatement statement = connection.prepareStatement(sql);<span class="comment">// 这个必须和sql语句同时载入</span></span><br><span class="line"></span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">            List&lt;User&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                lists.add(<span class="keyword">new</span> User(resultSet.getInt(<span class="string">"id"</span>),</span><br><span class="line">                        resultSet.getString(<span class="string">"name"</span>),</span><br><span class="line">                        resultSet.getInt(<span class="string">"age"</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (User list : lists) &#123;</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet.close();</span><br><span class="line">            statement.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="———————————–第四部分———————————–"><a href="#———————————–第四部分———————————–" class="headerlink" title="———————————–第四部分———————————–"></a>———————————–第四部分———————————–</h3><p><strong>1.字节流和字符流的区别</strong></p>
<p>字节流读取单个字节，字符流读取单个字符。字节流来处理二进制文件（图片，MP3，视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。字节是给计算机看的，字符是给人看的。</p>
<p><strong>2.死锁的四个条件</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求和保持条件：一个进程因为请求资源而被阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源在没有释放之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成了一种头尾相连的循环等待资源关系。</li>
</ol>
<p>解除死锁的方法：</p>
<ol>
<li>剥夺资源：从其他进程剥夺足够数量的资源给死锁线程，以解除死锁状态</li>
<li>撤销进程：可以直接撤销死锁进程或者撤销代价最小的进程，直至有足够的资源可用</li>
</ol>
<p>3.给1G的数据，内存限制为100M，怎么排序？</p>
<p>首先不能选择内存排序，需要选择外存排序，使用多路归并的思路，把数据分为N部分，每部分100M，在使用内存来排序，将排序结果使用外存记录，然后每次从外存冲取记录，在内存中进行比较，从而获取排序的结果。</p>
<p>4.CDN是什么，能谈一谈吗？</p>
<p>CDN是content distribute network，内容分发网络，应用了HTTP协议中的缓存和代理技术，代替源站响应客户端的请求。CDN是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发、调度等功能模块，使用户就近获取所需的内容，降低网络阻塞，提高用户访问响应速度和命中率。CDN中的关键技术有内容存储和分发技术。</p>
<p>5.PUT和POST的区别？</p>
<p>PUT具有幂等性，幂等性是指一次和多次请求同一个资源对于资源本身应该具有同样的结果。即任意多次执行对资源本身所产生的应该与一次执行产生的影响相同。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
