<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试项目准备</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h2 id="1-秒杀中如何解决商品超卖问题"><a href="#1-秒杀中如何解决商品超卖问题" class="headerlink" title="1. 秒杀中如何解决商品超卖问题"></a>1. 秒杀中如何解决商品超卖问题</h2><p>首先面对高并发问题，前端常用 扩容，静态化（CDN），限流来解决（采用Ip级别的限流，或者活动入口增加小游戏或者问题环节削峰处理）。</p>
<p>后端的话主要是减库存操作。多个用户同时操作MySQL数据库的话很容易导致出现负数的情况。</p>
<p>当减库存和高并发操作碰到一起，由于操作的库存数量是同一行，就会出现争抢InnoDB行级锁的问题，导致相互等待甚至死锁，从而大大降低了MySQL的处理性能，最终导致前端页面出现异常。</p>
<p>操作代码使用<code>update number set x = x-1 where (x-1) &gt; 0</code>，这种只能减少超卖的数量，不能完全避免超卖。</p>
<p>解决方案1：</p>
<p>将库存从MySQL迁移到redis中，将所有的写操作放在内存中，由于redis不存在锁所以不会出现互相等待，并且有redis的写性能和读性能远远高于MySQL，这就解决了高并发下的性能问题。然后通过队列一步手段，将变化的数据异步写入到DB中</p>
<p>优点：解决了性能问题</p>
<p>缺点：没有解决超卖的问题，同时由于异步写入DB，在某一时刻会导致Db和redis数据不一致的风险。</p>
<p>解决方案2：</p>
<p>引入队列，然后将所有Db操作在单队列中排队，完全串行处理。当达到库存阈值的时候就不存在消费队列，并关闭购买功能。这就解决了超卖问题。</p>
<p>优点：解决了超卖问题，略微提升性能。</p>
<p>缺点：性能受限队列处理性能和DB写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。</p>
<p>解决方案3:</p>
<p>将写操作迁移到Memcached中，同时利用Memcached的轻量级的锁机制CAS来实现减库存操作。</p>
<p>优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存操作。</p>
<p>缺点：没有实测。</p>
<p>解决方案4：</p>
<p>将提交操作成两段式操作，先申请后操作，然后利用redis的原子自增操作（相比较MySQL的自增来说没有空洞），同时利用Redis的事务特性来发号，保证拿到小于等于库存阈值的号的人都可以成功提交订单。然后数据异步写入DB</p>
<p>优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。</p>
<p>缺点：由于异步写入DB，可能造成数据不一致问题出现，另外可能存在少买。也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单并没有达到库存阈值。</p>
<h2 id="2-优化方案"><a href="#2-优化方案" class="headerlink" title="2. 优化方案"></a>2. 优化方案</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><strong>方向：将请求尽量拦截在系统上游，进来的时候使用Nginx负载均衡，对于承受不住的直接返回，不进行处理。</strong></p>
<p><strong>限流和削峰</strong></p>
<p>限流，屏蔽掉无用的流量，前端要做按键置灰操作，一个用户不能多次请求。</p>
<p>削峰，瞬间大流量的话容易压垮系统，此时可以采用异步处理，缓存和消息中间件。异步处理感觉挺难实现，一般使用缓存和消息中间件。秒杀本身是读多写少。因为是秒杀，实际操作减库存的人不多。</p>
<p>消息队列可以实现削峰，将拦截大量的并发请求，是异步处理的，先进入消息队列，后台从消息队列中主动拉取处理。</p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端的话首先需要做页面静态化，页面存在html，动态数据是接口从服务器中获取，实现前后端分离。静态页面只有第一次请求的时候加载。</p>
<p>或者使用CDN缓存静态资源，加载快。</p>
<p>利用缓存，使用令牌桶算法实现限流。（桶里发令牌，如果没有令牌，拒绝执行任务。直接打回去）</p>
<p>秒杀业务放在高配服务器上，采用消息队列缓存请求，利用缓存应对读请求，利用缓存应对写请求（redis的写操作）</p>
<p><strong>方案</strong></p>
<p>秒杀阶段的时候使用本地标记对用户秒杀过的商品做标记，若被标记过直接返回重复秒杀，未被标记查询redis，通过本地标记减少对redis的访问</p>
<p>抢购开始，将商品和库存数据同步到redis中，所有的抢购操作都在redis中进行处理，通过redis预减少库存，减少对数据库的访问。</p>
<p>为了保护系统不受高流量的冲击而导致系统崩溃，使用MQ消息队列进行异步处理下单，实际做了一层缓冲保护层。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer刷题</title>
    <url>/2020/03/22/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring之Bean的生命周期学习</title>
    <url>/2020/03/22/Spring%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p><strong>Bean创建===&gt;初始化===&gt;销毁</strong></p>
<h2 id="1-Bean指定初始化和销毁方法"><a href="#1-Bean指定初始化和销毁方法" class="headerlink" title="1. @Bean指定初始化和销毁方法"></a>1. @Bean指定初始化和销毁方法</h2><p>构造(对象创建)：</p>
<ul>
<li>单实例：在容器启动的时候创建对象</li>
<li>多实例：在每次获取的时候创建对象</li>
</ul>
<p>初始化：</p>
<ul>
<li>对象创建完成，并赋值好，调用初始化方法</li>
</ul>
<p>销毁：</p>
<ul>
<li>单实例：容器关闭的时候销毁</li>
<li>多实例：容器不会管理这个bean，容器不会调用销毁方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Bean的含义就是意味着当前的方法可以生产一个被Spring容器管理的实例对象</span></span><br><span class="line">    <span class="comment">// @Scope("prototype") 多实例</span></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建IOC容器</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"容器创建完成!"</span>);</span><br><span class="line">        <span class="comment">// 多实例的时候只有使用的时候才会加载</span></span><br><span class="line">        <span class="comment">// applicationContext.getBean("car");</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Bean使用InitializingBean和DisposableBean"><a href="#2-Bean使用InitializingBean和DisposableBean" class="headerlink" title="2. @Bean使用InitializingBean和DisposableBean"></a>2. @Bean使用InitializingBean和DisposableBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat destroy...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用@Component标签的话，需要使用@ComponentScan标签来将此类注入。</p>
<h2 id="2-PostConstruct和-PreDestory"><a href="#2-PostConstruct和-PreDestory" class="headerlink" title="2. @PostConstruct和@PreDestory"></a>2. @PostConstruct和@PreDestory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog constructor...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象创建并赋值之后使用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog...@PostConstruct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除之后给的反馈信号</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog...@PreDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-BeanPostProcessor"><a href="#4-BeanPostProcessor" class="headerlink" title="4. @BeanPostProcessor"></a>4. @BeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postProcessBeforeInitialization()  <span class="comment">// 在初始化调用之前</span></span><br><span class="line">postProcessAfterInitialization()   <span class="comment">// 在初始化调用之后</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBeforeInitialization...."</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfterInitialization...."</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个方法是在类的初始化前后进行作用。</p>
<h2 id="5-BeanPostProcessor原理"><a href="#5-BeanPostProcessor原理" class="headerlink" title="5. BeanPostProcessor原理"></a>5. BeanPostProcessor原理</h2><p>源码断点Debug</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 给Bean属性赋值</span></span><br><span class="line">initializeBean(beanName, exposedObject, mbd); <span class="comment">// 初始化Bean</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// Bean初始化之前调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// 执行自定义初始化</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// Bean初始化之后调用</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Spring底层对BeanPostProcessor的使用"><a href="#6-Spring底层对BeanPostProcessor的使用" class="headerlink" title="6. Spring底层对BeanPostProcessor的使用"></a>6. Spring底层对BeanPostProcessor的使用</h2><p>Bean赋值，属性注入，@AutoWired注解，生命周期注解功能，@Async，xxx，都是由BeanPostProcessor来完成的。</p>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>面试相关技巧掌握学习</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="1-面试的三层架构"><a href="#1-面试的三层架构" class="headerlink" title="1. 面试的三层架构"></a>1. 面试的三层架构</h2><ul>
<li>首轮：面试技术基本功</li>
<li>次轮：架构设计，通过技术解决某些场景下的问题</li>
<li>末轮：稳定性以及未来规划，压工资（可能会）</li>
</ul>
<h2 id="2-备战心仪公司"><a href="#2-备战心仪公司" class="headerlink" title="2. 备战心仪公司"></a>2. 备战心仪公司</h2><ul>
<li><p>认真研究职位要求，提炼出特别需要准备的知识点</p>
</li>
<li><p>主要是针对岗位JD的描述提炼出知识点</p>
</li>
<li><p>通过内部人士打听团队所做的项目的信息，重点备战这些知识点</p>
</li>
</ul>
<h2 id="3-面试中项目介绍如何表达比较好"><a href="#3-面试中项目介绍如何表达比较好" class="headerlink" title="3. 面试中项目介绍如何表达比较好"></a>3. 面试中项目介绍如何表达比较好</h2><p><strong><font color="red">属于面试中的重点，前几天的面试，感觉自己项目介绍的不太好，面试官感觉不是太好，有减分。</font></strong></p>
<ul>
<li>站在码农的角度介绍项目，专注技术指标以及解决思路</li>
<li>自信，脉路要清晰：项目用途-&gt;自己的角色-&gt;如何解决难题</li>
<li>项目如果找不到难点，则谈谈改进，前提是熟悉相关设计的知识点</li>
<li>事前用图形将你的项目勾画清楚(细节不是很重要，但是自己需要掌握，表达出大致模块即可，问到再说细节)</li>
</ul>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>准备面试的过程中，技巧也是很重要的一个部分，虽然能力重要，但是展示出你的能力更加重要，有很多时候面试感觉很糟不是因为我们能力不够，而是因为我们能够展现出来的能力没有机会展示出来，最后面试结果不理想。</p>
<p>面试之前的准备，有技巧的准备很重要，基础知识、算法、项目三大主力面试集需要重点抓牢。</p>
<blockquote>
<p>Keep thinking，Keep coding！加油~</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见SQL语句</title>
    <url>/2020/03/22/%E9%9D%A2%E8%AF%95SQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1-SQL基本语法"><a href="#1-SQL基本语法" class="headerlink" title="1. SQL基本语法"></a>1. SQL基本语法</h2><p><strong>关键语法：</strong></p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT，SUM，MAX，MIN，AVG</li>
</ul>
<p><strong>GROUP BY</strong></p>
<ul>
<li>满足“SELECT子句中的列名必须为分组列或列函数”</li>
<li>列函数对于group by子句定义的每个组各返回一个结果</li>
</ul>
<p><strong>HAVING</strong></p>
<ul>
<li>通常与GROUP BY子句一起使用</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一SQL中的顺序：where&gt;group by&gt;having</li>
<li>如果SQL语句中group by，可以使用having代替where</li>
</ul>
<h2 id="2-SQL语句练习"><a href="#2-SQL语句练习" class="headerlink" title="2. SQL语句练习"></a>2. SQL语句练习</h2><p>三张表</p>
<p><code>student</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`student`</span>(</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="string">'0'</span>,</span><br><span class="line">primary <span class="keyword">key</span> (<span class="string">`student_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">10</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><code>course</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`score`</span>(</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line"><span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><code>score</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`course`</span>(</span><br><span class="line"><span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="string">`course_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">5</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>插入的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'zs'</span>,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'ls'</span>,<span class="number">23</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">'ww'</span>,<span class="number">26</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span></span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"语文"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"数学"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"英语"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score <span class="keyword">values</span></span><br><span class="line">(<span class="number">10</span>,<span class="number">5</span>,<span class="number">70</span>),(<span class="number">10</span>,<span class="number">6</span>,<span class="number">50</span>),(<span class="number">10</span>,<span class="number">7</span>,<span class="number">56</span>),(<span class="number">10</span>,<span class="number">8</span>,<span class="number">80</span>),(<span class="number">11</span>,<span class="number">5</span>,<span class="number">50</span>),(<span class="number">11</span>,<span class="number">6</span>,<span class="number">60</span>),(<span class="number">11</span>,<span class="number">7</span>,<span class="number">61</span>),(<span class="number">12</span>,<span class="number">6</span>,<span class="number">30</span>),(<span class="number">12</span>,<span class="number">7</span>,<span class="number">55</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-面试常见问题"><a href="#3-面试常见问题" class="headerlink" title="3. 面试常见问题"></a>3. 面试常见问题</h2><h3 id="3-1-查询所有同学的学号、选课数、总成绩"><a href="#3-1-查询所有同学的学号、选课数、总成绩" class="headerlink" title="3.1 查询所有同学的学号、选课数、总成绩"></a>3.1 查询所有同学的学号、选课数、总成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：当前的sql语句需要实现的是查询所有同学的信息，所以需要以同学为分组。其次选课数，COUNT函数，总成绩SUM函数。</p>
<p>GROUP BY的话相当于以当前分组的对象为一个A，一个学生id会对应着多门课程，如果以学生为分组的话，此时所使用的函数会将分组中的多门课程进行一个类似于聚合的操作。</p>
</blockquote>
<h3 id="3-2-查询所有同学的学号、姓名、选课数、总成绩"><a href="#3-2-查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="3.2 查询所有同学的学号、姓名、选课数、总成绩"></a>3.2 查询所有同学的学号、姓名、选课数、总成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.student_id,stu.name,<span class="keyword">count</span>(s.course_id),<span class="keyword">sum</span>(s.score)</span><br><span class="line"><span class="keyword">from</span> student stu,score s</span><br><span class="line"><span class="keyword">where</span> stu.student_id = s.student_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.student_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：因为姓名这个属性在score这张表中没有，所以此时需要使用联合student这张表，通过id作为一个联合的中间节点查询到</p>
</blockquote>
<h3 id="3-3-查询平均成绩大于60分的同学的学号和平均成绩"><a href="#3-3-查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="3.3 查询平均成绩大于60分的同学的学号和平均成绩"></a>3.3 查询平均成绩大于60分的同学的学号和平均成绩</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id, <span class="keyword">avg</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(score) &gt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 附加一点，HAVING可以代理where关键字，前提是没有使用group by</span></span><br><span class="line"><span class="comment">-- 获取id为10的学生的所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">having</span> student_id = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：同样还是id为分组，此时多出了成绩大于60这个条件，HAVING是用来过滤分组的，所以此时需要使用到HAVING这个关键字来过滤查询到的结果</p>
</blockquote>
<h3 id="3-4-查询没有学全所有课的同学的学号、姓名"><a href="#3-4-查询没有学全所有课的同学的学号、姓名" class="headerlink" title="3.4 查询没有学全所有课的同学的学号、姓名"></a>3.4 查询没有学全所有课的同学的学号、姓名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> stu.student_id, stu.name</span><br><span class="line"><span class="keyword">from</span> student stu, score s</span><br><span class="line"><span class="keyword">where</span> stu.student_id = s.student_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> stu.student_id</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line"><span class="keyword">count</span>(*) &lt; (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：学全所有课只需要看当前学生的课程id是否小于course中的总课程即可。姓名的话依旧是根据两表联查。</p>
</blockquote>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>SQL语句的话一般是问上述的相关问题，但不一定是保证问这些，尽量多练习，可以保证在面试中对于SQL语句的考察一次性通过。</p>
<blockquote>
<p>Keep thinking，keep coding！</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习(未完待续)</title>
    <url>/2020/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统学习"><a href="#操作系统学习" class="headerlink" title="操作系统学习"></a>操作系统学习</h1><h1 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h1><h2 id="1-分页和分段有什么区别？"><a href="#1-分页和分段有什么区别？" class="headerlink" title="1. 分页和分段有什么区别？"></a>1. 分页和分段有什么区别？</h2><h3 id="1-1-页式存储"><a href="#1-1-页式存储" class="headerlink" title="1.1 页式存储"></a>1.1 页式存储</h3><p>用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配内存时以页为单位，按照进程需要的页数分配，逻辑上相邻的页，物理上不一定相邻。原因是逻辑上是连续的，而物理上不一定是连续的。(物理内存被分为大小相等的帧)</p>
<p>页帧：把物理地址空间划分为大小相同的基本分配单位。大小为2的n次方。</p>
<p>页面：把逻辑地址空间划分为相同大小的基本分配单位。</p>
<p>页：进程逻辑地址空间被划分成大小相等的页。</p>
<p>页面到页帧：逻辑地址到物理地址的转换。</p>
<p><strong>页式存储中的地址映射</strong></p>
<ul>
<li>页到帧的映射（逻辑地址到物理地址的映射）</li>
<li>逻辑地址中的页号是连续的</li>
<li>物理地址中的页号是不连续的</li>
<li>不是所有的页都有页帧（缺页的情况，后面会介绍，虚拟内存技术）</li>
</ul>
<p><font color="red">页表page table</font>保存了逻辑地址-物理地址之间的映射关系。</p>
<p><strong>页式存储管理机制的性能问题</strong></p>
<ul>
<li><p>内存访问性能问题</p>
<ul>
<li>访问一个内存单元需要2次内存访问</li>
<li>第一次访问：获取页表项</li>
<li>第二次访问：访问数据</li>
</ul>
</li>
<li><p>页表大小问题</p>
<ul>
<li>页表可能非常大</li>
</ul>
</li>
</ul>
<p>处理办法：缓存？间接访问？</p>
<ul>
<li>块表（Translation Look-aside Buffer，TLB）<ul>
<li>缓存近期访问的页表项目</li>
</ul>
</li>
<li>多级页表<ul>
<li>通过间接引用将页号分为k级</li>
<li>建立页表“树”</li>
<li>减少每级页表的长度</li>
</ul>
</li>
</ul>
<h3 id="1-2-段式存储"><a href="#1-2-段式存储" class="headerlink" title="1.2 段式存储"></a>1.2 段式存储</h3><p>用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态的划分成长度不同的区域，分配时以段位单位，每段在内存中占据连续空间，各段可以不相邻。</p>
<h3 id="1-3-段页式存储"><a href="#1-3-段页式存储" class="headerlink" title="1.3 段页式存储"></a>1.3 段页式存储</h3><p>用户进程先按照段划分，段内按照页划分，内存划分和分配按照页</p>
<p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。</p>
<p>在段式存储管理基础上，给每个段加一级页表。通过指向相同的页表基址，实现进程间的段共享</p>
<h3 id="1-4-区别"><a href="#1-4-区别" class="headerlink" title="1.4 区别"></a>1.4 区别</h3><ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定</li>
<li>地址空间维度不同：分段是二维空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多个页表，通过一个逻辑地址就能找到对应的物理地址）</li>
<li>分段便于信息的保护和共享；分页的共享受到限制</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（页没有填满）</li>
</ul>
<h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2. 虚拟内存"></a>2. 虚拟内存</h2><h3 id="2-0-虚拟内存的目标"><a href="#2-0-虚拟内存的目标" class="headerlink" title="2.0 虚拟内存的目标"></a>2.0 虚拟内存的目标</h3><ul>
<li>只把部分程序放到内存中，从而运行比物理内存大的程序<ul>
<li>由操作系统自动完成，无需程序员的干涉</li>
</ul>
</li>
<li>实现进程在内存和外存之间的交换，从而获得更多的空间内存空间<ul>
<li>在内存和外存之间只交换进程的部分内容</li>
</ul>
</li>
</ul>
<h3 id="2-1-局部性原理"><a href="#2-1-局部性原理" class="headerlink" title="2.1 局部性原理"></a>2.1 局部性原理</h3><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一个区域</p>
<ul>
<li>时间上：最近被访问的页在不就的将来还会被访问</li>
<li>空间上：内存中被访问的页周围的页在不就的将来也可能被访问</li>
<li>分支局部性：一条跳转指令的两次执行，很可能跳到相同的内存地址</li>
</ul>
<p><strong><font color="red">局部性原理的意义：从理论上来说，虚拟内存技术是能够实现的，且能够取得满意的效果。</font></strong></p>
<h3 id="2-2-虚拟内存的基本概念"><a href="#2-2-虚拟内存的基本概念" class="headerlink" title="2.2 虚拟内存的基本概念"></a>2.2 虚拟内存的基本概念</h3><ul>
<li>思路：将不常用的部分内存块暂存到外存</li>
<li>原理：<ul>
<li>装载程序时：只将当前指令执行需要的部分页面或段装入内存</li>
<li>指令执行中需要的指令或数据不存在内存（缺页或者缺段）时：处理器将通知操作系统将相应的页面或段调入页面</li>
<li>操作系统将内存中暂时不用的页面或段保存到外存</li>
</ul>
</li>
<li>实现方式：<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
</li>
</ul>
<p><strong><font color="red">物理内存+磁盘=虚拟内存</font></strong></p>
<p><strong>虚拟内存的支持技术</strong></p>
<ul>
<li>硬件：页式或段式存储中的地址转换机制</li>
<li>操作系统：管理内存和外存间页面或段的换入换出</li>
</ul>
<h3 id="2-3-虚拟页式存储管理"><a href="#2-3-虚拟页式存储管理" class="headerlink" title="2.3 虚拟页式存储管理"></a>2.3 虚拟页式存储管理</h3><p>在页式存储管理的基础上，增加请求调页和页面置换</p>
<p>思路：</p>
<ul>
<li>当用户程序要装载到内存中运行的时候，只装入部分页面，就启动程序运行</li>
<li>进程在运行中发现有需要的代码或者数据不存在时，则向系统发出缺页异常请求（可以从用户态切换到内核态进行 ）</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li>
</ul>
<h3 id="2-4-什么是虚拟内存"><a href="#2-4-什么是虚拟内存" class="headerlink" title="2.4 什么是虚拟内存"></a>2.4 什么是虚拟内存</h3><p>每个程序都拥有自己的地址空间，这些地址空间被分成大小相等的页，这些页被映射为物理内存；但不需要所有的页都在物理内存当中，当程序引用到不再物理内存当中的页的时候，由操作系统将确实的页装入物理内存。这样对程序来说似乎有很大的内存空间，但实际上有一部分存储在磁盘上，所以被称为虚拟内存。</p>
<h3 id="2-5-如何进行地址空间到物理内存的映射？"><a href="#2-5-如何进行地址空间到物理内存的映射？" class="headerlink" title="2.5 如何进行地址空间到物理内存的映射？"></a>2.5 如何进行地址空间到物理内存的映射？</h3><p>通过MMU内存管理单元来实现，MMU管理着逻辑地址和物理地址的转换，其中的页表(page table)存储页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含有效位（在内存or磁盘）、访问位（是否被访问过）、修改位（是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
<h3 id="2-6-页面置换算法"><a href="#2-6-页面置换算法" class="headerlink" title="2.6 页面置换算法"></a>2.6 页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不再内存中，就会发生缺页中断从而将该页调入到内存中。此时如果内存无空间空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要的目标是是页面置换频率最低（即缺页率最低，也就是因缺页导致的中断次数最少）</p>
<ul>
<li><strong>最佳页面置换算法OPT</strong>（Optimal Replacement Algorithm）：置换以后不需要或这最远的将来才需要的页面，是一种理论上的算法，是最优策略</li>
<li><strong>先进先出FIFO</strong>：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面置换出，从而使缺页率提高。（主要是因为FIFO不具备删选的能力）</li>
<li><strong>最近最少使用算法</strong>（LRU Least Recently Used）：置换出未使用时间最长的页面；实现方式：维护一个栈帧或者维护一个所有页面的链表，当一个页面被访问时，将这个页面移动到链表表头。这样就能够保证链表表尾是最近最久未访问的元素。</li>
<li><strong>时钟算法Clock</strong>：SCR需要将页面在链表中移动，时钟算法使用环形链表来实现，在使用一个指针指向最老的页面，避免移动页面的开销。访问之后变为1，找到为0的替换，如果遇到的为1，变为0，下一轮遇到为0的则替换。<ul>
<li><strong>原理</strong><ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面（读/写）时，访问位置置为1</li>
<li>缺页时：从指针当前位置顺序检查环形链表，访问位为0，则置换该页。访问位为1的话，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面位置。</li>
</ul>
</li>
</ul>
</li>
<li><strong>第二次机会算法SCR</strong>：改进的clock算法，这种是在clock算法的基础上，增加了一位修改位。按照FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置为0。相比时钟算法多了一位。1 0表示可写 ，第二位表示访问位，如果访问为1，给二次机会，并将访问置为0</li>
<li><strong>最近未使用算法LFU</strong>：缺页时置换访问次数最少的页面。实现：每个页面设置一个访问技计数，访问页面时，访问计数+1，缺页时，置换计数最小的页面。</li>
</ul>
<h3 id="2-7-Belady现象"><a href="#2-7-Belady现象" class="headerlink" title="2.7 Belady现象"></a>2.7 Belady现象</h3><p>采用FIFO算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象。</p>
<p><strong>产生的原因：</strong></p>
<ul>
<li>FIFO的置换特征与进程访问内存的动态特征矛盾</li>
<li>被它置换出去的页面并不一定是近期不会访问的（注意FIFO）</li>
</ul>
<p><strong>为什么LRU算法没有此现象？FIFO有？</strong></p>
<p>因为FIFO是先进先出，不记录置换的页面是否近期被访问过。而LRU算法是将最近最久没有使用的页面置换出去，所以不会出现Belady现象。</p>
<h3 id="2-8-抖动问题"><a href="#2-8-抖动问题" class="headerlink" title="2.8 抖动问题"></a>2.8 抖动问题</h3><p><strong>抖动</strong>：</p>
<ul>
<li>进程物理页面太小，不能包含工作集</li>
<li>造成大量缺页，频繁置换</li>
<li>进程运行速度变慢</li>
</ul>
<p><strong>产生抖动原因：</strong></p>
<ul>
<li>随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升</li>
</ul>
<p><strong>解决：</strong></p>
<ul>
<li>操作系统需要在并发水平和缺页率之间达到一个平衡</li>
<li>选择一个适当的进程数目和进程需要的物理页面数</li>
</ul>
<h2 id="3-用户态和内核态"><a href="#3-用户态和内核态" class="headerlink" title="3. 用户态和内核态"></a>3. 用户态和内核态</h2><p>为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，CPU划分了用户态和内核态两个权限等级</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他资源获取</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换</li>
</ul>
<p>所有的用户程序工作在用户态，但有时需要一些内核态操作，比如从硬盘或者磁盘读数据，这时就需要进行系统调用使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h3 id="3-1-为什么要区分用户态和内核态？"><a href="#3-1-为什么要区分用户态和内核态？" class="headerlink" title="3.1 为什么要区分用户态和内核态？"></a>3.1 为什么要区分用户态和内核态？</h3><ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源</li>
<li>封装性：用户程序不需要实现更加底层的代码</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要调度；统一交给操作系统会更加方便</li>
</ul>
<h3 id="3-2-如何从用户态切换到内核态？"><a href="#3-2-如何从用户态切换到内核态？" class="headerlink" title="3.2 如何从用户态切换到内核态？"></a>3.2 如何从用户态切换到内核态？</h3><ul>
<li>系统调用：比如读取命令行输入。本质上是通过中断实现的。<font color="red">系统调用指代的是系统函数调用。</font>这是发生在用户态主动请求切换到内核态的过程中的。</li>
<li>用户程序发生异常：比如发生缺页异常。会触发当前运行的进程切换到处理此内核异常的内核相关程序中，即切换到内核态。</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会先CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</li>
</ul>
<h2 id="4-进程"><a href="#4-进程" class="headerlink" title="4. 进程"></a>4. 进程</h2><p>进程：指一个具有一定的<font color="red">独立功能</font>的程序在一个<font color="red">数据集合</font>上的一次<font color="red">动态执行过程。</font></p>
<h3 id="4-1-进程的组成及特点"><a href="#4-1-进程的组成及特点" class="headerlink" title="4.1 进程的组成及特点"></a>4.1 进程的组成及特点</h3><p>进程包含了正在运行的一个程序的<strong>所有状态</strong>信息</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器</li>
<li>通用寄存器</li>
<li>进程占用系统资源：打开文件、已分配内存….</li>
</ul>
<p>进程的特点：</p>
<ul>
<li>动态性：动态的创建、结束进程</li>
<li>并发性：进程可以被独立调度并占用处理机运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据/资源或进程间同步而产生制约</li>
</ul>
<h3 id="4-2-进程与程序的联系及区别"><a href="#4-2-进程与程序的联系及区别" class="headerlink" title="4.2 进程与程序的联系及区别"></a>4.2 进程与程序的联系及区别</h3><p><strong>进程与程序的联系：</strong></p>
<ul>
<li>进程是操作系统中处于执行状态程序的抽象<ul>
<li>程序=文件</li>
<li>进程=执行中的程序=程序+执行状态</li>
</ul>
</li>
<li>同一个程序的多次执行过程对应为不同进程<ul>
<li>命令<code>ls</code>多次执行对应多个进程</li>
</ul>
</li>
<li>进程执行需要的资源<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
</li>
</ul>
<p><strong>进程和程序的区别：</strong></p>
<ul>
<li>进程是动态的，程序是静态的<ul>
<li>程序是有序序代码的集合</li>
<li>进程是程序的执行，进程有核心态/用户态</li>
</ul>
</li>
<li>进程是暂时的，程序是永久恶<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可以长久保存</li>
</ul>
</li>
<li>进程与程序的组成不同<ul>
<li>进程包括程序、数据和进程控制块（PCB）；而程序只包含有序代码</li>
</ul>
</li>
</ul>
<h3 id="4-3-进程控制块"><a href="#4-3-进程控制块" class="headerlink" title="4.3 进程控制块"></a>4.3 进程控制块</h3><p>进程控制块（PCB Process Control Block）：操作系统管理控制进程运行所用的信息集合。</p>
<ul>
<li>操作系统使用PCB来描述进程的基本情况以及运行变化的过程</li>
<li>PCB是进程存在的唯一标识<ul>
<li>每个进程在操作系统中都有一个对应的PCB</li>
</ul>
</li>
</ul>
<p><strong>进程控制块的作用</strong></p>
<ul>
<li>进程创建：生成该进程的PCB</li>
<li>进程终止：回收它的PCB</li>
<li>进程的组织管理：通过对PCB的组织管理来实现</li>
</ul>
<p><strong>进程控制块的组成：</strong></p>
<ul>
<li>进程标识信息</li>
<li>处理机保护现场</li>
<li>进程控制信息</li>
</ul>
<p><strong>进程控制信息：</strong></p>
<ul>
<li>调度和状态信息：<ul>
<li>调度进程和处理机使用情况</li>
</ul>
</li>
<li>进程间通信信息<ul>
<li>进程间通信相关的各种标识</li>
</ul>
</li>
<li>存储管理信息<ul>
<li>指向进程映像存储空间数据结构</li>
</ul>
</li>
<li>进程所用资源<ul>
<li>进程使用的系统资源，如打开文件等</li>
</ul>
</li>
<li>有关数据结构连接信息<ul>
<li>与PCB相关的进程队列</li>
</ul>
</li>
</ul>
<p><strong>进程控制块的组织</strong></p>
<ul>
<li>链表<ul>
<li>同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li>
</ul>
</li>
<li>索引表<ul>
<li>同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表</li>
</ul>
</li>
</ul>
<h3 id="4-4-进程的生命周期"><a href="#4-4-进程的生命周期" class="headerlink" title="4.4 进程的生命周期"></a>4.4 进程的生命周期</h3><p>进程的生命周期可以分为：</p>
<ul>
<li>进程创建</li>
<li>进程执行</li>
<li>进程等待</li>
<li>进程抢占</li>
<li>进程唤醒</li>
<li>进程结束</li>
</ul>
<p><strong>进程创建，如何会引起进程创建？</strong></p>
<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新的进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
<p><strong>进程执行</strong></p>
<ul>
<li>内核选择一个就绪的进程，让它占用处理机并执行</li>
<li>如何选择？相应的调度算法会解决这个问题</li>
</ul>
<p><strong>进程等待：进程进入等待（阻塞）的状态</strong></p>
<p>进入阻塞的情况发生场景：</p>
<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据还没有到达</li>
</ul>
<p><font color="red">注意，只有进程自身才能知道何时需要等待某种时间的发生</font></p>
<p><strong>进程抢占</strong></p>
<ul>
<li>高优先级进程就绪</li>
<li>进程当前执行时间用完</li>
</ul>
<p><strong>进程唤醒</strong></p>
<ul>
<li>被阻塞的进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
</ul>
<p><font color="red">注意：进程只能被操作系统或者其他进程唤醒</font></p>
<p><strong>进程结束</strong></p>
<ul>
<li>正常退出（自愿的）</li>
<li>错误退出（自愿的）</li>
<li>致命错误（强制性的）</li>
<li>被其他进程所杀（强制性的）</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583218452994.png" alt="1583218452994"></p>
<h3 id="4-5-进程挂起"><a href="#4-5-进程挂起" class="headerlink" title="4.5 进程挂起"></a>4.5 进程挂起</h3><p>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存。</p>
<p><strong>等待到等待挂起</strong></p>
<ul>
<li>没有进程处于就绪状态或就绪进程要求更多内存资源</li>
</ul>
<p><strong>就绪到就绪挂起</strong></p>
<ul>
<li>当有高优先级等待（系统会认为很快就绪的）进程和低优先级就绪进程</li>
</ul>
<p><strong>运行到就绪挂起</strong></p>
<ul>
<li>对抢先式分时系统当有高优先级等待挂起进程因时间而进入就绪挂起</li>
</ul>
<p><strong>在外存时的状态转换</strong></p>
<ul>
<li>等待挂起到就绪挂起<ul>
<li>当有等待挂起进程因相关时间出现</li>
</ul>
</li>
</ul>
<p><strong>激活Active</strong></p>
<ul>
<li>把一个进程从外存转到内存</li>
<li>就绪挂起到就绪：没有就绪进程或者挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并由高优先级等待挂起进程</li>
</ul>
<h2 id="5-线程"><a href="#5-线程" class="headerlink" title="5. 线程"></a>5. 线程</h2><p>在进程内部增加一类实体，满足以下特性：</p>
<ul>
<li>实体之间可以并发执行</li>
<li>实体之间共享相同的地址空间</li>
</ul>
<p>这种实体就是线程</p>
<h3 id="5-1-线程的概念"><a href="#5-1-线程的概念" class="headerlink" title="5.1 线程的概念"></a>5.1 线程的概念</h3><p>线程是进程的一部分，描述指令执行状态。它是进程中执行指令流的最小单元，是CPU<font  color="red">调度</font>的基本单位。</p>
<ul>
<li>进程的资源分配角色：进程由一组相关资源构成，包括地址空间（代码段、数据段等）、打开文件等各种资源。</li>
<li>线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态</li>
</ul>
<p><strong>线程=进程-共享资源</strong></p>
<p><strong>线程的优点：</strong></p>
<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
<p><strong>线程的缺点：</strong></p>
<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
<h3 id="5-2-线程和进程的区别"><a href="#5-2-线程和进程的区别" class="headerlink" title="5.2 线程和进程的区别"></a><font color="red">5.2 线程和进程的区别</font></h3><ul>
<li>进程是资源的分配单位，线程是CPU的调度单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可以不通过内核直接进行通信（进程的读取资源是需要进入内核的。）</li>
</ul>
</li>
</ul>
<h3 id="5-3-线程的三种实现方式"><a href="#5-3-线程的三种实现方式" class="headerlink" title="5.3 线程的三种实现方式"></a>5.3 线程的三种实现方式</h3><p><strong>用户线程：在用户空间中实现</strong></p>
<p>由一组用户级的线程库函数来完成线程的管理。包括线程的创建、终止、调度和同步等</p>
<h4 id="5-3-1-用户线程"><a href="#5-3-1-用户线程" class="headerlink" title="5.3.1 用户线程"></a>5.3.1 用户线程</h4><p><strong>用户线程的特征：</strong></p>
<ul>
<li>不依赖于操作系统的内核<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
</li>
<li>在用户空间实现的线程机制<ul>
<li>每个进程有私有的线程控制块（TCB）列表</li>
<li><font color="red">TCB由线程库函数维护</font></li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快<ul>
<li>无需用户态/内核态切换</li>
</ul>
</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
<p><strong>用户线程的不足</strong></p>
<ul>
<li>线程发起系统调用而阻塞时，则整个进程进入等待（IDEA跑程序多线程死锁之后的等待）</li>
<li>不支持基于线程的处理机抢占<ul>
<li>除非当前运行线程主动放弃，否则它所在的进程的其他线程无法抢占CPU</li>
</ul>
</li>
<li>只能按进程分配CPU时间<ul>
<li>多个线程的进程中，每个线程的时间片较少</li>
</ul>
</li>
</ul>
<h4 id="5-3-2-内核线程"><a href="#5-3-2-内核线程" class="headerlink" title="5.3.2 内核线程"></a>5.3.2 内核线程</h4><p><strong>内核线程：在内核中实现</strong></p>
<p>由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</p>
<p><strong>内核线程的特征</strong></p>
<ul>
<li>由内核维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止、切换开销相对较大<ul>
<li>通过系统调用/内核函数，在内核中实现</li>
</ul>
</li>
<li>以线程为单位进行CPU时间分配<ul>
<li>多线程的进程可获得更多CPU时间</li>
</ul>
</li>
</ul>
<h4 id="5-3-3-轻权进程（Light-Weight-Process）"><a href="#5-3-3-轻权进程（Light-Weight-Process）" class="headerlink" title="5.3.3 轻权进程（Light Weight Process）"></a>5.3.3 轻权进程（Light Weight Process）</h4><p><strong>轻量级线程：在内核中实现，支持用户线程</strong></p>
<p>内核支持的用户线程。一个进程可以拥有一个或者多个轻量级线程，每个轻权进程由一个单独的内核线程来支持。</p>
<p><strong>用户线程和内核线程的对应关系</strong></p>
<ul>
<li>一对一</li>
<li>多对一</li>
<li>多对多</li>
</ul>
<h2 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6. 进程控制"></a>6. 进程控制</h2><h3 id="6-1-进程切换"><a href="#6-1-进程切换" class="headerlink" title="6.1 进程切换"></a>6.1 进程切换</h3><p><strong>进程切换</strong></p>
<ul>
<li>暂停当前运行进程，从运行状态变成其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
<p><strong>进程切换要求</strong></p>
<ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
<p><strong>进程生命周期信息</strong></p>
<ul>
<li>寄存器（PC、SP）</li>
<li>CPU状态</li>
<li>内存地址空间</li>
</ul>
<p><strong>进程控制块PCB：内核的进程状态记录</strong></p>
<ul>
<li>内核为每个进程维护了对应的进程控制块PCB</li>
<li>内核将相同状态的进程的PCB放置再同一队列</li>
</ul>
<h3 id="6-2-进程的创建"><a href="#6-2-进程的创建" class="headerlink" title="6.2 进程的创建"></a>6.2 进程的创建</h3><p><strong>Windows创建进程API：CreateProcess(fileName)</strong></p>
<p><strong>Unix创建进程：fork/exec</strong></p>
<ul>
<li>fork()将一个进程复制为两个进程</li>
<li>exec()用新程序来重写当前进程，PID没有改变</li>
<li>fork()创建一个继承子进程<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有CPU寄存器（一个例外）</li>
</ul>
</li>
<li>fork()的返回值<ul>
<li>子进程的fork()返回0</li>
<li>父进程的fork()返回子进程标识符</li>
<li>fork()返回值可方便后续使用，子进程可使用getpid()获取PID</li>
</ul>
</li>
</ul>
<p><strong>fork()的开销</strong></p>
<ul>
<li>由于再fork过程中涉及到大量的数据复制，内存分配，开销昂贵</li>
<li>在99%的情况下，调用了fork之后需要调用exec</li>
</ul>
<p><strong>vfork()</strong></p>
<ul>
<li>创建进程时，不再创建一个同样的内存映像</li>
<li>轻量级fork()</li>
<li>子进程应该几乎立即调用exec</li>
<li>现在使用Copy On Write技术（高并发）</li>
</ul>
<h3 id="6-3-进程加载及进程的等待与退出"><a href="#6-3-进程加载及进程的等待与退出" class="headerlink" title="6.3 进程加载及进程的等待与退出"></a>6.3 进程加载及进程的等待与退出</h3><p>程序加载和执行系统调用exec()</p>
<p><strong>父进程等待子进程</strong></p>
<ul>
<li>wait()系统调用用于父进程等待子进程的结束<ul>
<li>子进程结束时通过exit()向父进程返回一个值</li>
<li>父进程通过wait()接受并处理返回值</li>
</ul>
</li>
<li>wait()系统调用的功能<ul>
<li>有子进程存活时，父进程进入等待状态，等待子进程的返回结果（<font color="blue">当某子进程调用exit时，唤醒父进程，将exit()返回值作为父进程中wait的返回值</font>）</li>
<li>有僵尸子进程等待时，wait()立即返回其中一个值</li>
<li>无子进程存活时，wait()立即返回</li>
</ul>
</li>
</ul>
<p><strong>进程的有序终止exit()</strong></p>
<ul>
<li>进程结束执行时调用exit()，完成进程资源回收</li>
<li>exit()系统调用的功能<ul>
<li>将调用参数作为进程的结果</li>
<li>关闭所有打开的文件等占用的资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查是否父进程是存活着的<ul>
<li>如果存活，保留结果的值直到父进程需要它，进入僵尸状态</li>
<li>如果没有，释放所有的数据结构，进程结果</li>
</ul>
</li>
<li>清理等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集（资源回收）</li>
</ul>
<p><font color="orange">僵尸进程：一个子进程结束后，她的父进程并没有得等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被摧毁。它已经放弃了几乎所有的内存空间，没有任何可以执行的代码，也不能够被调度，仅仅是再进程表中保留一个位置，记录着该进程的id，终止状态以及资源利用信息（CPU时间、内存使用量等），供父进程收集，除此之外，僵尸进程不再占有任何内存空间，这个僵尸进程可能会一直保留在系统中直到系统重启。</font></p>
<p><font color="red">僵尸进程危害：占用进程号，系统的进程号是有限的；占用内存</font></p>
<h2 id="7-处理机调度"><a href="#7-处理机调度" class="headerlink" title="7. 处理机调度"></a>7. 处理机调度</h2><p><strong>CPU资源的时分复用</strong></p>
<ul>
<li>进程切换：CPU资源的当前占用者切换<ul>
<li>保存当前进程在PCB中的知行上下文（CPU状态）</li>
<li>恢复下一个进程的知执行上下文</li>
</ul>
</li>
<li>处理机调度<ul>
<li>从就绪队列中挑选下一个占用CPU运行的进程</li>
<li>从多个可用CPU中挑选就绪进程可使用的CPU资源</li>
</ul>
</li>
<li>调度程序：挑选就绪进程的内核函数</li>
</ul>
<h3 id="7-1-调度时机"><a href="#7-1-调度时机" class="headerlink" title="7.1 调度时机"></a>7.1 调度时机</h3><ul>
<li>内核运行调度程序的条件<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
</li>
<li><strong>非抢占系统</strong><ul>
<li>当前进程主动放弃CPU时间片</li>
</ul>
</li>
<li><strong>可抢占系统</strong><ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程时间片用完</li>
<li>进程从等待切换到就绪</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>处理机资源的使用模式</strong></p>
<ul>
<li>进程在CPU计算和I/O操作间交替<ul>
<li>每次调度决定再下一个CPU计算时将哪个工作交给CPU</li>
<li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li>
</ul>
</li>
</ul>
<h3 id="7-2-比较调度算法的原则"><a href="#7-2-比较调度算法的原则" class="headerlink" title="7.2 比较调度算法的原则"></a>7.2 比较调度算法的原则</h3><ul>
<li>CPU使用率<ul>
<li>CPU处于忙状态的时间百分比</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间内完成的进程数量</li>
</ul>
</li>
<li>周转时间<ul>
<li>进程从初始化到结束（包括等待）的总时间</li>
</ul>
</li>
<li>就绪等待时间<ul>
<li>进程在就绪队列中的总时间</li>
</ul>
</li>
<li>响应时间<ul>
<li>从提交请求到产生响应所花费的总时间</li>
</ul>
</li>
</ul>
<p><strong>吞吐量与延迟</strong></p>
<ul>
<li>调度算法的要求：希望获取“更快”的服务</li>
<li>更快的含义<ul>
<li>传输文件时的高带宽，调度算法的高吞吐量</li>
<li>玩游戏时的低延迟，调度算法的低相应延迟</li>
</ul>
</li>
</ul>
<p><strong>处理机调度策略的响应时间目标</strong></p>
<ul>
<li>减少响应时间（响应时间是操作系统的计算延迟）</li>
<li>减少平均响应时间的波动</li>
</ul>
<p><strong>处理机调度策略的吞吐量目标</strong></p>
<ul>
<li>增加吞吐量（吞吐量是操作系统的计算带宽）<ul>
<li>减少开销（操作系统开销、上下文切换）</li>
<li>系统资源的高效利用（CPU、I/O设备）</li>
</ul>
</li>
<li>减少等待时间<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
<li>操作系统需要保证吞吐量不受用户交互的影响<ul>
<li>操作系统必须不停的进行调度，即使存在许多交互任务。</li>
</ul>
</li>
</ul>
<p><strong>处理机调度的公平性目标</strong></p>
<ul>
<li>公平的定义<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>保证每个进程的等待时间相同</li>
</ul>
</li>
<li>公平通常会增加平均响应时间</li>
</ul>
<h3 id="7-3-调度算法"><a href="#7-3-调度算法" class="headerlink" title="7.3 调度算法"></a>7.3 调度算法</h3><p><strong>先来先服务算法（First Come  First Served，FCFS）</strong></p>
<ul>
<li>依据进程进入就绪状态的先后顺序排列<ul>
<li>进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>平均等待时间波动较大<ul>
<li>短进程可能排在长进程后面</li>
</ul>
</li>
<li>I/O资源和CPU资源的利用率较低<ul>
<li>CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也会等待</li>
</ul>
</li>
</ul>
<p><strong>短进程优先算法（Shortest Process Next）</strong></p>
<ul>
<li>选择执行队列中执行时间最短进程占用CPU进入运行状态<ul>
<li>就绪队列按预期的执行时间来排序</li>
</ul>
</li>
<li><font color="red">短剩余时间优先算法SRT</font>：SPN算法的可抢占改进</li>
</ul>
<p>缺点</p>
<ul>
<li>可能导致饥饿<ul>
<li>连续的短进程流会使长进程无法获得CPU资源</li>
</ul>
</li>
<li><font color="red">需要预知未来：主要是预估下一个进程需要的CPU计算的持续时间</font>：询问用户</li>
</ul>
<p><strong>最高响应比优先算法（Highest Response Ratio Next）</strong></p>
<ul>
<li>选择就绪队列中相应时间比R值最高的进程（R=(w+s)/s w：等待时间，s：执行时间）</li>
<li>在短进程优先算法的基础上改进</li>
<li>不可抢占</li>
<li>关注进程的等待时间</li>
<li>防止无限期推迟</li>
</ul>
<p><strong>时间片轮训算法（RR，Round-Robin）</strong></p>
<ul>
<li>时间片<ul>
<li>分配处理机资源的基本时间单元</li>
</ul>
</li>
<li>算法思路：<ul>
<li>时间片结束时，按照FCFS算法切换到下一个就绪进程</li>
<li>每隔(n-1)个时间片进程执行一个时间片q</li>
</ul>
</li>
</ul>
<p><strong>时间片轮转算法中的时间片长度</strong></p>
<ul>
<li>RR算法开销<ul>
<li>额外的上下文切换</li>
</ul>
</li>
<li>时间片太大<ul>
<li>等待时间过长</li>
<li>极限情况退化为FCFS</li>
</ul>
</li>
<li>时间片太小<ul>
<li>反应迅速，会产生大量上下文切换</li>
<li>大量上下文切换开销影响到系统吞吐量</li>
</ul>
</li>
<li>时间片长度选择目标<ul>
<li>选择一个合适的时间片长度</li>
<li>经验规则：维持上下文切换开销处于1%以内</li>
</ul>
</li>
</ul>
<p><strong>多级队列调度算法（MQ）</strong></p>
<ul>
<li>就绪队列被划分为多个独立的子队列</li>
<li>每个队列拥有自己的调度策略</li>
<li>队列间的调度<ul>
<li>固定优先级<ul>
<li>先处理前台，然后处理后台</li>
<li>可能导致饥饿（前台太多）</li>
</ul>
</li>
<li>时间片轮转<ul>
<li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>多级反馈队列算法（MLFQ Multi Level Feedback Queues）</strong></p>
<ul>
<li>进程可在不同队列间移动的多级队列算法<ul>
<li>时间片大小随优先级级别增加而增加</li>
<li>如进程再当前的时间片没有完成，则降到下一个优先级</li>
</ul>
</li>
<li>MLFQ算法的特征<ul>
<li>CPU密集型进程的优先级下降很快</li>
<li>I/O密集型进程停留在高优先级</li>
</ul>
</li>
</ul>
<p><strong>公平共享调度（FSS，Fair Share Scheduling）</strong></p>
<ul>
<li>FSS控制用户对系统资源的访问<ul>
<li>一些用户组比其他用户组更加重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照比例分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
</li>
</ul>
<h3 id="7-4-调度算法总结"><a href="#7-4-调度算法总结" class="headerlink" title="7.4 调度算法总结"></a>7.4 调度算法总结</h3><ul>
<li>先来先服务算法<ul>
<li>不公平、平均等待时间较差</li>
</ul>
</li>
<li>短进程优先算法<ul>
<li>不公平、平均周转时间最小</li>
<li>需要精确预测计算时间</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li>最高响应比优先算法<ul>
<li>基于SPN（短进程优先）调度</li>
<li>不可抢占</li>
</ul>
</li>
<li>时间片轮转算法<ul>
<li>公平，但是平均等待时间较差</li>
<li>多级反馈队列</li>
</ul>
</li>
<li>公平共享调度<ul>
<li>公平是第一要素</li>
</ul>
</li>
</ul>
<h3 id="7-5-实时操作系统"><a href="#7-5-实时操作系统" class="headerlink" title="7.5 实时操作系统"></a>7.5 实时操作系统</h3><p><strong>定义</strong>：正确依赖于其时间和功能两方面的操作系统</p>
<p><strong>性能指标</strong></p>
<ul>
<li>时间约束的及时性</li>
<li>速度和平均性能的相对不重要</li>
</ul>
<p><strong>实时操作系统的特性</strong></p>
<ul>
<li>时间约束的可预测性</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>强实时操作系统<ul>
<li>要求在指定的时间内必须完成重要的任务</li>
</ul>
</li>
<li>弱实时操作系统<ul>
<li>重要进程有高优先级，要求尽量但非必须完成</li>
</ul>
</li>
</ul>
<p><strong>实时任务</strong></p>
<p>任务：即工作单元，一次计算，一次文件读取，一次消息传递等。</p>
<p><strong>可调度性</strong></p>
<p>表示一个实时操作系统能够满足任务时限要求</p>
<h3 id="7-6-优先级返转-Priority-Inversion"><a href="#7-6-优先级返转-Priority-Inversion" class="headerlink" title="7.6 优先级返转(Priority Inversion)"></a>7.6 优先级返转(Priority Inversion)</h3><ul>
<li>操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象。</li>
<li>基于优先级的可抢占调度算法存在优先级反转现象</li>
</ul>
<p><font color="red">优先级反转的通俗含义理解：T1、T2、T3是三个优先级从高到低的进程，然而T1处理完之后，T3获得时间片，此时T3处理完之后，T2执行，然而再这时间内T1想要执行，却被T2给拦住，此时出现优先级反转的行为，导致程序重新启动。</font></p>
<p><strong>优先级继承(Priority Inheritance)</strong></p>
<ul>
<li>占用资源的低优先级进程继承申请资源的高优先级进程的优先级<ul>
<li>只有再占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级</li>
</ul>
</li>
</ul>
<p><font color="red">通俗理解：T1、T2、T3是三个优先级从高到低的进程，当T1要请求T3当前占有的资源的时候，此时T3就直接继承T1的优先级。由此可避免优先级反转的现象发生。</font></p>
<p><strong>优先级天花板协议(Priority Ceiling Protocol)</strong></p>
<ul>
<li>占有资源进程的优先级和所有可能申请该资源的进程的最高优先级相同<ul>
<li>不管是否发生等待，都提升占有资源进程的优先级</li>
<li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的常见面试点</title>
    <url>/2020/03/21/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h2><p>JVM也就是java虚拟机，运行时的数据区域分为：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存。</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的为本地方法则为空）</p>
<h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3><p>每个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完毕的过程，对应每一个栈帧在Java虚拟机中入栈和出栈的过程</p>
<p>可能会抛出的异常：</p>
<ul>
<li>线程请求的栈深度超过最大值，会抛出StackOverflowError异常</li>
<li>栈进行动态扩展时如果无法申请到足够的内存，会抛出OutOfMemoryError异常</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈与Java虚拟机栈类似，区别在于本地方法栈是为本地方法服务的。</p>
<p>本地方法一般使用其他语言（C++/C/汇编等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特殊处理。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>堆的主要作用就是给所有对象分配内存，是垃圾收集的主要区域。（GC堆）</p>
<p>堆为了方便回收，加上现代的垃圾收集器都是分代回收的，堆可以划分为新生代（Young Generation）和老年代（Old Generation）</p>
<p>堆不需要连续的内存，并且可以动态的增加其内存，增加失败会抛出OutOfMemoryError异常。</p>
<p>可以使用<code>-XMs20M  -XMx40M</code>设置堆内存大小，第一个是初始值，第二个是最大值</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存。并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。</p>
<p>对这块区域的回收主要是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>JDK1.8以后方法区被移至元空间，它位于本地内存中，而不是虚拟机内存中。因为在之前的HotSpot虚拟机都是将方法区的回收当成永久代进行回收，但是很难确定回收内存的大小，因为它们受到很多因素的影响，并且每次FullGC之后永久代的空间都会变，所以经常会抛出OutMemoryError异常。</p>
<p>方法区是JVM的一个规范，永久代和元空间都是它的实现方式，在JDK1.8之后，原来永久代的数据被分到元空间中，元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p>运行时常量池是方法区的一部分。</p>
<p>Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><p>在JDK1.4之后新引入了NIO类，它可以使用native函数库直接分配堆外内存，然后通过java堆里的 DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景下显著提升性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h3 id="8-线程所属"><a href="#8-线程所属" class="headerlink" title="8. 线程所属"></a>8. 线程所属</h3><p>上述属于线程私有的：</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p>属于线程共有的：</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ul>
<h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><p>线程私有的部分都只存在于线程的生命周期之内，线程结束之后就消失。所以一般的垃圾回收主要是针对堆和方法区而言的。</p>
<p>既然要进行垃圾回收，就需要判断哪些是JVM中认定的可回收的“垃圾”。</p>
<h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><p>为对象添加一个引用计数器，当对象增加一个计数+1，引用失效时计数器-1，引用计数为0的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收，正是因为循环引用的存在，因此Java虚拟机不使用引用计数法。</p>
<h4 id="1-可达性分析算法"><a href="#1-可达性分析算法" class="headerlink" title="1. 可达性分析算法"></a>1. 可达性分析算法</h4><p>以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots一般包含一下内容：</p>
<ul>
<li>虚拟机栈局部变量表中引用的对象</li>
<li>本地方法栈JNI中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h4 id="2-方法区的回收"><a href="#2-方法区的回收" class="headerlink" title="2. 方法区的回收"></a>2. 方法区的回收</h4><p>因为方法区主要存放永久代对象，而永久代的回收率比新生代低很多，所以在方法区进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足三大条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法</li>
</ul>
<h4 id="3-finalize"><a href="#3-finalize" class="headerlink" title="3.  finalize()"></a>3.  finalize()</h4><p>类似C++的析构函数，用于关闭外部资源。但是try-finally等方式可以做的更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法让对象重新被引用，从而实现自救，自救只能进行一次，如果回收的对象之前调用finalize()方法自救，后面回收时不会再调用该方法。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java提供了四种强度不同的引用类型。</p>
<h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p>被强引用关联的对象不会被回收</p>
<p>使用 new一个新对象的方式来创建引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收</p>
<p>使用SoftReference类来创建软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(object);</span><br><span class="line">    <span class="comment">// 使对象只被软引用关联</span></span><br><span class="line">    object = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</p>
<p>使用WeakReference来创建弱引用。</p>
<h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>又被称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时受到一个系统通知</p>
<p>使用PhantomReference 来构建虚引用</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h4><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这个两个分块。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小size的块block，如果它找到的块等于size，会直接返回这个分块；如果找到的块大于size，会将这个块分割成size大小和block-size大小的两块，返回大小为size的分块，并将block-size块返回给空闲链表</p>
<p>存在的不足：</p>
<ul>
<li>标记和清除效率都不高</li>
<li>会产生大量的不连续的内存碎片，导致无法给大对象分配内存</li>
</ul>
<h4 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记-整理"></a>2. 标记-整理</h4><p>标记整理的话，标记与上面1的标记相同，只是在回收之前会有一个整理过程，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点：</p>
<p>不会产生内存碎片</p>
<p>缺点：</p>
<p>需要移动大量对象，处理效率比较低</p>
<h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h4><p>将内存划分为两块大小相等的块，每次只使用其中一块，当这一块的内存使用完了就将还存活的对象复制到另一块上面，然后把使用过的内存空间一次清理。</p>
<p>主要存在的不足就是使用了内存的一半空间</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的块，而是划分为一块较大的Eden和两块较小的Survivor块，每次使用Eden空间和Survivor中的一块，在回收时，将Eden和Survivor中还存活着的对象全部复制到另一块Survivor上去，最后清理Eden和使用过的那一块的Survivor空间即可。</p>
<p>HotSpot虚拟机有Eden和Survivor大小比例默认为8:1，保证了内存的利用了达到90%，如果每次回收有多于10%的对象存活的话，那么一块Survivor对象就不够用了，此时需要依赖老年代进行 空间分配担保，就是借用老年代的空间存储放不下的对象。</p>
<h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h4><p>现在的商业虚拟机使用分代收集算法，它根据对象存货周期将内存分为几块，不同块采用适当的收集算法。</p>
<p>一般是分为新生代和老年代：</p>
<ul>
<li>新生代一般使用复制算法，因为回收的内存空间大，存活的对象少</li>
<li>老年代一般使用标记-清除或者标记-整理算法</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581662395801.png" alt="1581662395801"></p>
<p>以上是HotSpot的7个垃圾收集器，连线表示收集器之间可以配合使用</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，多线程表示使用多个线程</li>
<li>串行和并行：串行是指垃圾收集器与用户线程交替执行，这意味着再执行垃圾收集线程的时候需要停顿用户线程；并行是指垃圾收集器线程与用户线程一起执行。除了CMS和G1收集器之外其他的垃圾收集器都是以串行的方式执行</li>
</ul>
<h4 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h4><p>串行收集器，以串行的方式执行。它是单线程垃圾收集器，只会使用一个垃圾收集线程执行垃圾的回收。</p>
<p><strong>优点</strong>：简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是Client场景下默认的新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆的垃圾的停顿时间可以控制在100多毫秒之内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h4 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h4><p>它是Serial收集器的多线程版本。</p>
<p>它是Server场景下默认的新生代收集器，除了性能原因外，主要是因为除了Serial收集器，只有它能与CMS收集器配合使用。</p>
<h4 id="3-Parallel-Scavenger收集器"><a href="#3-Parallel-Scavenger收集器" class="headerlink" title="3. Parallel Scavenger收集器"></a>3. Parallel Scavenger收集器</h4><p>与ParNew一样是多线程收集器。</p>
<p>其他收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制吞吐量，因此它被称为“吞吐量优先”的收集器，这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来实现的：新生代空间变小，垃圾回收频繁，导致吞吐量下降。（这里的原因是新生代空间如果大的话，一次收集需要停顿的时间可能是100ms，但是如果小的话，停顿时间可能只需要30ms，停顿时间缩短了，但是吞吐量也下降了）</p>
<p>可以通过一个开关参数打开GC自适应调节策略（GC Ergonomics），就不需要手动指定新生代的大小（-Xmn）、Eden和Survivor大小比例、晋升老年代的年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h4 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h4><p>Serial收集器的老年代版本，也是Client场景下使用的，如果在Server场景下：</p>
<ul>
<li>在JDK1.5以及之前版本（Parallel Old诞生之前）中与Parallel Scavenge收集器搭配使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<h4 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本</p>
<p>在注重吞吐量以及CPU敏感的场合，都可以优先考虑Paralllel Scavenge结合Parallel Old收集器使用</p>
<h4 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h4><p>CMS（Concurrent Mark Sweep），并发标记清除。</p>
<p>分为四个流程来进行：</p>
<ul>
<li>初始标记：仅仅只是标记一下GC Roots能够关联到的对象，速度很快，<strong>需要停顿</strong></li>
<li>并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，<strong>不需要停顿</strong></li>
<li>重新标记：为了修正并发标记期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿（不停顿就可能需要一直循环标记了:smile:）</li>
<li>并发清除：<strong>不需要停顿</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高</li>
<li>无法处理浮动垃圾，可能出现Concurrent Mode Failure。浮动垃圾指的是在并发清除阶段由于用户线程继续运行而产生的垃圾，这部分的垃圾只能到下一次的垃圾回收才能够被回收，由于浮动垃圾的存在，因此需要预留出一部分内存，以为这CMS收集器不能像其他垃圾收集器一样等到老年代内存快满的时候再进行回收。如果预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将启用Serial Old来替代CMS。</li>
<li>标记-清除算法将会导致产生大量的空间碎片，往往出现老年代空间剩余，但是没有足够大的空间来分配当前对象，以致于不得不提前触发一次Full GC</li>
</ul>
<h4 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU和大内存的应用场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。</p>
<p>堆被分成新生代和老年代，其他收集器进行收集的范围都是新生代或者老年代，但是G1可以对新生代和老年代一起回收。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></p>
<p>G1把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></p>
<p>通过引入Region的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种回收方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验所得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的空间。</p>
<p>每个Region都有一个 Remembered Set，用来记录该Region对象的引用所在的Region，通过Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发期间由于用户线程工作导致标记产生变动的那一部分的标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs数据合并到Remembered Set中，这个阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个Region中的回收价值和回收成本进行排序，根据用户所期望的GC停顿时间来指定回收计划，此阶段其实也可做到与用户线程一起并发执行，但是因为只回收一部分Region，时间是用户控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体上来看是基于“标记-整理”算法实现的收集器，从局部的Region上来看是基于复制算法来的，这意味着在运行期间不会产生空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC的时间不得超过N毫秒。</li>
</ul>
<h2 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h2><h3 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h3><ul>
<li>Minor GC：回收新生代，因为新生代对象存活的时间很短，因此Minor会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象器存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很少。</li>
</ul>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在Eden上分配"><a href="#1-对象优先在Eden上分配" class="headerlink" title="1. 对象优先在Eden上分配"></a>1. 对象优先在Eden上分配</h4><p>大多数情况下，对象在新生代Eden上分配，当Eden上空间不足时，发动Minor GC</p>
<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数组</p>
<p>经常出现大对象会提前触发垃圾收集以获得足够的连续空间分配给大对象</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制</p>
<h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在Eden上出生并经历Minor GC后依然存活，将移动到Survivor中，年龄增加一岁，增加到一定年龄的对象移动到老年代中。默认是15岁</p>
<p>-XX:MaxTenuringThreshold，用来定义年龄的阈值</p>
<h4 id="4-动态对象年龄判断"><a href="#4-动态对象年龄判断" class="headerlink" title="4. 动态对象年龄判断"></a>4. 动态对象年龄判断</h4><p>虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor中相同年龄的所有对象大小的总和超过Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立的话，那么Minor GC可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure的值是否允许担保失败，如果允许的话就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于的话，将尝试着进行一次Minor GC操作；如果小于的话，或者HandlePromotionFailure的值不允许冒险，则需要进行以此Full GC</p>
<h3 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h3><p>对于Minor GC的话，其触发条件非常简单，当Eden空间满的时候，将触发一次Minor GC操作，而Full GC相对比较复杂。有以下条件：</p>
<h4 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1. 调用System.gc()"></a>1. 调用System.gc()</h4><p>只是建议虚拟机执行Full GC，但是虚拟机不一定真正的去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的场景如上文中的大对象直接进入老年代，长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的Full GC，应当尽量不要创建过大的对象以及数组，除此之外，可以通过-Xmn虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过-XX:MaxTenuringThreshold调大进入老年代的年龄，让对象在新生代中存活时间长一点。</p>
<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>Minor GC后存活的对象没有足够的空间可以容纳它，此时需要担保进入老年代，如果担保失败此时会触发Full GC</p>
<h4 id="4-JDK1-7及以前的永久代空间不足"><a href="#4-JDK1-7及以前的永久代空间不足" class="headerlink" title="4. JDK1.7及以前的永久代空间不足"></a>4. JDK1.7及以前的永久代空间不足</h4><p>在JDK1.7之前，HotSpot虚拟机中的方法区是永久代实现的，永久代存放的是Class的信息，常量，静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能被占满，在未配置CMS GC的时候也会执行Full GC，如果经过Full GC仍然回收不了，那么虚拟机会抛出<code>java.lang.OutOfMemoryError</code></p>
<p>为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或者转变为使用CMS GC</p>
<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC</p>
<h2 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类，因为如果一次性加载，那么会占用很多的内存。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>七个阶段：</p>
<ol>
<li>加载-Loading</li>
<li>验证-Verficiation</li>
<li>准备-Preparation</li>
<li>解析-Resolution</li>
<li>初始化-Initialization</li>
<li>使用-Using</li>
<li>卸载-Unloading</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载过程包括：加载、验证、准备、解析、初始化五个过程</p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>加载是类加载的第一个阶段，不要混淆加载与类加载的概念，加载只是类加载的一个部分。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的全限定名获取定义该类的二进制字节流</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时的存储结构</li>
<li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li>
</ul>
<p>其中二进制文件流可以从如下途径中获取：</p>
<ul>
<li>从ZIP包中读取，成为JAR，EAR、WAR格式的基础</li>
<li>从网络中获取，最典型的就是Applet</li>
<li>运行时计算生成。例如动态代理技术，在java.lang.reflect.proxy使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li>
<li>由其他文件生成，例如由JSP生成对应的Class类</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>确保Class的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>如果是被static修饰的类变量，准备阶段会为类变量分配内存以及设置初始值，使用的是方法区的内存</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例初始化之前，并且类加载只有一次，实例化可以有多次。</p>
<p>初始值一般为0，但是如果用final修饰的变量为表达式赋予的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">123</span>; <span class="comment">// 初始值0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">123</span>; <span class="comment">// 初始值123</span></span><br></pre></td></tr></table></figure>

<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段开始之后再开始，是为了支持Java的动态绑定。</p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>初始化阶段才真正开始执行类中定义的Java程序代码，初始化阶段是虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</p>
<p><code>&lt;clinit&gt;()</code>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的先后顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量。定义在它之后的类变量只能赋值。不能访问。</p>
<p>JDK1.8下运行如下代码会输出0. JDK1.7的看代码中注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.println(i); <span class="comment">// 编译器提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassTest test = <span class="keyword">new</span> ClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块的执行要优先于子类。（继承）</p>
<p>接口中不能使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法，但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父类接口中的<code>&lt;clinit&gt;()</code>方法。只有在父接口中定义的变量被使用的时候，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程的环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都会阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中这种阻塞很隐蔽。</p>
<h3 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h3><h4 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h4><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规范了有且只有下列五种情况必须对类进行初始化（加载、验证、准备、解析都会随之发生）</p>
<ul>
<li>遇到new，getstatic，putstatic，invokestatic这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：使用new关键字实例化对象的时候；读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类还没有初始化，则需要先触发初始化</li>
<li>当初始化一个类的时候，发现其父类还没有初始化，则需要先初始化其父类</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法的句柄所对应的类没有初始化，则需要先触发其先初始化</li>
</ul>
<h4 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h4><p>上述五种场景的行为被称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用如下：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类被初始化。下列代码会输出”父类初始化…..”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String s = <span class="string">"Hello World!"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类初始化....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类初始化......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承字Object的子类，其中包含了数组的属性和方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Son[] son = <span class="keyword">new</span> Son[<span class="number">10</span>]; <span class="comment">// 不会初始化Son</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Father.s);<span class="comment">// 不会初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>两个类相等，需要类本身相等，并且使用同一个类加载器加载，这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的Class对象的equals()方法，isAaaignableFrom()方法，isInstance()方法的返回结果为true，也包括使用instanceOf关键字做对象所属关系判定结果为true</p>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>从Java虚拟机的角度来说，只存在一下两种类加载器：</p>
<ul>
<li>启动类加载器（Boostrap ClassLoader）：使用C++实现，是虚拟机自身的一部分</li>
<li>所有其他类加载器，使用Java实现，独立于虚拟机，继承自抽象类java.land.ClassLoader</li>
</ul>
<p>从java开发人员的角度来看，类加载器可以划分的更细：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader） ：此类加载器负责将存放在<code>JRE_HOME\lib</code>目录中的或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是被虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在目录下也不会被加载）类库加载到虚拟机内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器的时候，如果需要把加载请求委派给启动类加载器，直接说过null即可</li>
<li>扩展类加载器（Extension ClassLoader）：这个启动类加载器是由ExtClassLoader实现的，它负责将<code>JAVA_HOME/lib/ext</code>或者被java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器是由AppClassLoader实现的，这个类加载器是ClassLoader中的getClassLoader()方法的返回值，因此一般称为系统类加载器，他复杂加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下就是这个程序中的默认的类加载器。</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自定定义的类加载器。</p>
<p>下图就是双亲委派模型（Parents Delegation Model）的实现，该模型要求除了顶层的启动类加载器之外，其他的类加载器都要有自己的父加载器，这里的父子关系一般通过组合关系（表示我这个类由上一个类加载器，而我并不依赖他。所以非继承，是组合，has-a关系）来实现，而不是继承关系。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581672815558.png" alt="1581672815558"></p>
<h4 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h4><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成加载时才尝试自己加载</p>
<h4 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h4><p>使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h4><p>代码中很明显父类加载失败，才尝试自己去加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>一般自定义类加载器都是覆写findClass方法，然后通过defineClass将字节码转换成java.lang.Class类的实例。</p>
<p>自定义文件系统类加载器</p>
<p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、JVM优化"><a href="#五、JVM优化" class="headerlink" title="五、JVM优化"></a>五、JVM优化</h2><table>
<thead>
<tr>
<th>操作命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>打印HotSpot VM的进程</td>
</tr>
<tr>
<td>jstat</td>
<td>查看HotSpot VM运行时信息</td>
</tr>
<tr>
<td>jinfo</td>
<td>查看和修改虚拟机各项参数</td>
</tr>
<tr>
<td>jmap</td>
<td>heapdump：生成VM堆转储快照、查询finalize执行队列、Java堆和永久代详细信息</td>
</tr>
<tr>
<td>jstack</td>
<td>查看VM当前时刻的线程快照：当前VM内每一条线程正在执行的方法堆栈集合</td>
</tr>
<tr>
<td>javap</td>
<td>查看经javac编译后产生的JVM字节码代码</td>
</tr>
<tr>
<td>jcmd</td>
<td>多功能工具，可以用来导出堆，查看java进程、导出线程信息，执行GC、查看性能相关数据</td>
</tr>
<tr>
<td>jconsole</td>
<td>基于JMX的可视化监视、管理工具</td>
</tr>
<tr>
<td>jvisualvm</td>
<td>JDK中最强大运行监视和故障处理工具</td>
</tr>
</tbody></table>
<p><code>jps -l</code>：显示线程id和执行线程的主类名</p>
<p><code>jps -v</code>：显示线程id和执行线程的主类名和JVM配置信息</p>
<p><code>jstat -参数 线程id 执行时间 执行次数</code> =&gt; <code>jstat -gc 4488 30 10</code>：表示查看线程4488，30秒内执行10此的GC信息。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之动态规划</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ输入输出学习</title>
    <url>/2020/03/21/OJ%E5%9C%A8%E7%BA%BF%E5%88%A4%E9%A2%98%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="OJ在线判题学习"><a href="#OJ在线判题学习" class="headerlink" title="OJ在线判题学习"></a>OJ在线判题学习</h1><h2 id="1-正确处理输入格式"><a href="#1-正确处理输入格式" class="headerlink" title="1. 正确处理输入格式"></a>1. 正确处理输入格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预先不知道数据的组数---直接读到文件结尾</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事先知道数据组数---读数据组然后循环</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数据的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的只有一组数据---直接读</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line"><span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">System.out.println(a+b);</span><br></pre></td></tr></table></figure>

<h2 id="2-正确处理输出格式"><a href="#2-正确处理输出格式" class="headerlink" title="2. 正确处理输出格式"></a>2. 正确处理输出格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要输出case数</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数据的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要输出case数</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">" "</span> + (a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个case之后要有空行</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">" "</span> + (a + b)+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个case之间有空行</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">// 数组的组数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Case:"</span> + (i + <span class="number">1</span>) + <span class="string">"结果为: "</span> + (a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-处理细节和技巧"><a href="#3-处理细节和技巧" class="headerlink" title="3. 处理细节和技巧"></a>3. 处理细节和技巧</h2><ul>
<li><p>不用实现可以保存所有输入，读一组计算一组，Java建议使用BufferedInputStream</p>
</li>
<li><p>注意输出格式</p>
<ul>
<li>字母大小写</li>
<li>换行的时刻</li>
<li>输出“case”之后有没有”#”或者”:”之类的</li>
<li>每行末尾有”\n”，但一般没有空白</li>
<li>java尽量使用BufferedOutputStream</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之树</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之双指针</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之字符串</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见算法题</title>
    <url>/2020/03/21/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1. 最长公共子序列(Leetcode 1143)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/23 22:10</span></span><br><span class="line"><span class="comment"> * 最长公共子序列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 找出两个字符串的最长公共子序列长度</span></span><br><span class="line"><span class="comment"> * "abcde" "ace" 3</span></span><br><span class="line"><span class="comment"> * "bcde"  "de" 2 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubsequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果第一个都不相等怎么解决这个问题？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (text1.length() == <span class="number">0</span> || text2.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = text2.length() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果相等的话,即1的前i-1与2的前j-1的基础上加1</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果不能的话就看1的前i个与2的前j-1个，与1的前i-1个与2的前j个之间的大小情况</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongestCommonSubsequence test = <span class="keyword">new</span> LongestCommonSubsequence();</span><br><span class="line">        <span class="keyword">int</span> i = test.longestCommonSubsequence(<span class="string">"abcde"</span>, <span class="string">"ace"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 硬币组合问题（Leetcode面试题）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/23 21:49</span></span><br><span class="line"><span class="comment"> * 换硬币问题，典型的背包问题</span></span><br><span class="line"><span class="comment"> * dp[i][j] 表示第i个物品是j空间的总数</span></span><br><span class="line"><span class="comment"> * dp[i][j] 一方面等于没有取第i个物品，此时背包空间j</span></span><br><span class="line"><span class="comment"> * 另一方面的等于去了第i个物品，此时背包空间为j-coins[i]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaysToChange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 第一列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>; <span class="comment">// 第一行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个硬币值开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; <span class="comment">// 空间为n</span></span><br><span class="line">                <span class="comment">// 前提是硬币需要大于当前适配的硬币值</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i]]) % <span class="number">1000000007</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果当前硬币值不大于适配的硬币面值，则只能顺应上一级的</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]; <span class="comment">// 放不下，价值没法增加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 零钱兑换(Leetcode 322)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选的面额，一定的钱，用最少的硬币个数凑成面额值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &gt; i)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">// 背包装不下，直接下一个</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 否则的话，判断背包装了这个硬币+1，之后与之前的大小，取最小的</span></span><br><span class="line">                    dp[i] = Math.min(dp[i],<span class="number">1</span>+dp[i-coin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之数组</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong>Leetcode 11 盛水最多的容器</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/24 21:15</span></span><br><span class="line"><span class="comment"> * Leetcode 11 : 盛水最多的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxWaterArea</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 小值的后面遇到获取到更大的容量概率更大，每次移动最小的那个即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用双指针</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> width = r - l;</span><br><span class="line">            <span class="keyword">int</span> h = Math.min(height[l], height[r]);</span><br><span class="line">            res = Math.max(res, width * h);</span><br><span class="line">            <span class="comment">// 谁小谁往前走，越小越可能遇到面积大的</span></span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Leetcode 15 三数之和</strong> :star:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.duanxi.leetcode.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/24 21:26</span></span><br><span class="line"><span class="comment"> * Leetcode 15 : 三数之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度分析：排序算法时间复杂度O(nlogn) 遍历时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">     * 总的时间复杂度为O(nlogn)+O(n^2)=O(n^2)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 首先排序，使用一次遍历数组，遍历的时候注意去重操作。因为三数之和需要为0，当遍历的数大于0的时候，直接返回。</span></span><br><span class="line"><span class="comment">     * 随后使用双指针策略来从两边夹逼，获取到值，注意去除重复，使用while循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// res中不能出现重复,如何实现去重?</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为排序了，如果大于零在往右走找不到相加为0的</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 去重操作，防止重复的三元组</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用双指针夹逼</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[l] + nums[r] + nums[i];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r - <span class="number">1</span>] == nums[r]) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 注意一定要先去重然后在走</span></span><br><span class="line">                    r--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l + <span class="number">1</span>] == nums[l]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                    <span class="comment">// 两个一起走，这样可以避免漏掉</span></span><br><span class="line">                    <span class="comment">// [-2,0,1,1,2] 如果不是一起走会漏电-2 1 1 因为到了0 2处此时需要同时前进。</span></span><br><span class="line">                    <span class="comment">// [-2,0,0,2,2] 此时注意重复的-2 0 2</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l + <span class="number">1</span>] == nums[l]) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r - <span class="number">1</span>] == nums[r]) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 先去除重复，然后依次向中间进一步</span></span><br><span class="line">                    l += <span class="number">1</span>;</span><br><span class="line">                    r -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>Leetcode 31 下一个排列 *</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/25 22:36</span></span><br><span class="line"><span class="comment"> * Leetcode 31 : 下一个排列</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 必须原地修改，只允许使用额外常数空间。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</span></span><br><span class="line"><span class="comment"> * 1,2,3 → 1,3,2</span></span><br><span class="line"><span class="comment"> * 3,2,1 → 1,2,3</span></span><br><span class="line"><span class="comment"> * 1,1,5 → 1,5,1</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/next-permutation</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextPermutation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n),最坏的情况需要进行两次扫描</span></span><br><span class="line">    <span class="comment">// 空间复杂度O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原地修改</span></span><br><span class="line">        <span class="comment">// 如何判断是否是最大的排列</span></span><br><span class="line">        <span class="comment">// 1 2 3 =&gt; 1 3 2 =&gt;</span></span><br><span class="line">        <span class="keyword">int</span> l = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 一直向前走，注意等于的情况</span></span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l + <span class="number">1</span>] &lt;= nums[l]) &#123;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有全部逆序，此时需要从后往前找到第一个大于当前数的数，然后后面的数翻转即可</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示不是全都是逆序</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[l]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, j, l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是全部逆序，直接全部翻转，注意翻转是从l+1开始</span></span><br><span class="line">        reverse(nums, l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = start;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            swap(nums, l++, r--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Leetcode 39 组合总和</strong>:star:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caoduanxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/3/26 23:05</span></span><br><span class="line"><span class="comment"> * Leetcode 39 : 组合总和</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 数组数字多少个数组合可以组成这个目标数，输出list</span></span><br><span class="line"><span class="comment"> * 标准的回溯法，注意回溯需要剪枝</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(2^n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">if</span> (candidates.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 有一个开始的起点</span></span><br><span class="line">        combine(candidates, target, res, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> start, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 如果回溯到小于0</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break是直接终止当前for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            <span class="comment">// 对于当前的i来说target需要变为那么大</span></span><br><span class="line">            combine(candidates,target-candidates[i],res,i,list);</span><br><span class="line">            <span class="comment">// 需要回退一个</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识</title>
    <url>/2020/03/21/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><h2 id="1-Redis与Memcache的区别"><a href="#1-Redis与Memcache的区别" class="headerlink" title="1. Redis与Memcache的区别"></a>1. Redis与Memcache的区别</h2><ul>
<li>Memcache代码层类似hash</li>
<li>Memcache支持简单数据类型，Redis支持丰富的数据类型</li>
<li>Memcache不支持数据持久化存储，Redis支持数据磁盘持久化存储</li>
<li>Memcache不支持主从，Redis支持主从</li>
<li>Memcahce不支持分片，Redis支持分片</li>
</ul>
<h2 id="2-Redis为什么这么快？"><a href="#2-Redis为什么这么快？" class="headerlink" title="2. Redis为什么这么快？"></a>2. Redis为什么这么快？</h2><p>官方给出的数据是100000+QPS，redis快的原因：</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li>
<li>数据结构简单，对数据操作也简单</li>
<li>采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例</li>
<li>使用多路I/O复用模型，阻塞IO</li>
</ul>
<h2 id="3-多路I-O复用模型"><a href="#3-多路I-O复用模型" class="headerlink" title="3. 多路I/O复用模型"></a>3. 多路I/O复用模型</h2><p>FD：File Descriptor，文件描述符</p>
<p>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的数据。</p>
<p><strong>Redis采用的I/O多路复用函数：epoll、kqueue、evport、select</strong></p>
<ul>
<li>因地制宜</li>
<li>优先选择时间复杂度为O(1) 的I/O多路复用函数作为底层实现</li>
<li>以时间复杂度为O(n)的select作为保底</li>
<li>基于react设计模式监听I/O事件</li>
</ul>
<h2 id="4-Redis常用的数据类型"><a href="#4-Redis常用的数据类型" class="headerlink" title="4. Redis常用的数据类型"></a>4. Redis常用的数据类型</h2><p>String：最基本的数据类型，二进制安全。</p>
<p>底层实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len; <span class="comment">// buf数据已占用的长度</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// buf中剩余可用空间的长度</span></span><br><span class="line">	<span class="keyword">char</span> buf[]; <span class="comment">// 数据空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Hash：String元素组成的字典，适合存储对象。底层实现：字典</p>
<p>List：列表，按照String元素插入顺序排序（有序）。底层实现：链表</p>
<p>Set：String元素组成的无序集合，通过哈希实现，不允许重复（无序）：底层使用整数集合来存储</p>
<p>Sorted Set：通过分数来为集合中的成员进行从小到大的排序。（按照分数高低排序，也就是由分数权重）：跳跃表。时间复杂度O(logn)（最坏的情况下是O(n)）,跟二叉树有的一拼，时常用来代替二叉树。</p>
<h2 id="5-跳跃表"><a href="#5-跳跃表" class="headerlink" title="5. 跳跃表"></a>5. 跳跃表</h2><p>Sorted Set底层是基于跳跃表实现的。什么是跳跃表呢。其实就是链表，但是与链表不同的是，这是有层次的链表，什么意思呢，因为链表的查找很费时间，O(n)，查询效率低下，一旦用到数据量大的查询上面，性能不佳。此时为了提升查询的速度，提出了跳跃表的这种结构，从链表中提取出关键节点，一般是上一层是下一层的一半，提取的极限是那一层不大于2个节点时（≤2）停止提取。</p>
<p><img src="https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528210921601-949409375.png" alt="img"></p>
<h2 id="6-面试题：从海量key中查询出某一固定前缀的key"><a href="#6-面试题：从海量key中查询出某一固定前缀的key" class="headerlink" title="6. 面试题：从海量key中查询出某一固定前缀的key"></a>6. 面试题：从海量key中查询出某一固定前缀的key</h2><p>使用keys pattern来匹配，但是如果数据量巨大的话，会造成客户端卡段。keys指令一次性返回所有匹配的key。键的数量过大会造成服务的卡段，对于内存的消耗是一个隐患，对于redis这样的内存型数据库。</p>
<p><strong>scan cursor [MATCH pattern] [COUNT count]</strong>，基于游标的迭代器</p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li>
<li>一次返回的数量不可控，只能是大概率符合count参数</li>
</ul>
<p><code>scan 0 match n* count 1</code> 表示查询从0开始的以n开头的数据的一条记录。</p>
<h2 id="7-Redis实现分布式锁"><a href="#7-Redis实现分布式锁" class="headerlink" title="7. Redis实现分布式锁"></a>7. Redis实现分布式锁</h2><p>分布式锁需要解决的问题：</p>
<ul>
<li>互斥性</li>
<li>安全性</li>
<li>死锁</li>
<li>容错</li>
</ul>
<p><strong>第一种方案：使用SETNX+EXPIRE方案</strong></p>
<p>SETNX key value 如果这个key不存在，则设置这个value，时间复杂度O(1)，成功返回1，失败返回0</p>
<p>一般利用setnx来获取到锁，一旦获取到锁之后，采用expire的时间来释放锁，从而实现分布式锁。</p>
<p>解决setnx长期有效的问题采用的是expire来实现的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 大致的伪代码</span><br><span class="line">long num = setnx(key,value)</span><br><span class="line">if(num==1)&#123;expire key time;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的缺点在于一旦发生了某个节点的宕机，而此节点正好获取到了锁，此时未能设置expire造成原子性得不到满足。</p>
<p>setnx是原子操作，expire也是原子操作，但是两者在一起却不是原子操作</p>
<p><strong>第二种方案：使用SET+EXPIRE方案</strong></p>
<p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<ul>
<li>EX：设置的是存活的秒数</li>
<li>PX：设置的是存活的毫秒数</li>
<li>NX：只有键不存在的时候，才设置值</li>
<li>XX：只有键存在的时候，才设置值</li>
</ul>
<p>SET方法可以满足原子性，设置成功返回1，设置失败返回nil，由此实现Redis的分布式锁。</p>
<h2 id="8-Redis如何实现消息队列"><a href="#8-Redis如何实现消息队列" class="headerlink" title="8. Redis如何实现消息队列"></a>8. Redis如何实现消息队列</h2><p><strong>第一种方案使用lpush+rpop</strong></p>
<p>使用<code>lpush testlist &quot;aaa&quot;</code>实现从左向右推元素，完成消息的生产。</p>
<p>使用<code>rpop testlist</code>实现从右边弹出，完成消息的消费。</p>
<p><strong>存在的缺点：</strong></p>
<ul>
<li>没有等待队列中有值就直接消费</li>
<li>弥补：可以通过在应用层中引入sleep机制去调用lpop重试</li>
</ul>
<p><strong>第二种方法使用blpop+rpush</strong></p>
<p>BLPOP key[key] timeout：阻塞直到队列有消息或者超时</p>
<p>BLPOP使用的话是用来精确定时，也就是在设置的timeout中看阻塞队列中是否有消息。</p>
<p>缺点：每次生产的消息只能够供一个消费者消费。</p>
<p><strong>多个消费者的问题，使用pub/sub模式来解决：主题订阅者模式</strong></p>
<ul>
<li>发送者（pub）发送消息，订阅者（sub）接收消息</li>
<li>订阅者可以订阅任意数量的频道</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582621048095.png" alt="1582621048095"></p>
<p>使用pub/sub主题订阅者模式实现一个消息多个消费者消费的问题。</p>
<p><strong>缺点：</strong></p>
<p>消息的发布是无状态的，无法保证可达。</p>
<p>消息发布的时候下线，然后上线，这个消息，订阅者是接收不到的。如果要保证可达需要使用kafka，专业的消息队列</p>
<h2 id="9-Redis如何实现持久化"><a href="#9-Redis如何实现持久化" class="headerlink" title="9. Redis如何实现持久化"></a>9. Redis如何实现持久化</h2><h3 id="9-1-RDB"><a href="#9-1-RDB" class="headerlink" title="9.1 RDB"></a>9.1 RDB</h3><p>RDB快照持久化：保存某个时间点的全量数据快照。</p>
<ul>
<li>save：阻塞Redis的服务器进程，直到RDB文件被创建完毕</li>
<li>BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器</li>
</ul>
<p><strong>自动触发RDB持久化的方式：</strong></p>
<ul>
<li>根据redis.conf中配置的save m n定时触发，用的是bgsave</li>
<li>主从复制的时候，主节点自动触发</li>
<li>执行Debug Reload</li>
<li>执行shutdown且没有开启AOF持久化</li>
</ul>
<p>BGSAVE的工作原理：</p>
<ul>
<li>检查子进程（看是否有RDB或者AOF的子进程正在工作），存在的话返回错误</li>
<li>触发持久化，调用rdbSaveBackground</li>
<li>fork出一个子进程完成save操作，当前进程继续响应其他操作</li>
</ul>
<p>系统调用fork()，创建进程，实现copy-on-write:</p>
<p>如果有多个调用者同时要求相同资源（如内存或者磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用视图修改资源的内容时，系统才会真正复制一份专用副本给调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p><strong>RDB持久化的缺点：</strong></p>
<ul>
<li>内存数据的全量同步，数据量大会由于I/O而严重影响性能。</li>
<li>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据。</li>
</ul>
<h3 id="9-3-AOF"><a href="#9-3-AOF" class="headerlink" title="9.3 AOF"></a>9.3 AOF</h3><p><strong>AOF：append-only-file ：保持写状态</strong></p>
<ul>
<li>记录下除了查询以外所有变更数据库的指令</li>
<li>以append的形式追加保存到AOF文件中（增量）</li>
</ul>
<p><strong>由于AOF文件是不断追加形式的，日志重写解决AOF文件不断增大的问题，步骤如下：</strong></p>
<ul>
<li>调用fork()，创建一个子进程</li>
<li>子进程把新的AOF写到一个临时文件中，不依赖原来的AOF文件</li>
<li>主进程持续将新的变动写到内存和原来的AOF文件中</li>
<li>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动</li>
<li>使用新AOF文件替换掉旧的AOF文件</li>
</ul>
<p><strong>Redis数据的恢复：</strong>一般是RDB和AOF文件共存时候的问题。</p>
<ul>
<li>存在AOF，则加载AOF文件，否则加载RDB，如果两者都不存在，报加载失败。</li>
</ul>
<p><strong>RDB和AOF的对比：</strong></p>
<ul>
<li>RDB优点：全量数据快照，文件小，恢复快</li>
<li>RDB缺点：无法保存最近一次快照以后的数据</li>
<li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li>
<li>AOF缺点：文件体积大，恢复时间长</li>
</ul>
<p><strong>Redis如何做持久化</strong>：现在支持RDB-AOF混合持久化</p>
<ul>
<li>BGSAVE做镜像全量持久化，AOF做增量持久化</li>
</ul>
<h2 id="10-Pipeline"><a href="#10-Pipeline" class="headerlink" title="10. Pipeline"></a>10. Pipeline</h2><p>使用Pipeline的好处：</p>
<ul>
<li>Pipeline和Linux的管道相似</li>
<li>Redis基于请求/响应模式，单个请求处理需要一一应答</li>
<li>Pipeline批量执行指令，节省多次I/O往返的时间</li>
<li>有顺序依赖的指令建议分批分送</li>
</ul>
<h2 id="11-Redis的同步机制"><a href="#11-Redis的同步机制" class="headerlink" title="11. Redis的同步机制"></a>11. Redis的同步机制</h2><p><strong>主从同步的全同步过程：</strong></p>
<ul>
<li>Slave发送sync命令到Master</li>
<li>Master启动一个后台进程，将Redis中的数据快照保存到文件中</li>
<li>Master将保存数据快照期间接收到的写命令缓存起来（此时写命令属于增量）</li>
<li>Master完成写操作之后，将该文件发送给slave</li>
<li>使用新的AOF替换掉旧的AOF文件</li>
<li>Master将这期间收集到的增量写命令发送给slave端</li>
</ul>
<p><strong>增量同步过程</strong>：</p>
<ul>
<li>Master接收到用户的操作指令，判断是否需要传播到slave</li>
<li>将操作记录追加到AOF文件</li>
<li>将操作传播到其他slave：1. 对齐主从库；2.往响应缓存写入指令</li>
<li>将缓存中的数据发送给slave</li>
</ul>
<p><strong>Redis Sentinel哨兵：高可用</strong></p>
<ul>
<li>监控：检查主从服务器是否运行正常</li>
<li>提醒：通过API向管理员或者其他应用程序发送故障通知</li>
<li>自动故障迁移：主从切换</li>
</ul>
<p><strong>流言协议Gossip</strong>：在杂乱无章中寻求一致</p>
<ul>
<li>每个节点都随机地与对方通信，最终所有节点的状态达成一致</li>
<li>种子节点定期随机向其他节点发送节点列表以及需要传播的消息</li>
<li>不保证信息一定会传递给所有节点，但是最终会趋于一致</li>
</ul>
<h2 id="12-Redis的集群原理"><a href="#12-Redis的集群原理" class="headerlink" title="12. Redis的集群原理"></a>12. Redis的集群原理</h2><p><strong>从海量的数据中找到所需：</strong></p>
<ul>
<li>分片：按照某种规则去划分数据，分散存储在多个节点上</li>
<li>常规的按照哈希划分无法实现节点的动态增减。</li>
</ul>
<p><strong>一致性哈希算法</strong>：对2<sup>32</sup>取模，将哈希值组织成虚拟的圆环</p>
<p><strong>将数据key使用相同的函数Hash计算出hash值，由于是环状的，所有的节点计算出的hash值都会按照顺时针归属为自己最近的节点。无论是节点宕机还是增加节点都比较方便。但是这样不可避免的会出现节点过少，此时由于节点分布不均匀，将会导致数据的倾斜问题产生，此时需要引入虚拟节点来解决数据倾斜的问题，也就是同一节点再细分成不同的编号组，以此使得数据倾斜问题被解决。</strong></p>
<h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>本章主要介绍的是redis的相关知识，首先从基础的结构将其，redis作为内存型数据库，操作数据的能力是非常快的，且有丰富的数据类型，数据操作简单。连接Memcache与Redis的区别，随后为什么redis这么快，主要是直接操作内存，数据操作简单，单线程，多了I/O复用，随后通过从海量的key中找出固定前缀的key，引出keys pattern和scan基于游标的迭代获取结果数据方式。</p>
<p>随后介绍分布式锁，分布式锁需要解决的问题是，互斥性，安全性，死锁以及容错四个特性，使用SETNX+EXPIRE实现分布式锁，由于存在破坏原子性的可能，使用SET直接设置可以实现原子性，实现分布式锁。随后通过list中的常用的lpush+rpop实现消息队列，使用BLPOP+RPUSH+timeout实现定时获取消息的机制。但是这存在一个消息只能有一个消费者。</p>
<p>如果一个消息需要被多个消费者消费的话，需要使用pub/sub模式，订阅发布模式来实现，虽然能够实现一个消息被多个消费者消费，但是不能够保证消息的可达性，也就是发布者不能保证订阅者一定能够接收到消息。（一个是发送的无状态，不能保证可达，还有一个就是如果发布消息的时候订阅者上线，然后上线，这条消息也是接收不到的。如果需要解决需要依赖于专业的消息队列中间件KafKa）</p>
<p>随后介绍持久化的实现基于BGSAVE的快照RDB实现，以及操作数据的AOF文件追加实现，现在支持两种方案并行使用。</p>
<p>然后就是介绍Pipeline的机制，节省多次I/O往返时间。介绍了Redis的主从同步机制以及增量的同步机制。Redis哨兵的高可用性以及流言协议Gossip对于同步的最后趋于一致性的作用。</p>
<p>最后就是介绍Redis的集群原理，主要是通过分片，对数据Hash取模值，最后形成hash环以此将数据相对比较均匀的分散到各个节点之上。如果遇到节点数过少，此时数据可能产生倾斜，此时需要使用单个节点多次编号来解决这个问题，使得数据分布相对均匀。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>备战面试基础知识-2</title>
    <url>/2020/03/21/%E5%A4%87%E6%88%98%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="备战滴滴面试"><a href="#备战滴滴面试" class="headerlink" title="备战滴滴面试"></a>备战滴滴面试</h2><h3 id="———————————–第一部分———————————–"><a href="#———————————–第一部分———————————–" class="headerlink" title="———————————–第一部分———————————–"></a>———————————–第一部分———————————–</h3><p><strong>1.set map list</strong></p>
<p>常见的HashSet HashMap ArrayList</p>
<p>一般是HashMap和LinkedHashMap，然后就是HashSet的实现。以及ArrayList与LinkedList之间的区别。</p>
<p><strong>2.TreeSet和HashSet对比之间的区别？</strong></p>
<p>一个有序一个无序</p>
<p><strong>3.HashMap和ConcurrentHashMap的区别？</strong></p>
<p>HashMap底层是基于数组+链表+红黑树实现的，ConcurrentHashMap的底层是Node+链表+红黑树来实现的，且并发安全的实现是依赖synchronized+CAS来实现的。</p>
<p><strong>4.线程池的参数有哪些？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,       TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>

<p>corePoolSize核心线程个数，最大的线程个数，线程池中线程存活时间，时间的单位，阻塞队列</p>
<p><strong>5.线程池的拒绝策略？</strong></p>
<p>如果超出了线程池的数量限制大小，此时需要使用到线程池的拒绝策略。被拒绝的理由可能是由于：1.线程池异常关闭，2. 任务数量超过线程池的最大限制</p>
<p>其中在ThrealPoolExecutor构建线程池的时候，底层会调用ThreadPoolExecutor来构建线程池。其中有线程策略handler：</p>
<p>默认的拒绝策略为AbortPolicy</p>
<ul>
<li>AbortPolicy：任务到线程池中被拒绝时，将会抛出RejectedExecutionException异常</li>
<li>DiscardPolicy：拒绝任务的处理程序，静默丢弃被拒绝的任务。</li>
<li>DiscardOldestPolicy：线程池会放弃等待最久的未处理任务，然后将被拒绝的任务添加到等待队列中</li>
<li>CallerRunsPolicy：在线程池当前正在运行的Thread线程池中处理被拒绝的任务</li>
</ul>
<p><strong>5.SynchronizedBlockQueue中到底可以存几个？</strong></p>
<p>存一个，他是一个缓存值为1的阻塞队列，但是IsEmpty()方法永远返回true。remove方法返回false，iterator方法永远返回空，peek方法永远返回null</p>
<p><strong>6.锁用过吗？常见的有哪些锁？</strong></p>
<p>用过，乐观锁，悲观锁，synchronized, reentrantLock, 偏向锁，轻量级锁，自旋锁。重量级锁</p>
<p><strong>7.锁的方法：tryLock，lock, lockInterruptily()</strong></p>
<p>lock的方法不能被外部打断，但是lockInterruptily可以，但是会抛出异常</p>
<p><strong>8.lock和tryLock的区别？</strong></p>
<p>一个是直接锁，一个是尝试获取锁。区别就是直接锁也会去做判断，看看自己是否能获取锁，尝试锁的话就要去判断当前的线程的状态值，看看是否锁被占用或者有可重入锁的机会，如果都没有的话，返回false</p>
<p><strong>10.公平锁与非公平锁的实现有什么区别？</strong></p>
<p>公平锁的话就是直接获取锁，出现了在尝试获取锁的时候如果当前对象没有被上锁，需要先判断队列中自己前面是否有线程，保证按照顺序来。</p>
<p>非公平锁的话，就是在调用lock方法的时候如果没有人上锁，就直接上锁了，不然的话就要去tryAcquire获取锁，这个大家都是争抢锁资源。</p>
<p><strong>11.类加载的机制是怎么样的？</strong></p>
<p>类加载过程：加载—连接（验证、准备、解析）—初始化—使用—卸载</p>
<p><strong>12.tomcat的加载过程？</strong></p>
<p>getServer–getConnector–Server.start–startService–启动Engine–启动host–启动context–启动connector–EndPoint启动</p>
<p><strong>13.Spring的生命周期？Spring的源代码一定要看啊！！！**</strong></p>
<p>Bean的生命周期：创建（调用构造函数）—set方法注入属性–BeanNameAware–BeanFactoryAware–ApplicationContextAware–BeanPostProcessor的before方法–InitializingBean—自定义init方法–BeanPostProcessord的after方法–使用–容器的销毁–DisposableBean的destory–自定义销毁方法。</p>
<p><strong>14.AOP</strong></p>
<p>Spring的AOP是面向切面编程，可以通过切面向类或者方法中插入日志，通知等方法。可以通过BaseSchema实现以及AspectJ或者其注解来实现，主要是通过动态代理技术来实现的，动态代理分为JDK动态代理，能够代理实现了其接口的类。还有就是cglib代理，通过字节码构造这个类的一个实例对象进行代理。静态代理和动态代理的区别，静态代理只能代理实现了其接口的一个类，且静态代理在代理之前就知道了代理对象，而动态代理是在运行过程中才知道代理的对象。{jdk动态代理的实现主要是实现了InnovationHandler接口，重写其中的invoke方法来调用。而CGLIB动态代理的话是通过实现接口MethodInterceptor重写intercept方法来实现代理，其中是通过字节码来动态的构建代理对象的子类重写其方法来实现的}</p>
<p><strong>15.ASM怎么实现AOP？</strong></p>
<p>ASM是一个Java字节码操纵框架，能够被用来动态生成类或者增强其持有类的功能。ASM可以直接产生二进制class文件，也可以在类被加载进Java虚拟机之前就动态改变类的行为，Java class被存储在严格格式定义的.class文件中，这些类文件拥有足够的源数据来解析出类中所有元素：类名称、方法、属性以及Java字节码。ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p>
<p><strong>16.MyBatis的插件？</strong></p>
<p>pageHelper，但是一般用的都是MyBatisPlus</p>
<p><strong>17.项目：自己在自己的项目中干了什么？从项目中学习到了什么？复盘自己的项目</strong></p>
<p>首先是在工作中，暑期实习的地方是做电商的B2b，记忆深一点的就是当时做的活动模块，大致的环境配置就是使用SpringBoot来搭建开发的，主要有使用到的的技术有spring,springmvc,redis,mybatis,mysql,等等，使用postman作为测试组件来测试代码的功能完整性。对于在测试环境下的出现的代码错误，会通过linux查看具体错误的心底，定位到具体的错误代码。</p>
<p>在项目java高并发秒杀系统中，主要使用的SSM搭建的环境开发框架，其中使用到了redis做后端的缓存，因为项目不是太大，在慕课网上看的，所以用到的技术不是很多，这个项目分成三个部分，前端模块，后端模块，数据库模块，在这之中的话，因为是高并发项目，所以前端的优化是使用 CDN内容分发网络（Content Delivery Network）将前端的静态资源存储减少并发，同时对于用户多点对于后台造成的并发，使用前端点击之后按钮变灰，对于用户多次刷新页面的可以采用拦截，限制某个账户访问的次数。同时还可以使用中间件例如消息队列，来将高峰时期的请求都存入消息队列中，后端根据自己的处理能力从消息队列中获取请求然后处理。数据库层面的话，如果都直接访问mysql数据库的话，数据库可能会崩掉，可以采用redis对数据库中的部分数据做一个缓存，这样的话可以适当减小数据库的压力，或者使用redis来保存数据库中的数据，在redis中进行相应的数据操作，最后将redis中的数据同步至mysql数据库中即可。</p>
<p><strong>18.数据库中的隔离级别有什么用？</strong></p>
<p>解决数据库<strong>并发</strong>操作中可能出现的脏读，幻读等问题</p>
<p><strong>19.隔离级别什么时候起作用呢？</strong></p>
<p>事务对数据库中的数据进行操作的时候起作用</p>
<hr>
<h3 id="———————————–第二部分———————————–"><a href="#———————————–第二部分———————————–" class="headerlink" title="———————————–第二部分———————————–"></a>———————————–第二部分———————————–</h3><p><strong>1.数据库的索引类型？</strong></p>
<p>唯一索引，聚簇索引，非聚簇索引</p>
<p><strong>2.聚簇索引和非聚簇索引的区别？</strong></p>
<p>在实现上面，都是使用的B+数实现的，但是实现的方式却不同，聚簇索引的话是节点中存储数据索引（键和指针），所有的数据都存储在叶子节点中，比如说一张数据表吧，聚簇索引主索引使用的是主键Row，辅助索引使用的是key+PK cols，也就是找到了当前的辅助索引之后还需要再根据主键来查找，需要查找两次。叶子节点之间通过构成单向链表，适合范围查询</p>
<p>非聚簇索引的话，是每个节点都存储数据索引与数据，主索引使用的是pkcols + rowNumber，辅助索引使用的是key+rowNumber，也就是只需要查一遍。无论是主索引还是从索引，都可以直接定位到数据。</p>
<p><strong>3.二叉树和B+树的区别？</strong></p>
<ul>
<li>B+树所有的数据都是存储在叶子节点上，每次的查找时间稳定</li>
<li>叶子节点都有指向下一个节点的指针，范围查找比较方便</li>
</ul>
<p><strong>4.如果说二叉树的数据都存储在叶子节点上呢？</strong></p>
<p>会线性化成链表</p>
<p><strong>5.平衡二叉树呢？</strong></p>
<p>B+数可以减少磁盘IO次数，如何减少IO次数呢。通过减少构造的树的高度来，B树的高度比平衡二叉树的高度要低，本来是效率更快，但是由于B树对于每一个节点需要比较多次，所以一般来说B树的效率和平衡二叉树是差不多的！</p>
<p>且B树相对于B+树而言，B+树的效率更高磁盘IO更少，因为B+数的data中不存储数据，所以可以存放更多的key，查找肯定更快。一个索引节点只需要一次IO即可</p>
<p><strong>6.磁盘中的文件都是使用B+树格式存储的吗？</strong></p>
<p><strong>7.磁盘怎么存储这些数据？</strong></p>
<p><strong>8.了解哪些文件格式？</strong></p>
<p><strong>9.linux操作系统了解吗？</strong></p>
<p><strong>了解，了解一些它常用的命令。</strong></p>
<p><strong>10.相关的命令用过哪些？</strong></p>
<p>ps -ef/grep/cat/find/netstat -tunpl/-a（表示列出当前网络所有的连接）/vim/tail -f查看日志/tar zxvf 解压缩</p>
<p><strong>11.linux根目录下有哪些文件夹</strong></p>
<p>/etc/bin/var/usr/home/opt/proc/sbin/root</p>
<p><strong>12.手撕翻转二叉树</strong></p>
<p><strong>13.最小路径和</strong></p>
<h3 id="———————————–第三部分———————————–"><a href="#———————————–第三部分———————————–" class="headerlink" title="———————————–第三部分———————————–"></a>———————————–第三部分———————————–</h3><p><strong>1.开源项目了解哪些？</strong></p>
<p>SpringBoot，SpringCloud</p>
<p>2.SpringBoot如何加载源码？</p>
<p>==<strong>待补充</strong>==</p>
<p><strong>3.源码是如何深入学习的？</strong></p>
<p>一般是通过看博客，自己跟着看源码。</p>
<p><strong>4.Spring的启动过程如何了解？</strong></p>
<p>通过Debug的方式来看在启动中都执行了哪些操作</p>
<p><strong>5.tomcat启动的流程，需要加载哪些资源？</strong></p>
<p>getServer–getConnector–Server.start–startService–启动Engine–启动host–启动context–启动connector–EndPoint启动，需要加载服务器资源，连接器资源，host资源，上下文资源，加载web.xml中设置的监听器，过滤器，servlet</p>
<p><strong>6.项目中的收获？</strong></p>
<p><strong>7.负责项目中的哪些点，技术方向的？</strong></p>
<p><strong>8.为什么使用MVC架构？</strong></p>
<p>主要是因为MVC的优点，具有低耦合性，高重用性以及可适用性。拥有较低的生命周期成本，快速的部署，好维护，有利于软件工程化管理。</p>
<p><strong>9.项目中的事务如何实现？</strong></p>
<p>通过加@Transactional注解来实现。</p>
<p><strong>10.事务注解底层是怎么实现的？以及为什么加了这个注解可以实现事务？</strong></p>
<p><strong>源码…..待补充!</strong></p>
<p><strong>11.这个事务和数据库事务的区别？</strong></p>
<p>本质上是一样的，Spring的事务就是对数据库事务的封装，最后本质的实现还是在数据库中实现的，假如数据库不支持事务的话，Spring中的事务是没有任何作用的。数据库的事务简单来说就是开启，回滚和关闭，Spring对数据库事务的包装，原理就是拿一个连接，根据Spring的事务配置，操作这个数据连接对数据库进行事务开启，回滚或者关闭操作。但是Spring除了实现这些功能之外，还配合Spring的传播行为对事务进行了广泛的管理，事务中涉及的隔离级别，以及Spring如何对数据库的隔离级别进行封装，事务与隔离级别放在一起会好理解一点。</p>
<p><strong>12.mybatis你用的是什么数据库连接池c3p0？</strong></p>
<p><strong>13.你还知道其他的数据库连接池吗？</strong></p>
<p>DBCP：依赖Jakarta commons-pool对象池机制的数据库连接池，DBCP可以直接在应用程序中使用，Tomcat中的数据源就是使用的DBCP</p>
<p>c3p0：是一个开源的JDBC连接池，它在lib目录下和Hibernate一起发布，包括实现jdbc3和jdbc2扩展规范说明的Connnection和Statement池的Datasources对象</p>
<p>Durid：阿里出品，淘宝和支付宝专用数据库连接池。Druid的功能十分强大。</p>
<p><strong>14.数据库连接池的功能有哪些？</strong></p>
<ul>
<li>资源重用</li>
<li>更快的系统响应速度</li>
<li>新的资源分配手段</li>
<li>统一的连接管理</li>
<li>避免数据库连接池泄露</li>
</ul>
<p><strong>15.JUC看过哪些，说下AQS实现的机制？</strong></p>
<p>看过Atomic，AQS下的一些类，AQS实现机制。他主要是同步器和锁机制的构建框架。使用AQS能简单高效地构造出应用广泛的大量的同步器。ReentrantLock，Semaphore都是基于AQS。</p>
<p>AQS核心的思想就是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作县策划稿，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS使用CLH队列锁来实现的，即将暂时获取不到锁的线程加入队列中。</p>
<p><strong>16.公平锁与非公平锁的区别？</strong></p>
<p>这个就是一个是按照顺序的，一个不是按照顺序的，这个在尝试获取锁的代码是不同的，公平锁，会先查询队列中是否前面还有节点，而非公平锁不查直接过去锁。</p>
<p><strong>17.lock如何分配线程锁？</strong></p>
<p>看情况而定！没有人占有锁自己就获取锁，如果有人占有锁，看看是不是自己，是的话就重入，如果不是就返回false，获取锁失败。</p>
<p><strong>18.队列呢？了解哪些？</strong></p>
<ul>
<li>ConcurrentLinkedQueue：基础链表同步队列。</li>
<li>LinkedBlockingQueue：阻塞队列，队列容量不足自动阻塞，队列容量为0时自动阻塞</li>
<li>ArrayBlockingQueue：底层数组实现的有界队列，自动阻塞，根据API（add/put/offer）不同，有不同特定，当容量不足的时候，有阻塞能力，add方法在容量不足的时候，能够抛出异常。put方法在容量不足的时候，阻塞等待。offer方法，单参数offer方法不阻塞，容量不足的时候，返回false，当前新增数据操作放弃。三参数offer方法（offer(value,times,timeunit)），容量不足的时候，阻塞times时长，如果在阻塞时长内，有容量空闲，新增数据返回true，如果阻塞时长范围内，无容量空闲，放弃新增数据，返回false。</li>
<li>DelayQueue：延时队列，根据比较机制，实现自定义处理顺序的队列，常用于定时任务。如定时关机，对于缓存超时的数据进行删除，任务超时处理，空闲连接的关闭</li>
<li>LinkedTransferQueue：转移队列，使用transfer方法，实现数据的即时处理。没有消费者就阻塞。</li>
<li>SynchronusQueue：同步队列，是一个容量为0的队列。是一个特殊的TransferQueue。必须现有消费线程等待才可以使用。add方法，无阻塞，若没有消费线程阻塞等待数据，则抛出异常。put方法，有阻塞，若没有消费线程阻塞等待数据，则阻塞。（游戏匹配）</li>
</ul>
<p><strong>19.添加的方法都有哪些？具体讲讲？</strong></p>
<p>add offer put方法</p>
<p><strong>20.各个队列的使用场景：</strong></p>
<p><strong>这一块的东西要实践！</strong></p>
<p><strong>21.JVM看过什么？JVM的常用命令？</strong></p>
<p><font color="red">JVM看过深入理解java虚拟机。常用命令。jstat？如果看一个线程内存回收情况，如何看？</font></p>
<p><strong>22.JVM的类加载解析？如何解析到字节码？</strong></p>
<p><strong>待补充</strong></p>
<p><strong>23.如何验证jdk版本的冲突？jdk.1.6-&gt;1.7</strong></p>
<p><strong>24.类加载器的初始化如何去做？</strong></p>
<p><strong>25.实际运用中的classLoader都有哪些了解？</strong></p>
<p><strong>26.如何实现动态加载，需要使用哪些方法？继承classLoader类，重写findClass方法，调用defineClass方法</strong></p>
<p><strong>27.如何获取当前类的classLoader？</strong></p>
<p><strong>使用getClassLoader方法</strong></p>
<p><strong>28.如何保持建立多个ClassLoader</strong></p>
<p><strong>29.为什么类加载器加载出来的类不一样？</strong></p>
<p>因为每个加载器都有自己的隔离机制</p>
<p><strong>30.jvm的内存模型？</strong></p>
<p>程序计数器，虚拟机栈，本地方法栈，堆，方法区，常量池</p>
<p><strong>31.多线程如何实现主存同步的？</strong></p>
<p>synchronized关键字或者使用锁lock</p>
<p><strong>32.linux通过什么命令去使其他工作内存无效呢？</strong></p>
<p><strong>待补充，没听过的知识点</strong></p>
<p><strong>33.java如何是实现缓存一致性？</strong></p>
<p>volatile，synchronized，lock，wait/notify</p>
<p><strong>34.jvm的锁优化有哪些？</strong></p>
<p>synchronized互斥的重量级锁。（作用：确保线程互斥的访问代码，保证共享变量的修改能够及时可见，可以阻止jvm的指令重排）锁优化的话，采用了锁粗化，锁消除，适应性自旋。不存在多线程竞争，默认是偏向锁。轻量级锁，过渡锁，一般是偏向锁不满足，有多线程并发访问锁定同一个对象的时候，先提升为轻量级锁。只有两个线程争抢锁标记记录的时候，优先使用轻量级锁。适应性自旋，在轻量级锁获取失败的时候，为了避免线程在真实的系统层面被挂起，还会进行一项为自旋锁的优化手段。</p>
<p>锁粗化：一般在使用锁的时候，需要让同步的作用范围尽可能的小，仅在共享数据的操作中才进行。这样做的目的，是为了让同步操作的数量尽可能的小，如果出现锁的竞争，也能尽快的获取锁。但是如果遇到已连续的lock和unlock的操作，会导致性能的不必要损耗。<strong>锁粗化就是将连续的同步操作连在一起，粗化为一个范围更大的锁。</strong>锁消除：所消除是jvm进行的另外一项锁优化，该优化更加的彻底。jvm在进行<em>JIT</em>编译(just-in-time compilation)的时候，通过对上下文的扫描，<strong>JVM检测到不可能存在共享数据的晶振，如果这些资源有锁，就会消除这些资源的锁。可以节省毫无意义的锁请求时间</strong>。锁消除的依据，是逃逸分析的数据支持。</p>
<p><strong>35.网络编程了解多少？TCP、UDP，如何创建网络之间的通信？</strong></p>
<p>udp直接就是创建数据报的DatagramSocket通信即可。传输也是使用DatagramPacket来接收</p>
<p>tcp的话需要使用同一个接口来是的数据的传递是可靠的，服务器端使用的是阻塞式的接收客户端的连接。连接之后获取客户端的发送的数据流，将流读出来即可。</p>
<p><strong>36.java的IO了解吗？他们有什么区别？</strong></p>
<p>javaIo主要分为InputStream、OutputStream和Reader、Writer。他们的区别是Stream结尾的都是用来读取字节流，Reader结尾的都是用来读取字符流。</p>
<p><strong>37.BIO、NIO、AIO响应的类了解吗？</strong></p>
<p>BiO：Blocking IO 同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善</p>
<p>NIO：UNblocking IO 同步非阻塞编程，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都不能会被注册到多路复用器上面，多路复用器轮询到连接有IO请求时才启动一个下线程进行处理。</p>
<p>AIO：Asychronous IO：异步非阻塞IO，可以理解为read/write方法都是异步的，完成后会主动调用回调函数。服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>38.shell命令</strong></p>
<p>ls ll  cd pwd mkdir rmdir  cp mv rm du df cat echo head tail wc grep man logout </p>
<p><strong>39.进程的通信方式？</strong></p>
<p>管道、信号量、消息队列、套接字socket</p>
<p><strong>40.Linux的调度方式？</strong></p>
<p>调度机制分为抢占式内核和非抢占式内核。</p>
<p><strong>41.linux的缓存有几级？</strong></p>
<p><strong>待补充</strong></p>
<p><strong>42.jdbc连接mysql的几个步骤，以及如何读取数据，如何实现statement？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedMySQLTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClassName = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/407?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"cao236476"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; className = Class.forName(driverClassName);<span class="comment">// 加载mysql的驱动</span></span><br><span class="line">            Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            Statement statement = connection.createStatement(); // 这个是先产生statement，然后载入sql语句</span></span><br><span class="line">            String sql = <span class="string">"select * from test_user"</span>;</span><br><span class="line">            PreparedStatement statement = connection.prepareStatement(sql);<span class="comment">// 这个必须和sql语句同时载入</span></span><br><span class="line"></span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">            List&lt;User&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                lists.add(<span class="keyword">new</span> User(resultSet.getInt(<span class="string">"id"</span>),</span><br><span class="line">                        resultSet.getString(<span class="string">"name"</span>),</span><br><span class="line">                        resultSet.getInt(<span class="string">"age"</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (User list : lists) &#123;</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet.close();</span><br><span class="line">            statement.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="———————————–第四部分———————————–"><a href="#———————————–第四部分———————————–" class="headerlink" title="———————————–第四部分———————————–"></a>———————————–第四部分———————————–</h3><p><strong>1.字节流和字符流的区别</strong></p>
<p>字节流读取单个字节，字符流读取单个字符。字节流来处理二进制文件（图片，MP3，视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。字节是给计算机看的，字符是给人看的。</p>
<p><strong>2.死锁的四个条件</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求和保持条件：一个进程因为请求资源而被阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已经获得的资源在没有释放之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成了一种头尾相连的循环等待资源关系。</li>
</ol>
<p>解除死锁的方法：</p>
<ol>
<li>剥夺资源：从其他进程剥夺足够数量的资源给死锁线程，以解除死锁状态</li>
<li>撤销进程：可以直接撤销死锁进程或者撤销代价最小的进程，直至有足够的资源可用</li>
</ol>
<p>3.给1G的数据，内存限制为100M，怎么排序？</p>
<p>首先不能选择内存排序，需要选择外存排序，使用多路归并的思路，把数据分为N部分，每部分100M，在使用内存来排序，将排序结果使用外存记录，然后每次从外存冲取记录，在内存中进行比较，从而获取排序的结果。</p>
<p>4.CDN是什么，能谈一谈吗？</p>
<p>CDN是content distribute network，内容分发网络，应用了HTTP协议中的缓存和代理技术，代替源站响应客户端的请求。CDN是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发、调度等功能模块，使用户就近获取所需的内容，降低网络阻塞，提高用户访问响应速度和命中率。CDN中的关键技术有内容存储和分发技术。</p>
<p>5.PUT和POST的区别？</p>
<p>PUT具有幂等性，幂等性是指一次和多次请求同一个资源对于资源本身应该具有同样的结果。即任意多次执行对资源本身所产生的应该与一次执行产生的影响相同。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之链表</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发知识学习</title>
    <url>/2020/03/21/Java%E5%B9%B6%E5%8F%91%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1-使用线程"><a href="#1-使用线程" class="headerlink" title="1. 使用线程"></a>1. 使用线程</h2><p>使用线程的三种方法：准确来说应该是四种：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>使用线程池</li>
</ul>
<h3 id="1-1-继承类与实现接口使用线程对比"><a href="#1-1-继承类与实现接口使用线程对比" class="headerlink" title="1.1 继承类与实现接口使用线程对比"></a>1.1 继承类与实现接口使用线程对比</h3><p>实现接口会更好一些，因为java不支持多继承，但是支持多实现，继承Thread的开销过大</p>
<h2 id="2-线程机制"><a href="#2-线程机制" class="headerlink" title="2. 线程机制"></a>2. 线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>创建提交任务的Runnable任务，管理任务的异步执行，一般是使用它的子接口ExecutorService来创建线程池，无需程序员显式的管理线程的生命周期。这里的异步指代多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>常见的线程池类型有：</p>
<ul>
<li><p>CachedThreadPool：可以任务是线程池容量巨大的线程池</p>
</li>
<li><p>FixedThreadPool：创建固定大小线程个数的线程池</p>
</li>
<li><p>SingleThreadExecutor：创建容量为1个线程的线程池</p>
</li>
<li><p>ScheduledThreadPool：定时线程池</p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>说起线程池，一般的面试会问道线程池一般的类型，构建线程池的参数，以及如何自定义线程池。</p>
<ol>
<li>线程池的类型如上：一般的话还有ForkJoinPool，分支合并线程池</li>
<li>线程池的参数：由下面可以看出核心线程个数，最大线程池个数，线程存活时间，时间单位，阻塞队列。核心线程数与最大线程数的区别在于：一个是公司固定上班员工，一个是加上实习生之后的总的员工数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如何自定义线程池，使用ThreadPoolExecutor创建即可。注意通过Executors可以直接创建已有的上述几种类型的线程池！</li>
</ol>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程，守护线程是在程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，当所有非守护线程运行结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main线程属于非守护线程。创建线程可以使用<code>thread.setDaemon(true)</code>将当前线程设置为守护线程。</p>
<p>守护线程拥有结束自己生命周期的特性，而非守护线程不具备这样的特性。JVM中的垃圾回收线程就是守护线程，一旦程序结束，JVM的垃圾回收也就结束了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行守护thread中的run方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 使用setDaemon方法设置守护线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>sleep字面上理解就是睡觉的意思，在这里指代线程的休眠，线程在指定的时间内啥也不干，处于休眠状态。</p>
<p>注意sleep方法可能会抛出<code>InterruptedException</code>异常，如何有任何线程中断了当前线程的执行，抛出此异常，将会清楚当前线程的中断状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>字面上理解就是礼让的意思，在线程中调用此方法指代当前线程会让出自己的cpu处理器给其他线程处理，该方法只是对线程调度器的一个建议，而且只建议具有相同优先级的其他线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h2><p>线程在正常执行完毕的时候会自行结束，或在发生异常的情况下也会结束。</p>
<h3 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h3><p>中断异常，通过调用Interrupted()方法来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待，就会抛出InterruptedException，从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。</p>
<p>上面意思就是只要是处于阻塞状态或者是sleep，wait，join状态的，只要调用interrupted方法，就会抛出异常！</p>
<p>如果想要中断一个线程的话，可以使用submit方法提交线程，获取一个Future对象，在Future中可以执行对线程的中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可中断系列</span></span><br><span class="line">Future&lt;?&gt; future = <span class="keyword">new</span> ExecutorService().submit(<span class="keyword">new</span> Runnable() &#123;...&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-互斥同步"><a href="#4-互斥同步" class="headerlink" title="4. 互斥同步"></a>4. 互斥同步</h2><p>一般面试的时候会先问进程与线程的区别，然后问进程的通信方式，然后问线程的通信方式。</p>
<p>而线程由于共用一个资源，之间的通信只是对于资源访问的同步机制。</p>
<h3 id="1-同步一个代码块"><a href="#1-同步一个代码块" class="headerlink" title="1. 同步一个代码块"></a>1. 同步一个代码块</h3><p>同步代码块同步的是当前的对象，如果同时有两个线程中的同一个对象想要访问这个对象的这个方法中的资源，第一个线程获取到锁之后，第二个线程只能执行等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是呢，如果创建了两个不同的对象，两个对象之间是分别都有自己的资源的，此时如果调用自己当前的方法中的资源，是同步交替进行的，不需要等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"i= "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个对象和两个对象直接调用，情况是不同的！</span></span><br><span class="line">    TestSynchronized test = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    TestSynchronized test1 = <span class="keyword">new</span> TestSynchronized();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            test.func();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            test1.func();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2. 同步一个方法"></a>2. 同步一个方法</h3><p>与代码块一样，作用范围都是当前对象，毕竟方法存在于对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3. 同步一个类"></a>3. 同步一个类</h3><p>作用范围：作用于整个类（执行的那个类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-同步静态方法"><a href="#4-同步静态方法" class="headerlink" title="4. 同步静态方法"></a>4. 同步静态方法</h3><p>作用范围：作用与整个类，static表示是类的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-ReentrantLock"><a href="#5-ReentrantLock" class="headerlink" title="5. ReentrantLock"></a>5. ReentrantLock</h3><p>ReentrantLock是java.util.concurrent并发包下的锁。此锁是基于代码实现的。使用ReentrantLock的话，lock()方法加锁，在finally语句块中一定别忘了unlock()方法的调用。ReentrantLock可以实现公平锁与非公平锁，默认实现的是非公平锁。</p>
<h3 id="6-synchronized与ReentrantLock的比较"><a href="#6-synchronized与ReentrantLock的比较" class="headerlink" title="6. synchronized与ReentrantLock的比较"></a>6. synchronized与ReentrantLock的比较</h3><ul>
<li><p><strong>两者都是可重入锁</strong>：可重入锁表示的是只要当前锁住该对象的锁是自己，自己再次访问依然能够进入，一般是锁住m1，也锁住m2，在m1中可以访问m2，也就是实现了可重入锁。每锁一次计数加1，为0时才能够释放锁。</p>
</li>
<li><p><strong>synchronized依赖于底层JVM，而ReentrantLock依赖于API</strong>：synchronized依赖于JVM实现的，ReentrantLock是通过API实现的，我们可以直接看到其源码。</p>
</li>
<li><p><strong>ReentrantLock比synchronized的功能要多</strong>：主要体现在：</p>
<ul>
<li>等待可中断：使用lock.lockInterruptibly()来实现，表示正在等待的线程可以选择放弃等待，进而处理其他事情。一般的实现是当前锁可以被获取锁，如果获取到了锁的话，返回锁，如果没有获取到锁则进入等待状态，直到获取到锁或者被其他线程打断，如果被interrupted方法打断的话，一定会抛出异常。</li>
<li>实现公平锁：在synchronized为了保证性能采用了非公平锁即抢占式的锁，但是在ReentrantLock中可以实现公平锁，公平锁就是按照先来先获取锁的准则来的，默认是非公平锁。</li>
<li>选择性通知：synchronized利用wait()和notify/notifyAll()方法相结合实现等待/通知机制。ReentrantLock中引入了Condition这一类来是实现选择性通知到某一个类。await()、singnal()</li>
</ul>
</li>
<li><p><strong>性能已不是选择的标准</strong>：synchronized性能被优化了，目前两者性能相差不大。</p>
</li>
</ul>
<p>使用ReentrantLock唯一的缺点在于需要手动释放锁，否则会导致死锁的产生，而synchronized不会有这样的问题，因为JVM会保证锁的释放。</p>
<h2 id="5-线程之间的协作"><a href="#5-线程之间的协作" class="headerlink" title="5. 线程之间的协作"></a>5. 线程之间的协作</h2><h3 id="1-join"><a href="#1-join" class="headerlink" title="1. join()"></a>1. join()</h3><p>join()方法表示在一个线程中调用另一个线程执行，当前线程会等待被join的线程处理完毕再继续执行。</p>
<h3 id="2-wait-notify-notifyAll"><a href="#2-wait-notify-notifyAll" class="headerlink" title="2. wait/notify/notifyAll"></a><span id="anchor">2</span>. wait/notify/notifyAll</h3><p>一般用于常见的生产消费模型中，wait方法表示线程暂时挂起，等待notify或者notifyAll方法的唤醒挂起的线程。</p>
<p>它们属于Object的方法，不属于线程Thread，且只能在同步方法或者同步语句块中使用，否则会抛出IllegalMonitorStateException</p>
<p>使用wait线程挂起的时候，线程会释放锁，因为如果没有释放锁的话，其他同步方法就没有机会进入到对象的同步方法或者同步代码块中去，就无法使用notify或者notifyAll来唤醒挂起的线程，造成死锁现象的产生。</p>
<p><font color="red">需要注意的是sleep方法不会释放锁，因为睡眠过后，当前线程还是要接着运行，这是它与wait方法最主要的区别。且wait方法属于Object，sleep方法属于Thread</font></p>
<h3 id="3-await-signal-signalAll"><a href="#3-await-signal-signalAll" class="headerlink" title="3. await/signal/signalAll"></a>3. await/signal/signalAll</h3><p>这三个方法主要是JUC中的Condition类中实现线程之间协调的方法，可以在Condition上调用await()方法使线程等待，其他线程调用signal/signalAll方法唤醒等待的线程。</p>
<p>相比<a href="#anchor">2</a>中的方法await方法可以指定条件，更加灵活。</p>
<h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6. 线程的状态"></a>6. 线程的状态</h2><p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="1-NEW-新建"><a href="#1-NEW-新建" class="headerlink" title="1. NEW-新建"></a>1. NEW-新建</h3><p>一个线程被new出来就进入了NEW状态，表示创建后未启动</p>
<h3 id="2-RUNNABLE-可运行"><a href="#2-RUNNABLE-可运行" class="headerlink" title="2. RUNNABLE-可运行"></a>2. RUNNABLE-可运行</h3><p>表示当前线程具备运行的资质，但是具体什么时候运行，这个属于操作系统底层的调度一块的内容。</p>
<h3 id="3-BLOCKED-阻塞状态"><a href="#3-BLOCKED-阻塞状态" class="headerlink" title="3. BLOCKED-阻塞状态"></a>3. BLOCKED-阻塞状态</h3><p>请求获取monitor lock从而进入synchronized函数或者代码块的时候，此时如果其他线程占用了该monitor lock，当前线程处于阻塞状态。当其他线程释放锁时候，当前线程获得锁之后进入RUNNABLE状态，等待被调度。</p>
<h3 id="4-WAITING-无限期等待"><a href="#4-WAITING-无限期等待" class="headerlink" title="4. WAITING-无限期等待"></a>4. WAITING-无限期等待</h3><p>等待其他线程显式唤醒。一般是object.wait()方法对应object.notify()/object.notifyAll()方法。Thread.join()方法，结束的话只需要等待结束即可。最后一个不常见：LockSupport.park()等待LockSupport.unpark(Thread)。</p>
<p>3中的阻塞和当前的等待之间的区别在于，阻塞是被动的，等待获取monitor lock（被动的原因是因为其他线程已经获取到了monitor lock，自己没有办法，只能等，造成被动现象的产生）。而等待是主动的，join()等方法都是自己显式的在代码中写入的，是主动的。</p>
<h3 id="5-TIMED-WAITING-限期等待"><a href="#5-TIMED-WAITING-限期等待" class="headerlink" title="5. TIMED_WAITING-限期等待"></a>5. TIMED_WAITING-限期等待</h3><p>此种等待不需要其他方法的唤醒，而是到了一定的时间会被系统自动唤醒。</p>
<p>sleep(time)，Object.wait(time)，join(time)，LockSupport.parkNanos()/LockSupport.parkUntil，注意即使设置了时间，依旧可以利用相关的通知机制唤醒。</p>
<p><font color="red">sleep表示线程睡眠，wait表示线程挂起，两者表示行为，而阻塞表示一种状态。</font></p>
<h3 id="6-Terminated-死亡"><a href="#6-Terminated-死亡" class="headerlink" title="6. Terminated_死亡"></a>6. Terminated_死亡</h3><p>线程正常执行完毕结束，或者执行中遇到异常而提前结束。</p>
<h2 id="7-JUC-AQS"><a href="#7-JUC-AQS" class="headerlink" title="7. JUC-AQS"></a>7. JUC-AQS</h2><p>JUC是java中的并发包，AQS是JUC中的核心。</p>
<h3 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h3><p>表示门闩的意思，用来控制一个或者多个线程等待多个线程执行的过程。count.countDown方法是给门闩个数减一，到了0的时候，调用了await()方法会运行下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待门闩开放</span></span><br><span class="line">            count.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m1 method execute!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.getCount() != <span class="number">0</span>) &#123; <span class="comment">// 门闩未到0，上面继续阻塞，执行当前程序</span></span><br><span class="line">                System.out.println(<span class="string">"latch count:"</span> + count.getCount());</span><br><span class="line">                count.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"m2 method execute, i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCountDownLatch testCountDownLatch = <span class="keyword">new</span> TestCountDownLatch();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                testCountDownLatch.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                testCountDownLatch.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>latch count:5<br>m2 method execute, i = 0<br>latch count:4<br>m2 method execute, i = 1<br>latch count:3<br>m2 method execute, i = 2<br>latch count:2<br>m2 method execute, i = 3<br>latch count:1<br>m1 method execute!</p>
</blockquote>
<h3 id="2-CycliBarrier"><a href="#2-CycliBarrier" class="headerlink" title="2. CycliBarrier"></a>2. CycliBarrier</h3><p>听名字表示栅栏的意思，用来控制多个线程之间互相等待执行，多个线程到达时才会执行。</p>
<p>线程之间需要相互等待，也是通过计数器实现的，await每调用一次则数量减一，到0才会执行后面的逻辑。</p>
<p>CycliBarrier中实现循环屏障使用的是reset方法，可以重新设置初始化此时次数。</p>
<p>第一种构造方法，第一个参数表示线程个数，第二个参数表示每次到达数量的线程，会调用执行一次。类似于回调的感觉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the first constructor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the second</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        Runnable worker = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(<span class="string">"first arravial Thread is arrived:"</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"worker is done"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread of Worker is "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(worker).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfoThreadWhenDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 回调</span></span><br><span class="line">                System.out.println(<span class="string">"[directory] Thread in invert call function is "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        process(barrier);</span><br><span class="line">        System.out.println(<span class="string">"[directory] the main Thread is "</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestCyclicBarrier barrier = <span class="keyword">new</span> TestCyclicBarrier();</span><br><span class="line">        barrier.showInfoThreadWhenDirectory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><p>Semaphore与线程之间的同步机制比较相似，可以控制对互斥资源的线程访问个数。</p>
<p>一旦semaphore的acquire许可证不可用，则阻塞等待可用。release释放许可证，使其回到信号量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphorePratice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 抢到了车位~"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 等待了3s后离开！"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-JUC其余组件"><a href="#8-JUC其余组件" class="headerlink" title="8. JUC其余组件"></a>8. JUC其余组件</h2><h3 id="1-FutureTask"><a href="#1-FutureTask" class="headerlink" title="1. FutureTask"></a>1. FutureTask</h3><p>一般用于异步计算，如果计算一个很复杂的任务，可以使用FutureTask将其分为结果任务执行，主线程完成任务之后再去获取结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFutureTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 要求有返回值，所以使用Callable</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    res += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread is running~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 为了确保上面线程运行完，所以睡眠2s</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BlockingQueue"><a href="#2-BlockingQueue" class="headerlink" title="2. BlockingQueue"></a>2. BlockingQueue</h3><p>阻塞队列在java多线程下用的很多。阻塞队列接口的实现主要有（用的比较多的）：</p>
<ul>
<li>FIFO队列：LinkedBlockingQueue，ArrayBlockingQueue</li>
<li>优先级队列： PriorityBlockingQueue</li>
</ul>
<p>可以使用阻塞队列实现生产者消费者模型，而且在消息队列中间件底层的实现都是阻塞队列。</p>
<p><a href="https://blog.csdn.net/cao1315020626/article/details/104295409" target="_blank" rel="noopener">生产者消费者模型的三种实现</a></p>
<p>BlockingQueue有三种常用的组合</p>
<blockquote>
<ul>
<li>第一种组合：add+remove+element<ul>
<li>add如果满了还继续添加的话会抛出异常IllegalStateException</li>
<li>remove如果空了还继续删除抛出异常NoSuchElementException</li>
<li>element是获取队列中的元素，如果为空抛出异常NoSuchElementException</li>
<li><p></li>
<li>第二种组合：offer+poll+peek</li>
<li>offer如果满了继续添加，返回false</li>
<li>poll如果空了继续删除，返回null</li>
<li>peek方法获取队列中的元素，为空的话返回null</li>
<li><p></li>
<li>第三种组合：put+take</li>
<li>这种是阻塞模式，如果put中的元素满了，就一直阻塞等待消费，直到take消费才释放队列</li>
<li>如果put为空，此时调用take方法，take方法会一直阻塞直到put放入元素队列可用为止</li>
<li><p></li>
<li>第四种组合：offer(time,unit)/poll(time,unit)</li>
<li>允许等待一段时间，看是否能获取到插入元素的空间，或者等到空间有元素 再执行获取元素</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-ForkJoin"><a href="#3-ForkJoin" class="headerlink" title="3. ForkJoin"></a>3. ForkJoin</h3><p>类似于MapReduce分片的思想，将大的数据分成若干个小块去并行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_07ForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块-放入随机数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            numbers[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin, end;</span><br><span class="line">        <span class="comment">// 重写计算方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 进入计算</span></span><br><span class="line">            <span class="keyword">if</span> ((end - begin) &lt; MAX_SIZE) &#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则二分</span></span><br><span class="line">                <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">                AddTask task1 = <span class="keyword">new</span> AddTask(begin, mid);</span><br><span class="line">                AddTask task2 = <span class="keyword">new</span> AddTask(mid, end);</span><br><span class="line">                task1.fork();</span><br><span class="line">                task2.fork();</span><br><span class="line">                <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, numbers.length);</span><br><span class="line">        Long aLong = pool.submit(task).get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool是通过窃取算法来实现的，每个线程都维护了一个双端序列，用来存储需要执行的任务，工作窃取算法允许空闲的线程从其他线程的双端队列中窃取一个任务来执行，窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<h2 id="9-线程安全"><a href="#9-线程安全" class="headerlink" title="9. 线程安全"></a>9. 线程安全</h2><p>一般在多线程环境下对于一个变量在多个线程中操作的时候，此时的结果会出现丢失的情况。这就造成了线程不安全的情况发生。</p>
<p>会发生这样的问题主要是与java的内存模型有关，java的内存模型有工作内存和主内存，每次线程访问java内存的时候，会将这个变量的一份复制到自己的工作内存中，计算完之后，将自己的结果更新，然后更新到主内存中去。但是多个线程处理情况下，A线程更新主内存之后，B线程还是按照自己工作内存中的值去计算的话，就会造成数据的丢失。</p>
<p>下面这种请款就会造成数据的丢失。要想保证线程安全，就需要让a具有可见性，可以使用volatile关键字修饰a，以此保证，每个线程在使用这个变量的时候都需要从主内存中取出，以此保证线程的安全性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadUnSafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            a += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadUnSafe test = <span class="keyword">new</span> TestThreadUnSafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                test.compute();</span><br><span class="line">            &#125;, <span class="string">"i"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止速度太快</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">"a的真实最终结果:"</span> + <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"a的计算最终结果:"</span> + test.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-主内存和工作内存"><a href="#1-主内存和工作内存" class="headerlink" title="1. 主内存和工作内存"></a>1. 主内存和工作内存</h3><p>主内存和工作内存图如下，以及线程与工作内存之间的交互如下。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581577933752.png" alt="1581577933752"></p>
<h3 id="2-内存模型的三大特性"><a href="#2-内存模型的三大特性" class="headerlink" title="2. 内存模型的三大特性"></a>2. 内存模型的三大特性</h3><ul>
<li>原子性<ul>
<li>原子性的实现可以使用AtomicInteger等原子类来实现原子操作</li>
</ul>
</li>
<li>可见性<ul>
<li>主要使用volatile和synchronized来实现，或者使用final关键字修饰。</li>
</ul>
</li>
<li>有序性<ul>
<li>有序性指代的是：在本线程内观察所有的操作都是有序的，但是在另外一个线程观察一个线程，所有的操作都是无序的，无序是因为发生了指令重排。在java内存模型中，允许编译器和处理器对指令进行重排优化执行，重排序对于单线程来说没有问题，但是在多线程的环境下会发生错误。</li>
<li>可以使用volatile关键字通过添加内存屏障实现禁止指令重排。</li>
<li>synchronized关键字也可以实现有序性，它保证每个时刻只有一个线程在执行同步代码，相当于让线程顺序执行同步代码。</li>
</ul>
</li>
</ul>
<h3 id="3-synchronized与volatile的区别"><a href="#3-synchronized与volatile的区别" class="headerlink" title="3. synchronized与volatile的区别"></a>3. synchronized与volatile的区别</h3><p><strong>面试的时候，有些面试官会问synchronized与volatile的区别</strong>：</p>
<ul>
<li>volatile关键字是是线程同步的轻量实现，volatile的性能比synchronized好，但是volatile关键字只能作用于变量，synchronized关键字可以作用与代码块以及方法，实际开发synchronized关键字使用的更多一点。</li>
<li>多线程访问volatile关键字不会发生阻塞，而访问synchronized关键字可能会发生阻塞</li>
<li>volatile关键字只能保证数据的可见性，不能保证数据的原子性。 而synchronizd关键字全都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性</li>
</ul>
<h2 id="10-线程安全的实现方式"><a href="#10-线程安全的实现方式" class="headerlink" title="10. 线程安全的实现方式"></a>10. 线程安全的实现方式</h2><h3 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h3><p>不可变的对象一定是线程安全的，不需要采取任何的线程安全措施保证安全。多线程环境下应该尽可能保证对象为不可变对象，使得线程保持安全。</p>
<p>不可变的数据类型：</p>
<ul>
<li>final关键字修饰的基本数据类型</li>
<li>String（底层是不可变的数组实现的）修饰符为final</li>
<li>枚举类型（一旦定义就不会改变了）</li>
<li>Number部分子类。基本数据的包装类型或者BigDecimal的大数据包装类型。但是AtomicInteger等原子类是可变的。</li>
<li>集合类可以通过Collections总的相关创建不可变对象的方法创建不可变对象</li>
</ul>
<h3 id="2-互斥同步"><a href="#2-互斥同步" class="headerlink" title="2. 互斥同步"></a>2. 互斥同步</h3><p>synchronized和ReentrantLock</p>
<h3 id="3-非阻塞同步"><a href="#3-非阻塞同步" class="headerlink" title="3. 非阻塞同步"></a>3. 非阻塞同步</h3><p>互斥同步主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略（这里悲观类似于乐观锁与悲观锁，悲观锁就是特别悲观，害怕别人在自己做事的时候影响自己，所以总是加锁。而乐观锁是每次做事的时候相信别人不会影响自己，虽然自己做完事之后还是会去确认一下。）</p>
<p>随着硬件指令集的发展，可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程争用共享数据，操作就成功了。否则就需要采取补偿措施。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步被称为非阻塞同步。</p>
<h4 id="①-CAS"><a href="#①-CAS" class="headerlink" title="① CAS"></a>① CAS</h4><p>CAS称为CompareAndSwap比较并交换，需要提供3个参数，分别是内存地址V，旧的预期值A和新值B，只有V=A的时候，才能够将V的值更新为B，底层是Unsafe根据相应地偏移量来判断并实现的。</p>
<h4 id="②-Atmoic相关原子操作类"><a href="#②-Atmoic相关原子操作类" class="headerlink" title="② Atmoic相关原子操作类"></a>② Atmoic相关原子操作类</h4><p>AtomicInteger等底层都是调用了Unsafe的CAS实现的原子操作。一旦发生冲突就不断地进行重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出一旦发生比较交换失败，会一直进行重试，直到成功返回值。</p>
<h4 id="③-ABA问题"><a href="#③-ABA问题" class="headerlink" title="③ ABA问题"></a>③ ABA问题</h4><p>ABA问题的产生是由于CAS引起的，这也是CAS中存在的问题。为什么这么说呢？我们来看看A B两个线程同时操作一个变量C=3. A来操作的时候将其改成了5，然后想想不对劲又改成了3，此时B如果来操作，它会发现这压根没人动过，但实际上值被改过。就产生了俗称的“ABA”问题</p>
<p>JUC中有一个AtmoicStampedReference类可以给对象值加个类似邮戳的记录，一旦被修改，邮戳+1，这样可以保证ABA问题如果发生，邮戳对不上的话也是更新失败。</p>
<p>下面的例子运行下就会明白了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;Integer&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========ABA问题的产生======"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            reference.compareAndSet(<span class="number">5</span>, <span class="number">100</span>);</span><br><span class="line">            reference.compareAndSet(<span class="number">100</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t修改成功否："</span> + reference.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">",最终值为："</span> + reference.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">        System.out.println(<span class="string">"============ABA问题的解决================="</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始的版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference() + <span class="string">"\t当前版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line">            stamp = atomicStampedReference.getStamp();</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference() + <span class="string">"\t当前版本号为："</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"t3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; </span><br><span class="line">            <span class="comment">// 被t3线程修改的，是不能够在这里获取到，所以false</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t成功否："</span> + atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>) + <span class="string">"\t当前值为："</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"t4"</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-线程本地存储-ThreadLocal-Storage"><a href="#4-线程本地存储-ThreadLocal-Storage" class="headerlink" title="4. 线程本地存储(ThreadLocal Storage)"></a>4. 线程本地存储(ThreadLocal Storage)</h3><p>ThreadLocal给线程提供局部变量用的，下面代码可以看见t2线程对t1线程的threadLocal变量没有任何影响。提供变量副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+threadLocal.get()); <span class="comment">// t1 1</span></span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+threadLocal.get());<span class="comment">// t2 2</span></span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set()</code>方法，获取到当前线程，如果不为null的话设置值，否则自己构建一个存入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get()</code>方法，获取到当前线程，获取到Map看看是否有值，有值就取出。否则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal从理论上来说并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景下（尤其是使用线程池）的情况下，由于ThreadLocal.ThreadLocalMap的底层数据结构导致ThreadLocal有内存泄露的风险，应该尽可能的在使用完ThreadLocal后调用remove方法。以避免出现ThreadLocal经典的内存泄露甚至是造成自身业务混乱的情况。</p>
<p>造成内存泄露的原因是因为ThreadLocalMap结构的问题，如果键被回收了key=null，那么值value并非弱引用，没有被回收，如果线程也没有被回收，也即线程没有销毁，那么value就永远不会被回收，当产生大量value的时候，此时就会造成内存泄露。</p>
<p>（JDK1.8之后不会有这种情况了，在set的时候如果发现线程没有被回收，此时存在key=null，value!=null）的情况，直接将key=null的进行替换即可避免内存泄露问题的产生。（具体看源码！）</p>
<h2 id="11-锁优化"><a href="#11-锁优化" class="headerlink" title="11. 锁优化"></a>11. 锁优化</h2><p>锁优化策略指的是JVM层面对synchronized的优化</p>
<h3 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h3><p>互斥同步进入阻塞的开销都很大，应该尽量避免频繁进入阻塞发生。在许多情况下，共享数据的锁定只会持续一会儿。自旋的思想是让获取不到锁的线程执行循环（自旋）一段时间，如果能够获取到锁，就不用进入到阻塞状态。</p>
<p>自旋锁虽然能够避免进入阻塞状态从而减少开销，但是需要进行空循环操作占用CPU时间，它只适用于共享数据锁定时间短的场景。</p>
<p>自适应自旋锁表示次数不再是固定的，而是由前一次在同一个锁上的自旋次数以及锁的拥有者的状态来决定。</p>
<h3 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争分析的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其他线程访问到，那么就把他们当做私有数据对待，即可将他们的锁进行消除。</p>
<p>StringBuffer就是利用synchronized关键字对操作加锁的，当前如果没有锁消除的话，会执行三次加锁三次释放锁，但是现在有了锁消除，只需要一次加锁即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上段代码也可以用与展示锁粗化，三次加锁的对象都是sb，可以直接简化为一次。即将加锁的范围放大。</p>
<h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h3><p>JDK1.6引入了偏向锁和轻量级锁，从而让锁拥有四个状态：无锁状态unlocked、偏向锁biasable、轻量级锁light weighted locked和重量级锁locked</p>
<p>轻量级锁是相对于重量级锁而言的，它使用CAS 操作来避免重量级锁使用互斥量的开销，对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都是用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败再采用互斥量进行同步。</p>
<p>[轻量级锁具体的实现]([<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81]" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81]</a>(<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 并发?id=轻量级锁))</p>
<p>如果CAS操作失败，虚拟机会先检查对象的Mark Word（标记锁对象的锁的状态）是否指向当前线程的虚拟机，如果是的话，表明当前线程已经拥有了这个锁对象，可以直接进入同步代码块继续执行。否则说明这个锁对象被其他线程抢占了。如果两个线程同时抢占一把锁，轻量级锁不再有效，需要膨胀为重量级锁。</p>
<h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程在之后获取到该锁的时候不再需要进行同步操作，甚至连CAS也不需要。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<h2 id="12-多线程开发良好实践"><a href="#12-多线程开发良好实践" class="headerlink" title="12. 多线程开发良好实践"></a>12. 多线程开发良好实践</h2><ol>
<li>给线程起个有意义的名字，方便找bug</li>
<li>缩小同步范围，从而减少锁争用。synchronized应尽可能使用同步块，而不是同步方法</li>
<li>多用同步工具，少用wait/notify/notifyAll这些方法，多用CountDownLatch，CycliBarrier,Semaphore这些同步类。</li>
<li>使用BlockingQueue实现生产者消费者问题</li>
<li>多用并发集合，少用同步集合，例如ConcurrentHashMap而不是HashTable</li>
<li>使用本地变量和不可变类来保证线程安全</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效的利用有限的线程来处理任务。</li>
</ol>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode之栈</title>
    <url>/2020/03/21/Leetcode%E4%B9%8B%E6%A0%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码</title>
    <url>/2020/03/21/ConcurrentHashMap%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap源码"><a href="#ConcurrentHashMap源码" class="headerlink" title="ConcurrentHashMap源码"></a>ConcurrentHashMap源码</h1><h2 id="1-JDK1-7版本"><a href="#1-JDK1-7版本" class="headerlink" title="1. JDK1.7版本"></a>1. JDK1.7版本</h2><h3 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>ConcurrentHashMap与HashMap在实现上差距不大，最主要的区别在于ConcurrentHashMap采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段中的桶，从而提高并发度，并发度就是Segment的个数。</p>
<p>segment的定位是按照偏移量来定位的，底层使用了Unsafe类的相关方法。</p>
<p><code>HashEntry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Segment</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的并发级别是16，创建16个segment</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-size操作"><a href="#2-size操作" class="headerlink" title="2. size操作"></a>2. size操作</h3><p>每个Segment维护了一个count变量来统计该Segment中键值对的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行size操作的时候，需要遍历所有Segment然后把count累计起来</p>
<p>ConcurrentHashMap在执行size操作时先尝试不加锁，如果连续两次尝试不加锁操作得到的结果一致，就认为这个结果是正确的。否则的话，就需要对每个Segment执行加锁，然后执行size操作。</p>
<p>这里加锁操作主要是因为ConcurrentHashMap是并发操作，你在获取size的同时可能还在插入元素，会导致获取到的结果出现问题。第一种方法是计算前后两次获取到的值是否相等，相等的话，表明没有元素插入，结果准确。否则一旦超过三次表明结果不准备需要给当前的segment加锁执行size操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 如果retries==2，执行++之后为3，此时加锁</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// sum size置0操作，主要是为了验证前后是否等。</span></span><br><span class="line">                <span class="comment">// last是不清零的，所以只要两次对等，表明没有数据插入。</span></span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// 表名没有数据插入，直接break，可以返回size</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3. put操作"></a>3. put操作</h3><p>put操作中涉及到两个参数<code>segmentShift\segmentMask</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line"><span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这两个参数定义在ConcurrentHashMap构造器中：</p>
<p>下面大致构造即使构造出segmentShift的大小以及segmentMask大小。至于初始的<code>c</code>这个主要是用来辅助构建有多少个Segment的。从下面可以看到MIN_SEGMENT_TABLE_CAPACITY=2，这个为2，表示最少每个Segment中的数组需要由两个坑位。至于cap与c之间的关系，可以看到，如果c为3的话此时cap需要从2翻倍到4，ssize是segment的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">// 从这里可以看出ssize=2^sshift次方</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">// 这里主要是为了获取取多少位的问题！</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0] 其余的延迟初始化</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"><span class="comment">// 这一句操作其实看完上面的也很好理解了，为什么需要左移segmentShift位呢</span></span><br><span class="line"><span class="comment">// 因为你的segmentMask是根据ssize-1来的，而根据ssize = 2^sshift可以知道</span></span><br><span class="line"><span class="comment">// sshift比ssize少32-sshift位(segmentShift)</span></span><br></pre></td></tr></table></figure>

<p>所以的话此时如果左移segmentShift位的话，再与的话正好取到高位相与的值就是下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    	<span class="comment">// 求下标</span></span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    	<span class="comment">// 如果偏移量不能定位的话，调用ensureSegment来定位</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put真正的实现，实质是在Segment中完成put操作的，因为分段锁的缘故。</p>
<p>put操作主要是因为加了锁！tryLock()方法一旦获取成功则意味着lock()，而scanAndLockForPut明确了最后推出只能lock()之后break退出。无论是否找到，出口只有<code>lock();break;return node;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试是否能够拿到锁，拿到则取null值，否则通过scanAndLockForPut自旋获取node</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Segment对应的HashEntry</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取在第几个hashEntry中</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取到tab的第一个值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k; <span class="comment">// 如果找到了的话，此时替换掉值即可</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value; </span><br><span class="line">                    <span class="comment">// 管你有没有，我都直接覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="comment">// 没找到则一直遍历下去</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125; <span class="comment">// 如果遇到了tab中为null的元素。</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 看看node是否为null，不为null的话，表明已经新建了节点</span></span><br><span class="line">                <span class="comment">// 只需要把自己的next设置为first头即可。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) <span class="comment">// 因为first==null</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">               <span class="comment">// 相当于直接将node这个节点作为当前HashEntry的第一个节点，下一个节点为null(first)</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>; <span class="comment">// count是记录元素个数的</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 元素个数过多执行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 一切顺利，将此node放入到当前的HashEntry中</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount; <span class="comment">// 修改次数++</span></span><br><span class="line">                count = c; <span class="comment">// 元素个数为c</span></span><br><span class="line">                oldValue = <span class="keyword">null</span>; <span class="comment">// 老的值记录为null，因为需要返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanAndLockForPut其中使用自旋获取锁。这一段的逻辑操作为：首先获取当前key-hash=hash(key)对应的节点链的头节点，然后持续遍历该链，如果节点中不存在该节点，则预创建一个新的节点，retries=0，意味着增加1，直到retries操作达到了最大值，进入阻塞等待状态，终止！否则的话在自旋过程中如果发现头节点发生了变化，此时头节点也相应的跟随变化，并将retries置为-1，意味着从头开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 自旋获取锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">// 预创建节点</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="comment">// 表示找到了，retries置为0，下一轮必结束，break，返回node即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next; <span class="comment">// 即不为空也不等，证明在其中则一直下去。</span></span><br><span class="line">        &#125;<span class="comment">// 尝试次数如果大于1了 采用阻塞锁获取</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; <span class="comment">// 只要链表头不改变，执行下去，否则同步链表头，重新再来</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-rehash操作"><a href="#3-rehash操作" class="headerlink" title="3. rehash操作"></a>3. rehash操作</h3><p><code>rehash</code>操作的话是对Segment中存储元素的扩容，也就是对table的扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 直接扩容一倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 直接构建新的table，这是为了使得并发get拿到值是没有问题的</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 使用新的掩码</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 由于是2的倍数，基本上之前的位置上的索引hash值是不会变的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i]; <span class="comment">// 取值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask; </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e; <span class="comment">// 如果是一个节点的话直接存，这是Doug Lea大神的一个优化点</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;<span class="comment">// 如果是多个节点的话</span></span><br><span class="line">                <span class="comment">// 表示在当前槽位上</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 遍历找到可重用的那个点，一般来说也不会发生变化。除非还有新的操作</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="comment">// lastRun之后的左右的节点都是可重用的。如果一开始就没变的话那就直接重用</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes </span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">// 保证所有不可重用点都是new出来的，不会对原有结构进行改变</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-get操作"><a href="#4-get操作" class="headerlink" title="4. get操作"></a>4. get操作</h3><p>get操作比较简单，由于在存入或者put操作的时候都是新创建一个新的表，所以获取只需要定位然后根据key值以及hash值判断即可，相等就取出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123; <span class="comment">// 定位segment,然后获取到HashEntry的位置</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-remove操作"><a href="#5-remove操作" class="headerlink" title="5. remove操作"></a>5. remove操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock()) <span class="comment">// 加锁失败，则采取自旋获取锁lock()</span></span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>; <span class="comment">// 移除之后需要返回的值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到当前segment的table</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取当前删除元素的下标位置</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 找到当前下标的头节点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;<span class="comment">// 记录前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k; <span class="comment">// 三个节点 pred 当前节点 next</span></span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value; <span class="comment">// hash与key都相等，取出值value判断是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">// 如果pred为null，正好是首节点，就将next设置为首节点</span></span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// 否则直接跨过当前节点即可</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// 不然大家一起前进啊</span></span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-JDK1-8版本"><a href="#2-JDK1-8版本" class="headerlink" title="2. JDK1.8版本"></a>2. JDK1.8版本</h2><h3 id="1-基本结构-1"><a href="#1-基本结构-1" class="headerlink" title="1. 基本结构"></a>1. 基本结构</h3><p>ConcurrentHashMap第一个的区别就是在于使用了Node来代替Segment存储数据，使用Node代替了HashEntry&lt;K,V&gt;，从Node的结构上我们可以看到，现在的粒度更细，之前Segment锁住的是所有的HashEntry&lt;K,V&gt;[]，现在锁住的仅仅是一个Node&lt;K,V&gt;，粒度更细，并发度更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中几个比较重要的方法：后面用得着</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前数组以及指定下标的节点的原子操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cas操作，比较并交换，在特定位置设置值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在某个下标处设置值的原子操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有个比较中要的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制初始化和扩容的，默认值为0，初始化的时候如果制定了大小，则这个值会保存在sizeCtl中</span></span><br><span class="line"><span class="comment"> * 大小为数组长度的0.75，当为负的时候，说明表正在初始化或在扩张，</span></span><br><span class="line"><span class="comment"> * -1 表示初始化</span></span><br><span class="line"><span class="comment"> * -(1+n):其中n表示正在活动的扩张线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<p>构造方法：空构造就不看了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化的时候如果指定了容量的话，此处就将sizeCtl=cap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法：初始化table，使用sizeCtl中记录的大小。初始化方法主要用于第一次put操作时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0的话表示别的线程正在初始化，自己进行线程礼让</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 否则的话比较 SIZECTL：表示当前对象的内存偏移量</span></span><br><span class="line">        <span class="comment">// 期望值sc，符合就将sc替换为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 指定了大小的话就按照指定大小来，否则默认16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// n-n/4=3n/4</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 长度为3/4,即0.75</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2. put操作"></a>2. put操作</h3><p>传入key-value，实际调用putVal方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第三个参数onlyIfAbscent: false的话表示value一定会被设置</span></span><br><span class="line">    <span class="comment">// true：表示value为null时才会被设置</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>putVal()</code>方法，从第一句<code>if (key == null || value == null) throw new NullPointerException();</code>可以看出，ConcurrentHashMap键值都不能为空。</p>
<p><strong>总结put操作的过程</strong>：</p>
<p>首先判断键值是否为null，不为null获取当前key的hash值，获取当前table，如果当前tab没有被初始化，则先调用initTable()方法先初始化表（顺便初始化sizeCtl）；已经初始化的话，此时判断当前位置的元素是否为null，是的话，利用CAS操作以key创建新节点Node插入当前位置即可。否则的话，判断当前的hash值是否为-1，看看是否有其他线程在执行扩容的复制过程，是的话自己要去帮忙，然后再回来处理put过程。都不是的话，此时可以知道当前位置是存在元素的，此时利用synchronized关键字加锁，由于允许并发操作，为防止之前取出的头节点发生变化，再次取出比较，如果还相等，证明当前Node没有插入新的元素，否则表明已经插入，直接返回null即可。</p>
<p>如果头节点没有发生变化，判断当前的hash值是否大于0，（-2是树化的hash值），此时就遍历Node，binCount=1，依次累加，如果找到了元素，直接覆盖。如果之前树化了，则利用putTreeVal的方法添加节点。最后判断bitCount的数量是否超过了树化的门限，超过则调用treeifyBin方法判断是扩容还是树化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 记录当前桶的元素个数（可以理解为坑位）</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果tab没有初始化，则执行initTable()方法初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 否则获取到当下下标处的Node节点，如果为null的话</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过CAS将当前新创建的节点放入即可</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 跳出循环，结束put操作</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125; <span class="comment">// MOVED：-1 用于转发节点的hash</span></span><br><span class="line">        <span class="comment">// 如果是MOVED状态的话，表示正在进行数组扩张的数据复制阶段。</span></span><br><span class="line">        <span class="comment">// 当前线程也会参与复制，通过允许多线程复制的功能，以此来减少数组的复制所带来的性能损失。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// fh如果在这里没有命中，往后走只有&gt;=0 以及 -2可取</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置有元素的话，采用synchronized加锁</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次取出值与之前取出的对比</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 取出的hash值大于0，如果转化为树则为-2</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">// 桶个数置为1，表示从1开始</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果找到了，则直接值覆盖，put成功</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 否则将之前的节点定为pred，看看后面是否为null</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 是的话，直接创建新的Node节点拼接在pred.next处</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">// 小于0的话。表示已经树化，此时判断是否为树的类型</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用putTreeVal方法，存入值</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// binCount发生变化之后，判断是否大于树化的门限值8，是的话，树化。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// binCount执行+1操作，返回null</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-treeifyBin操作"><a href="#3-treeifyBin操作" class="headerlink" title="3. treeifyBin操作"></a>3. treeifyBin操作</h3><blockquote>
<p>Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.</p>
</blockquote>
<p>将其中的给定了index的节点替换为树中节点（链表转为树），超过64就要转，除非表太小，这种情况就参与扩容操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;<span class="comment">// 如果表不为null且大小小于64，执行扩容操作。</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>); <span class="comment">// 直接扩成2倍即可</span></span><br><span class="line">        <span class="comment">// 否则的话取出当前index下的Node节点并在hash值大于0的情况下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">// 使用synchronized加锁，取出再次比较</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 只有一个节点的话，则head=p,当前节点为头结点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span> <span class="comment">// 否则将其放在数的最后一个节点next处</span></span><br><span class="line">                            tl.next = p; </span><br><span class="line">                        tl = p; <span class="comment">// tl变到下面。</span></span><br><span class="line">                    &#125;<span class="comment">// 将当前表放入TreeBin中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容实现方法：tryPresize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果size大于1 &lt;&lt; 30的一半，则直接使用最大的。否则的话调用tableSizeFor来扩容</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">    tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">// 无论怎么扩都要是2的整次幂</span></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 假如之前是16的容量需要扩到32，那么sizeCtl就需要从12扩到24</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 如果没有被初始化，则此时创建一个n大小为sc与c中的更大值的Node[]</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">// 比较置为-1.</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 确认其他线程没有对此表进行修改</span></span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">// 完成之后还是设置为3/4大小</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;<span class="comment">// 3/4大小</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 扩容到容量小于等于sizeCtl大小，或者n大于最大容量，终止扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则获取到tab</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果也在初始化扩容的话，则帮助扩容，否则开始新的扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="comment">// 第一个判断是判断右移这么多位之后与之前的n是否是同一个容量下进行扩容</span></span><br><span class="line">                <span class="comment">// 第二个和第三个判断是判断当前扩容数是否到达最大的限制</span></span><br><span class="line">                <span class="comment">// 第四和第五个判断是确保transfer()方法初始化完毕</span></span><br><span class="line">                <span class="comment">// 如果都不符合，直接判定break;退出扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 线程数+1，sc在扩容的时候表示transfer的工作线程数</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;<span class="comment">// 否则开始新的扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-transfer操作"><a href="#4-transfer操作" class="headerlink" title="4. transfer操作"></a>4. transfer操作</h3><p>这一节的代码解释可以参看：<a href="https://www.jianshu.com/p/2829fe36a8dd" target="_blank" rel="noopener">并发编程——ConcurrentHashMap#transfer() 扩容逐行分析</a></p>
<ul>
<li><input disabled="" type="checkbox"> 扩容这里Doug Lea有点天秀的感觉。（先Mark，等以后能力足了再来补充！）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 设定线程处理桶的个数NCPU获取的CPU核心数</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 初始化 扩容两倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;<span class="comment">// 占位节点</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 为true表示可以推进</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 保证完成状态</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// transferIndex为转移时的下标，扩容前的tab的length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;<span class="comment">// 向前推进</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-get操作"><a href="#5-get操作" class="headerlink" title="5. get操作"></a>5. get操作</h3><p>get操作和jdk1.7基本一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode()); <span class="comment">// 获取哈希值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 拿到当前的Node节点</span></span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前key的哈希值与当前获取到的节点哈希值相等</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">// 判断值是否相等，相等的话就返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 如果小于0的话，此时遍历寻找，不存在返回null</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 既不等于头结点的hash值，也不小于0,遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-ConcurrentHashMap1-7与1-8的区别"><a href="#3-ConcurrentHashMap1-7与1-8的区别" class="headerlink" title="3. ConcurrentHashMap1.7与1.8的区别"></a>3. ConcurrentHashMap1.7与1.8的区别</h2><ul>
<li>JDK1.7中采用分段锁来实现并发更新操作，核心类为Segment，它继承自ReentrantLock，并发度为Segment的数量，采用的是数组+链表</li>
<li>JDK1.8使用了CAS操作以此支持更高的并发度，在CAS操作失败之后使用内置锁synchronized，JDK1.8的实现在链表过长时也会转化为红黑树。底层是数组+链表+红黑树。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>ConcurrentHashMap支持并发操作，从get方法中我们可以看出，没有任何任何的同步机制，所以读操作支持并发操作。</p>
<p>写操作的话一般是put操作，放入元素时发生写的操作，这个时候会进行相应的加锁过程（jdk1.7），在jdk1.8中主要是利用synchronized以及cas+Unsafe底层的操作来实现的同步操作。</p>
<p>多个线程同步处理的过程通过synchronized和unsafe两种方式来实现的。</p>
<ul>
<li>在取得sizeCtl、Node节点的时候，使用的都是Unsafe方法实现，以达到并发安全的目的。</li>
<li>当需要在某个位置设置节点的时候，一般是值覆盖的时候，会使用synchronized同步机制来锁定该位置的节点</li>
<li>在数组扩容的时候，则通过处理的步长和fwd节点来控制达到并发安全的目的，通过设置hash值为MOVED</li>
<li>当把某个位置的节点复制到扩张后的table的时候，也是通过synchronized同步机制来实现</li>
</ul>
<p>[参考]([<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8]" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8]</a>(<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器))</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码|并发</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备知识</title>
    <url>/2020/03/21/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="字节面试准备"><a href="#字节面试准备" class="headerlink" title="字节面试准备"></a>字节面试准备</h1><h2 id="1-常见的算法题"><a href="#1-常见的算法题" class="headerlink" title="1. 常见的算法题"></a>1. 常见的算法题</h2><h3 id="1-1-链表"><a href="#1-1-链表" class="headerlink" title="1.1 链表"></a>1.1 链表</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>1.找出两个链表的第一个公共节点，复杂度要求O(n)，空间复杂度O(1)</strong></p>
<p>找出两个链表的长度，长的先走，然后一起走，相遇的时候就是公共节点</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2.检测链表是否有环？如果要查找入换的节点呢？</strong></p>
<p>快慢链表，只要相遇就有环。</p>
<p>输出入环的节点只需要在相遇的时候，快指针回到链表头部，快慢指针同步前进，一旦相遇就是入环节点。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>3.链表对折</strong></p>
<p>找到终点，然后将前后两部分翻转，最后将两个链表合起来即可。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>4.K链表反转（Leetcode25）</strong></p>
</li>
</ul>
<p><strong>5. 封装一个单链表，要求实现添加、删除、反转方法？</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>6.链表奇数位升序，偶数位降序，如何改为有序链表？</strong></li>
</ul>
<p>​    第一种方法遍历将偶数存一个链表，将奇数存一个链表，最后合并。</p>
<p>​    不用额外空间的方法：</p>
<p>​    第二种方法：奇数构成一个链表，偶数构成一个链表，翻转偶数链表，两个链表合并即可。</p>
<h3 id="1-2-字符串"><a href="#1-2-字符串" class="headerlink" title="1.2 字符串"></a>1.2 字符串</h3><p><strong>1.最长不重复子序列长度</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2. 反转url：<a href="http://www.toutiao.com变成com.toutiao.www" target="_blank" rel="noopener">www.toutiao.com变成com.toutiao.www</a> 采用两次翻转</strong></p>
<p>先执行总的反转，然后根据’.’作为分隔符，将每一部分的单词顺序翻转即可。总共两次翻转</p>
</li>
</ul>
<h3 id="1-3-数组"><a href="#1-3-数组" class="headerlink" title="1.3 数组"></a>1.3 数组</h3><p><strong>1.将数组所有的0都放到数组末尾</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>2.三十六进制加法，要求不能转换为十进制？</strong></p>
<p>利用一个进位符号来记录进位，对两个数分别取最后一位进行相加以36为基准，判断是否大于36或者小于36采用不同的拼接方式。字母的拼接可以采用一个记录了36个字母的字符串来表示，直接从字符串中获取。</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>3.求下一个大的数</strong></p>
</li>
</ul>
<p><strong>4.相交区间合并：[1,5] [2,7] [4,9]…把有相交的区间合并为一个？</strong></p>
<p><strong>5.一个数组里面含有正负数，</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>6.输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</strong></li>
</ul>
<p>这一题主要是比较器的重写问题。组合组合。</p>
<p><strong>7.给一个函数返回0和1，概率为p或者p-1，请你实现一个函数，使得返回0和1概率相同</strong></p>
<p><strong>8.两数相加 leetcode 2</strong></p>
<p><strong>9.数组中每个数右边第一个比它大的元素leetcode 1019</strong></p>
<p><strong>10.一个无序数组一个target，找出数组中两个和为target的数，并输出下标。（不能使用Hash）</strong></p>
<p><strong>11.给两对有序的数组，给出合并后有序的数组（归并）</strong></p>
<p><strong>12.汉诺塔</strong></p>
<p><strong>13.数组反转</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <p><strong>14. 最长连续子序列</strong></p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p><strong>15. 数组反转给定一个target，每target长度反转一次</strong></p>
</li>
</ul>
<h3 id="1-4-二叉树"><a href="#1-4-二叉树" class="headerlink" title="1.4 二叉树"></a>1.4 二叉树</h3><ul>
<li><input checked="" disabled="" type="checkbox"> <strong>1.二叉树的公共祖先，不用递归如何实现？写出如何找出这条路径的算法？</strong></li>
</ul>
<p><strong>2.二叉树中和为某一值的路径，为什么要removeLast？</strong></p>
<p><strong>3.给一棵二叉树，根为root，请你删除一条边，使二叉树分裂成两颗子树，且他们的子树和乘积尽可能大，返回最大的乘积？（Leetcode 1339）</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>4.树的右视图，递归和非递归实现？</strong></li>
</ul>
<p><del><strong>5.寻找p1和p2节点两颗树的最近公共祖先节点</strong></del></p>
<p><del><strong>6.二叉树的最近公共祖先Leetcode 236</strong></del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要不都大于</span></span><br><span class="line">    <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">// 要不都小于</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要不就在两边,返回当前的</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树的最近公共祖先（使用递归解决）</span></span><br><span class="line"><span class="keyword">private</span> TreeNode ans = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    findNode(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNode</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 直接到最深处</span></span><br><span class="line">    <span class="keyword">int</span> left = findNode(root.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 看看右边有没有找到</span></span><br><span class="line">    <span class="keyword">int</span> right = findNode(root.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (root.val == p.val || root.val == q.val) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到了两个</span></span><br><span class="line">    <span class="keyword">if</span> (left + right + mid &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否找到的结果</span></span><br><span class="line">    <span class="keyword">return</span> (left + right + mid) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用非递归解决</span></span><br><span class="line"><span class="comment">// 利用map记录节点和指针。利用队列实现广度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用以放置节点和父指针</span></span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parent.put(root,<span class="keyword">null</span>);</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 如果同时包含两个Node的话终止</span></span><br><span class="line">    <span class="keyword">while</span>(!parent.containsKey(p) || !parent.containsKey(q))&#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent.put(pop.left,pop);</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent.put(pop.right,pop);</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这主要是对祖先节点去重</span></span><br><span class="line">    Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从上到下取出得到的所有的祖先节点，还不带重复</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ancestors.add(p);</span><br><span class="line">        p = parent.get(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取共同的祖先节点</span></span><br><span class="line">    <span class="keyword">while</span>( !ancestors.contains(q))&#123;</span><br><span class="line">        <span class="comment">// 从上到下获取父节点</span></span><br><span class="line">        q = parent.get(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-堆"><a href="#1-5-堆" class="headerlink" title="1.5 堆"></a>1.5 堆</h3><p><strong>1.百万的数据，找出最大的100个，如果数据100亿太大怎么办？</strong></p>
<p>使用小顶堆即可。如果数据太大的话，可以采用数据分割，分次读取即可。</p>
<h3 id="1-6-栈"><a href="#1-6-栈" class="headerlink" title="1.6 栈"></a>1.6 栈</h3><p><strong>1.Min栈的实现</strong></p>
<p><strong>2.手上握有一堆牌，分两步 1.把顶上的牌发出去  2.把顶上的牌放到底部, 重复1-2步，直到手上没牌。给出桌子上的发牌顺序，求原来手牌顺序</strong></p>
<h3 id="1-7-动态规划"><a href="#1-7-动态规划" class="headerlink" title="1.7 动态规划"></a>1.7 动态规划</h3><p><strong>1.上楼梯，给定一个n，从0开始，每次只能加6或者8，输出到达n最小的操作次数？</strong></p>
<p><strong>2.m*n的方格。从方格的一端到另一端有多少种方法？</strong></p>
<p><strong>3.有1 2 5 这种走法，n块的话有多少种走法？</strong></p>
<h2 id="2-常问的知识点"><a href="#2-常问的知识点" class="headerlink" title="2. 常问的知识点"></a>2. 常问的知识点</h2><h3 id="2-1-计算机网络"><a href="#2-1-计算机网络" class="headerlink" title="2.1 计算机网络"></a>2.1 计算机网络</h3><p><strong>1.三次握手是什么，为什么需要三次？TCP四次挥手，为什么需要等待2MSL？</strong></p>
<p>三次握手发生在TCP建立连接的时候，假设A为客户端，B为服务器，A发送SYN=1，seq=x的连接请求到B，A进入SYN-SENT状态；B如果同意建立连接，发送SYN=1，ACK=1，seq=y，确认号ack=x+1给A，B进入SYN-RCVD状态；A收到请求之后再次向B进行确认，发送SYN=1,ACK=1,seq=x+1,ack=y+1给B，双方进入到ESTABLISHED状态。三次的话主要是为了消除A发送的在网络中的滞留的请求到达B，而使得B发送确认，但此时A不再接受，B会一直发送确认报文。假如是两次的话，一旦滞留请求连接到达B此时B就要打开额外的连接。</p>
<p>四次挥手主要用于通信双方连接的释放：</p>
<p>A发送FIN=1,seq=u的连接释放请求给B，此时A进入FIN-WAIT1状态，B收到A的连接释放请求之后，需要发出确认，ACK=1，seq=v，ack=u+1,此时B进入CLOSED-WAIT状态，A收到报文之后，进入FIN-WAIT2状态，此时双方处于半关闭状态，如果此时B还有属于要发送给A的话，A还是可以接收的，当数据发送完毕，B发送FIN=1，ACK=1,seq=w，ack=u+1的连接释放报文给A，此时B进入LAST-ACK状态，等待最终确认，A收到后，发送确认报文ACK=1，seq=u+1,ack=w+1,此时A进入TIME-WAIT状态，等待2MSL进入CLOSED状态，B接收到A的确认之后就进入CLOSED状态。</p>
<p>等待2MSL，MSL是报文最长存活时间，1.保证B能够接收到确认报文，进入CLOSED状态。2.使得在释放过程中产生的所有的报文在网络中消失，使得下一次连接不会出现旧的连接请求报文。</p>
<p><strong>2.滑动窗口是什么，干什么用的？</strong></p>
<p>RTT：发送一个数据报到收到一个对应的ACK所花费的时间</p>
<p>RTO：重传时间间隔</p>
<p>TCP使用滑动窗口做<strong>流量控制</strong>和<strong>乱序重排</strong>。</p>
<p>第一个是提供TCP的可靠性，第二个是提供TCP的流控特性。</p>
<p>滑动窗口体现了TCP传输字节流的特性。</p>
<p>（TCP滑动窗口具体的实现，是发送方有一个滑动窗口，接收方也有一个滑动窗口，发送的时候需要已经发送并得到接收方确认的滑动窗口才可以从左向右滑动。而接收方需要获取到对方已接受并已经确认才可以继续从左向右滑动。）</p>
<p><strong>3.TCP和UDP的区别？</strong></p>
<ul>
<li>TCP是面向连接的，UDP是无连接的（TCP有三次握手，UDP适合消息的多播发布，单点向多点发布）</li>
<li>TCP是可靠交付的，UDP是尽最大努力交付的，不保证可靠性</li>
<li>TCP传输的数据是有序的，UDP是无序的（TCP利用序列号，数据有序）</li>
<li>TCP速度慢（创建连接），UDP快（适合在线视频媒体，电视广播，游戏直播，多人在线游戏）</li>
<li>量级，TCP头部有20个字节重量级，UDP只有8个字节轻量级</li>
</ul>
<p><strong>4. HTTP协议是什么样的？</strong></p>
<p>HTTP协议是应用层的协议，是一种基于请求与响应模式的无状态的协议，采用TCP进行连接，在1.1中引入了长连接keep-alived。</p>
<ul>
<li>支持C/S模式</li>
<li>简单快速（传送请求方法和路径即可 请求方法有 get  head post三种）</li>
<li>灵活：可以传输任意类型的数据使用Content-Type加以标记</li>
<li>无连接：限制每次连接只处理一个请求。可以节省传输时间。长连接可以理解为下层实现对上层透明。</li>
<li>无状态</li>
</ul>
<p>HTTP的请求结构：</p>
<p>请求头+回车/换行（/r/n）+请求正文</p>
<p>响应头+回车/换行（/r/n）+响应正文</p>
<p>HTTP请求响应的步骤：</p>
<ul>
<li>客户端连接Web服务器</li>
<li>发送HTTP请求</li>
<li>服务器接受请求并返回HTTP响应</li>
<li>释放TCP连接</li>
<li>客户端浏览器解析HTML内容</li>
</ul>
<p><strong>5.GET和POST的区别？</strong></p>
<ul>
<li>http报文层面：GET将请求信息放在URL中，POST放在报文主体</li>
<li>数据库层面：GET符合幂等性和安全性的，POST不符合（因为POST会对数据库的访问的内容进行修改）</li>
<li>其他层面：GET可以被缓存、被存储，POST不行</li>
</ul>
<p><strong>6.HTTPS的加密过程?为什么传输要用到对称加密？</strong></p>
<p>对称加密+非对称加密，非对称加密很安全，一般用于传输加密的相关信息。因为非对称加密可以传输的字节有大小限制，但是对称加密适合大数据量的传输。</p>
<p><strong>7.HTTP与HTTPS的区别，HTTPS建立连接的过程？</strong></p>
<p><strong>区别:</strong></p>
<ul>
<li>http使用80端口，https使用443端口，使用的是完全不同的连接方式</li>
<li>http是没有加密运行在tcp之上，https是运行在ssl/tls之上，ssl/tls运行在tcp上加密</li>
<li>https需要申请CA证书，一般需要付费，http不需要</li>
<li>https可以有效地防止运营商劫持，解决了防劫持的一个大问题</li>
</ul>
<p>或者</p>
<ul>
<li>https需要申请CA证书，一般需要付费，http不需要</li>
<li>HTTP密文传输，HTTP明文传输</li>
<li>连接方式不同，端口不同https 443 ，而HTTP是80</li>
<li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP更加安全</li>
</ul>
<p><strong>HTTPS数据传输流程：</strong></p>
<ul>
<li>浏览器将支持的加密算法发给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，以证书的形式返回给浏览器</li>
<li>浏览器验证证书的合法性，并结合证书中给出的公钥加密信息发送给服务器</li>
<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发给浏览器</li>
<li>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</li>
</ul>
<p><strong>8. TCP的拥塞控制？</strong></p>
<p>TCP的拥塞控制与TCP的流量控制比较类似，但是TCP的流量控制是针对发送方和发送方之间的流量控制。拥塞控制是减轻整个网络的拥塞。TCP的拥塞一旦发生，分组将会丢失，此时发送方会继续执行重传，将会导致网络拥塞程度更高，因此当出现拥塞时，应该采用TCP的拥塞控制。</p>
<p>主要有慢开始和拥塞避免，已经快开始与拥塞避免。</p>
<p>慢开始，开始增加，每次确认翻倍，等到了门限值sshthresh的时候，采用拥塞避免算法。如果发生拥塞的话，此时门限值sshthreash=cwnd/2，此时重新冲0开始执行慢开始算法。</p>
<p>而快恢复算法的话，只是到了发生拥塞的时候门限值变化为cwnd/2，才是开始也从这个点开始执行拥塞避免算法。</p>
<p>（注意还有一个快重传算法，就是每收到三次同样的确认报文，就直接重发下一个报文给接收方）</p>
<p><strong>9.DNS，输入URL之后到展示出页面发生了哪些流程？</strong></p>
<p>一、</p>
<ul>
<li>DNS域名解析系统先解析域名到IP地址</li>
<li>获得IP地址之后建立TCP连接，发送HTTP请求</li>
<li>服务器收到HTTP请求之后，返回HTTP响应报文</li>
<li>浏览器收到响应报文之后对页面HTML进行渲染，展示页面</li>
<li>连接结束</li>
</ul>
<p>二、</p>
<ul>
<li>DNS解析（DNS缓存查询：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，）</li>
<li>TCP连接（三次握手）</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
<li>TCP释放连接，连接结束</li>
</ul>
<p><strong>10.traceroute作用</strong></p>
<p>用来跟踪一个分组从源点到终点的路径。ICMP网际报文控制协议。经过路由器后，生存时间TTL改变了。</p>
<p><strong>11.socket编程</strong></p>
<p>TCP与UDP实现消息的传输</p>
<p><strong>12.xss跨域是什么？</strong></p>
<p>XSS攻击指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</p>
<p><strong>13.什么是数字签名，有什么作用？</strong></p>
<p>数字签名主要是用来存放公钥和私钥以及摘要的，作用就还是在进行HTTPS进行连接的时候进行数据秘钥协商的。数字签名=数字摘要+非对称加密技术。数字证书就是第三方提供的一个信任证书，用以对服务器的身份安全认证。</p>
<p><font color="red">流程：客户端向服务器发送协议版本号，随机数1，支持的加密算法，服务器确认双方的加密算法，然后服务器向客户端发送随机数2，以及自己的数字证书CA（含有公钥），客户端接收到证书之后验证服务器身份，随后生成随机数3，利用数字证书中的公钥进行加密发送给服务器，服务器接收到之后利用私钥解密获取到第三个数字，然后双方使用3个随机数字利用约定好的加密算法，生成双方对话的对称私钥。</font></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581993368392.png" alt="1581993368392"></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092003.png" alt="img"></p>
<p><strong>14.知道DNS吗，如何减少DNS的传输时间？host是啥，如何减少host的查询时间？</strong></p>
<p>DNS域名系统服务，减少DNS查找的时间，使用UDP进行传输。</p>
<p>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。所以减少唯一主机名的数量就可以减少DNS查找的数量。（减少host文件中的唯一主机名）</p>
<p><strong>15.交换机和路由器分别处于哪一层？</strong></p>
<p>交换器处于数据链路层，主要是维护MAC表</p>
<p>路由器处于网络层，主要是IP寻址和路由选择。</p>
<p><strong>16.什么是缓存溢出？</strong></p>
<p>是指存在缓存溢出漏洞的计算机中，攻击者用超出常规长度的字符数来填满一个域，通常是内存区地址。</p>
<p><strong>17.HTTP1.0和HTTP1.1区别，HTTP1和HTTP2的区别？</strong></p>
<p>HTTP1.0与HTTP1.1的区别主要在于：</p>
<ul>
<li><p>长连接：1.1支持长连接keep-alived</p>
</li>
<li><p>缓存处理：1.1的缓存策略更多</p>
</li>
<li><p>带宽优化及网络连接的使用：带宽主要是1.1中引入了range，控制文件对象大小。</p>
</li>
<li><p>错误通知的处理：1.1新增了状态码，更好的执行错误通知</p>
</li>
<li><p>Host头的处理：1.1中请求头和响应头都支持Host头域</p>
</li>
</ul>
<p>HTTP1.x与HTTP2的区别：</p>
<ul>
<li>新的二进制文件：HTTP1.x的解析是基于文本。HTTP2.x则是基于二进制</li>
<li>多路复用：连接共享</li>
<li>header压缩：HTTP2.0使用encoder来减少传输的header大小。</li>
<li>服务端推送：HTTP2.0具有server push功能</li>
</ul>
<p><strong>18. HTTP常见的状态码？</strong></p>
<ul>
<li>1XX：请求已接受并继续处理</li>
<li>2XX：表示成功，请求被成功接收、理解、接受</li>
<li>3XX：重定向，要完成请求必须进行更进一步的操作</li>
<li>4XX：客户端错误-请求有语法错误或请求无法实现</li>
<li>5XX：服务器错误，服务器未能实现合法的请求</li>
</ul>
<p><strong>19. Cookie和Session的区别</strong></p>
<p>Cookie：</p>
<ul>
<li>是由服务器发送给客户端的特殊的信息，以文本的形式存放在客户端</li>
<li>客户端再次请求的时候，会把Cookie回发</li>
<li>服务器接收到之后，会解析Cookie生成与客户端相对应的内容 </li>
</ul>
<p>Cookie流程：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582011572513.png" alt="1582011572513"></p>
<p>Session：</p>
<ul>
<li>服务器端的机制，在服务器上保存的信息</li>
<li>解析客户端请求并操作Session_id，按需保存状态信息</li>
</ul>
<p>Session的实现方式：</p>
<ul>
<li>使用Cookie来实现，在服务器发送过去的时候Set-Cookie中设置JSESSIONID=xxx，客户端的Cookie中的JSESSIONID=xxx给服务器，服务器返回响应</li>
<li>URL回写来实现。隐式的下载请求的URL中，这样在访问同一个网站的所有页面都可以直接有权操作。</li>
</ul>
<p>两者的区别：</p>
<ul>
<li>Cookie的数据存放在客户端的浏览器上，Session的数据放在服务器上</li>
<li>Session相对Cookie来说比较安全</li>
<li>若考虑减轻服务器的负担，应当使用Cookie</li>
</ul>
<p><strong>20. HTTP中有哪些加密方式</strong></p>
<ul>
<li>对称加密：加密和解密都用同一个秘钥</li>
<li>非对称加密：加密和解密使用不用的秘钥</li>
<li>哈希算法：将任意长度的信息转化为固定长度的值，不可逆</li>
<li>数字签名：证明某个消息或者某个文件是某人发出的</li>
</ul>
<h3 id="2-2-操作系统"><a href="#2-2-操作系统" class="headerlink" title="2.2 操作系统"></a>2.2 操作系统</h3><p><strong>1.进程和线程的区别</strong></p>
<ul>
<li>进程是资源分配与调度的基本单位，线程是CPU调度和分派的基本单位</li>
<li>进程拥有独立地址空间，线程共享所属进程的地址空间</li>
<li>进程是拥有系统资源的一个独立单位，而线程基本上不拥有资源，与其他线程共享本进程的相关资源如内存，I/O，CPU等</li>
<li>进程切换，涉及到当前整个CPU环境的保护环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器内容，并不涉及存储器管理方面的操作。可见进程切换的开销远远大于线程切换的开销</li>
<li>线程之间的通信更加方便，同一进程下的线程共享全局变量等数据。而进程之间的通信需要以进程之间通信（IPC）的方式进行</li>
<li>多线程只要有一个线程崩溃，整个程序就崩溃了，但是多进程如果有一个程序崩溃不会影响到其他进程，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<p><strong>2.操作系统为什么有用户态和内核态，用户级线程和内核级线程如何转换？</strong></p>
<p>拥有用户态和内核态主要是为了限制不同程序的访问能力，防止一些程序访问其他程序的内存数据，所以CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其他程序获取</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这是就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的任务，在切换为用户态并返回系统调用的结果。</p>
<p><strong>如何切换</strong>：</p>
<ul>
<li>系统调用：比如读取命令行输入，本质还是通过中断实现的。</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会想CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ul>
<p><strong>为什么要分内核态和用户态？</strong></p>
<p>答：</p>
<ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源</li>
<li>封装性：用户程序不需要实现更加底层的代码</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度会更加方便</li>
</ul>
<p><strong>3.epoll了解吗？</strong></p>
<p>epoll是Linux内核中为处理大批量文件描述符而做了改进的poll，在Linux下多了复用IO接口select/poll的增强版本，他能显著的提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<p><strong>4.进程有哪些通信方式？</strong></p>
<ul>
<li>管道</li>
<li>共享内存 </li>
<li>信号量</li>
<li>消息队列</li>
<li>套接字</li>
</ul>
<p><strong>5.操作系统中的spin lock和Java中锁的区别</strong></p>
<p><strong>6. 操作系统的分页分段管理？虚拟内存？</strong></p>
<p><strong>分页分段的区别</strong></p>
<ol>
<li><p>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配是以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻。</p>
</li>
<li><p>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个segment（如代码段，数据段，堆栈段），内存空间被动态的分成为长度不同的区域，分配时以段为单位，每段在内存中占连续空间，各段可以不相邻</p>
</li>
<li><p>段页式存储：用户进程先按段划分，段内按页再分，内存划分和分配按页</p>
</li>
</ol>
<p><strong>区别：</strong></p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存获得更大的地址空间；分段的目的就是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间。</li>
<li>大小不同：段的大小不固定，由其所完成的功能所决定；页的大小固定，由系统决定</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）</li>
<li>分段便于信息的保护和共享；分页的共享受到限制</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会有内碎片（一个页填不满）</li>
</ul>
<p><strong>虚拟内存是什么？</strong></p>
<p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射为物理的页；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样对于程序来说，逻辑上似乎有很大的内存空间，但实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<p><strong>如何进行地址空间到物理内存的映射？</strong></p>
<p><strong>内存管理单元（MMU）</strong>管理着逻辑地址和物理地址的转换，其中的页表（page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含有效位（判断是在内存还是磁盘）、访问位（是否被访问）、被修改（内存中是否被修改）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
<p><strong>7.线程同步有哪些方式？为什么要进行线程同步？</strong></p>
<ul>
<li><strong>互斥量Mutex</strong>：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
<li><strong>信号量Semaphore</strong>：信号量是内核对象，它允许同一时刻多个线程访问对象，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源访问，当前可用资源计数就减1，只要当前信号量的可用资源计数大于0，就可以发出信号量，如果为0，则将线程放入一个队列中等待。线程处理完共享资源以后，应当在离开的同时通过<code>ReleaseSemaphore</code>函数，将当前可用资源计数加1。如果信号量的取值只能为0或者1，信号量就变成了互斥量。</li>
<li><strong>事件Event</strong>：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。时间分为手动重置事件和自动重置事件；手动重置事件被设置为激活状态之后会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激活状态。自动重置状态被设置为激活状态之后，会唤醒一个等待中的线程，然后自动恢复为未激活状态。</li>
<li><strong>临界区 Critical Section</strong>：任意时刻只允许一个线程对临界资源进行访问，拥有临界区对象的线程，可以访问该临界资源，其他试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<p>进行线程同步主要是为了对共享资源访问的同步性，避免出现操作冲突。</p>
<h3 id="2-3-数据库"><a href="#2-3-数据库" class="headerlink" title="2.3 数据库"></a>2.3 数据库</h3><p><strong>1.Mysql事务隔离级别有哪些？</strong></p>
<p>读未提交：读取其他事务未提交的数据，可能发生脏读，不可重复读，幻读</p>
<p>读已提交：读取其他事务已提交的数据，可能发生不可重复读，幻读</p>
<p>可重复读：同一个事务多次读取数据结果是一样的，可能发生幻读</p>
<p>可串行化：事务串行执行，这是最安全的，可以避免上述所有问题</p>
<p><strong>2.事务隔离级别的实现？</strong></p>
<p>实现事务隔离级别的方式：</p>
<p>1.一级封锁协议：对应读未提交，指代事务在需要修改的事务上面（就是在发生修改的瞬间）对其加共享锁（其他事务不能更改，但是可以读取，导致“脏读”发生），直到事务结束才释放。事务结束包括提交和回滚</p>
<p>2.二级封锁协议：对应读已提交，指代事务对需要更新的数据加排它锁，防止其他事务读取未提交的数据，避免了脏读。事务在对应读取的数据上加共享锁，读完则释放锁。</p>
<p>3.三级封锁协议：对应可重复读，指代二级封锁协议在读取数据的瞬间必须对其添加共享锁，直到事务结束释放，这样保证了可重复读（其他事物能读取数据，但是不能更新数据）</p>
<p>4.四级封锁协议：三级封锁协议的增强版，实现机制最为简单，直接对事务中所读取或者更改的数据所在的表加表锁，也就是说，其他事务不能读写该表中的任何数据。可以避免上述所有的问题。</p>
<p><strong>3.Mysql有哪些锁，如何加锁？</strong></p>
<p>表级锁和行级锁。</p>
<p><strong>4.数据库的主键索引和普通索引的区别？哪个查询更快？</strong></p>
<p>主键索引只需要查询一次即可，但是普通索引的话可能涉及回表，所以一般来说主键索引速度会更快！</p>
<p>主键索引的叶子节点放置了本行的记录，普通索引的节点存放了主键的id，查询的时候需要做一次回表查询，但是也不一定必须要回表，当查询的字段刚好是索引的字段或者是索引的一部分，就可以不用回表，这也是索引覆盖的原理。</p>
<p><strong>5.索引越多越好吗？索引建多了会有什么问题？对操作有什么影响？</strong></p>
<p>不是，当对表中的数据进行增删改的时候，索引也要动态的维护，这样就降低了数据的维护速度。而且索引需要占物理空间，处理数据表占数据空间之外，每一个索引还需要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会很大。创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增加。</p>
<p><strong>6.聚簇索引和非聚簇索引的区别？</strong></p>
<p><strong>非聚簇索引</strong>：B+Tree的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree的搜索算法搜索索引，如果指定的key存在，则取出对应的data域的值，然后把data域的值为地址读取相应的记录。索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，</p>
<p><strong>聚簇索引</strong>：这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，被称为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。进行索引搜索时，直接找到key所在的节点即可取出数据；而根据辅助索引查找时，则需要取出主键的值，再走一遍主键索引。因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p><strong>7.幻读的概念，幻读和不可重复读的区别？</strong></p>
<p>幻读指的是第一个事务读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中当第一个事务再去读的时候，就会发现多了一些原本不存在的记录。像出现了幻觉一样。</p>
<p>不可重复读是指读的数据第一次和第二次不一样。</p>
<p>幻读和不可重复读的区别：幻读是指事务插入或者删除操作过程中发生的，而不可重复读是指事务的修改动作。</p>
<p><strong>8.说一下MVCC的概念，实现的原理，解决的问题？</strong></p>
<p><strong>MVCC简单来说是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>，主要的作用就是为了让读写不冲突！</p>
<p>MVCC（Multi Version Concurrency Control）多版本并发控制。MVCC并没有简单的使用数据库的行锁，而是使用了行级锁。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p>
<p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。（在操作的时候保存了一个版本号）。存在的特征：每行数据都有一个版本，每次数据更新时都更新该版本号。保存时比较版本号，成功的话，则覆盖原记录；失败则rollback</p>
<p>InnoDB中的实现，有一个创建版本号和一个删除版本号。crud过程中通过比较数据版本号来实现对数据版本的控制。</p>
<p>解决的问题：解决了在可重复读，和读已提交两个隔离级别下读同一行和写同一行的两个事务的并发。</p>
<ul>
<li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li>
<li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）。</li>
</ul>
<p>下面的例子确实好理解：</p>
<blockquote>
<p><strong>举个简单的例子：</strong></p>
<ol>
<li><strong>一个事务A（txnId=100）修改了数据X，使得X=1，并且commit了</strong></li>
<li><strong>另外一个事务B（txnId=101）开始尝试读取X，但是还X=1。但B没有提交。</strong></li>
<li><strong>第三个事务C（txnId=102）修改了数据X，使得X=2。并且提交了</strong></li>
<li><strong>事务B又一次读取了X。这时</strong></li>
</ol>
<ul>
<li><strong>如果事务B是Read Committed。那么就读取X的最新commit的版本，也就是X=2</strong></li>
<li><strong>如果事务B是Repeatable Read。那么读取的就是当前事务（txnId=101）之前X的最新版本，也就是X被txnId=100提交的版本，即X=1。</strong></li>
</ul>
</blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/73078137" target="_blank" rel="noopener">MVCC解决了什么问题</a></p>
<p><strong>9.MySQL使用什么数据结构存储数据？B树与B+树的区别？为什么使用B+而不用B树？</strong></p>
<p>MySQL使用B+树来存储数据。</p>
<p>B数的话，是节点存储数据和索引文件，而B+树的话，节点只存储索引，可以存储更多的索引文件，查找也更快只需要走一遍即可。且所有数据都在叶子节点，且叶子节点内部维护着链表，有利于范围统计。</p>
<p><strong>10.联合索引</strong></p>
<p><strong>11.最左匹配成因</strong></p>
<p>最左匹配的成因是因为如果第一个order by，对于数据来说正序，如果第二个也order by得话，此时数据就乱序了，这也就是使用最左匹配的成因。</p>
<p><strong>12.MySQL主从复制原理？读写分离如何在代码层实现？</strong></p>
<p><strong>13. B+Tree为什么更好？</strong></p>
<ul>
<li>B+树的磁盘读写代价更低，因为B+数的节点中只存储索引不存储数据，可以从存储更多的关键字信息</li>
<li>B+树的查询效率更加稳定。因为B+树的结构问题，所有数据的查询只需要走一趟即可。</li>
<li>B+树更有利于对数据库的扫描。因为B+树的叶子节点之间形成了链表，且有序对于范围查询更方便。</li>
</ul>
<p><strong>14. 按道理说Hash索引也可以实现数据的查询，且速度很快，为什么Mysql不使用Hash索引？</strong></p>
<ul>
<li><p>仅仅能满足”=”，”IN“，不能使用范围查询</p>
</li>
<li><p>无法被用来避免数据的排序操作</p>
</li>
<li><p>不能利用部分索引键查询</p>
</li>
<li><p>不能避免表扫描（有些键会有相同的hash值，找到了一个以后还是要全表扫描找出所有）</p>
</li>
<li><p>遇到大量Hash值相等的时候性能并不一定会比B-Tree高</p>
</li>
</ul>
<p><strong>15. 索引四个问题？</strong></p>
<ul>
<li>为什么要使用索引？因为使用索引可以避免全表扫描提高检索效率。</li>
<li>什么样的信息能成为索引？主键，唯一键等普通键，具有可区别的信息都可以</li>
<li>索引的数据结构？一般采用B+Tree，也有少部分采用Hash索引，bitMap索引，Mysql不显式支持Hash索引</li>
<li>密集索引和稀疏索引的区别？主要在于密集索引的辅助索引中包含主键，也就是密集索引文件中每个搜索码值都对应一个索引值。稀疏索是辅助索引与主键索引一样可以直接找到记录，只为索引码的某些值建立索引。</li>
</ul>
<p>InnoDB的索引和数据放在一起，而MyISAM是索引和数据分开的。</p>
<p><strong>16. 如何定位并优化慢SQL</strong></p>
<ul>
<li>通过慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或者尽量让sql走索引</li>
</ul>
<h4 id="2-3-1锁小结"><a href="#2-3-1锁小结" class="headerlink" title="2.3.1锁小结"></a>2.3.1锁小结</h4><p><strong>1. MyISAM和InnoDB关于锁方面的区别是什么？</strong></p>
<ul>
<li>MyISAM默认使用的是表级锁，不支持行级锁</li>
<li>InnoDB默认使用的是行级锁，也支持表级锁</li>
</ul>
<p><strong>MyISAM适用的场景：</strong></p>
<ul>
<li>频繁执行全表count语句</li>
<li>对数据进行增删改效率不高，查询非常频繁</li>
<li>没有事务</li>
</ul>
<p><strong>InnoDB适合的场景：</strong></p>
<ul>
<li>数据增删改查都很频繁</li>
<li>可靠性要求比较高，要求支持事务</li>
</ul>
<p><strong>数据库锁的分类</strong></p>
<ul>
<li>按照锁的粒度划分：表级锁，行级锁，页级锁</li>
<li>按照锁级别划分：共享锁，排它锁</li>
<li>按加锁的方式划分：自动锁，显式锁</li>
<li>按照操作划分：DML锁，DDL锁</li>
<li>按照使用方式划分：乐观锁、悲观锁</li>
</ul>
<p><strong>2. 数据库的四大特性</strong></p>
<ul>
<li>A：原子性</li>
<li>C：一致性</li>
<li>I：隔离性</li>
<li>D：持久性</li>
</ul>
<p><strong>3. 事务隔离级别以及各级别下的并发访问问题</strong></p>
<ul>
<li>更新丢失：mysql所有的事务隔离级别在数据库层面上均可避免</li>
<li>脏读：READ-COMMITED事务隔离级别以上可以避免</li>
<li>不可重复读：REPEATED-READ事务隔离级别以上可以避免</li>
<li>幻读：SERIALIZABLE事务隔离级别可以避免</li>
</ul>
<p><font color="red">注意：不可重复读和幻读之间的区别在于，不可重复读侧重在修改更新上，而幻读侧重在插入和删除数据上面。</font></p>
<p><strong>4. InnoDB可重复读隔离级别下如何避免幻读</strong></p>
<ul>
<li>表象：快照读（非阻塞读）– 伪MVCC</li>
<li>内在：next-key锁（行锁+gap锁）<ul>
<li>行锁</li>
<li>gap锁</li>
</ul>
</li>
</ul>
<p><strong>对主键索引或者唯一索引会用Gap锁吗</strong></p>
<ul>
<li>如果where条件全部命中，则不会使用gap锁，只会加记录锁</li>
<li>如果where条件部分命中或者全不命中，则会加gap锁</li>
</ul>
<p><font color="red">Gap锁会用在非唯一索引或不走索引的当前读中</font></p>
<p><strong>当前读和快照读：</strong></p>
<ul>
<li>当前读：selece….lock in share mode，select…for update;</li>
<li>当前读：update，delete，insert</li>
<li>快照读：不加锁的非阻塞读，select</li>
</ul>
<p>避免幻读主要是由快照读来实现的，快照读的数据的准确性由快照读的时机来决定的。（时机不好，容易读到老的数据）</p>
<p><strong>5. RC、RR级别下的InnoDB的非阻塞读如何实现</strong></p>
<ul>
<li>数据行中的 DB_TRX_ID、 DB_ROLL_PTR、 DB_ROW_ID字段</li>
<li>undo日志</li>
<li>read view（可读视图）</li>
</ul>
<h3 id="2-4-SQL基本语法"><a href="#2-4-SQL基本语法" class="headerlink" title="2.4 SQL基本语法"></a>2.4 SQL基本语法</h3><p>关键语法：</p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT，SUM，MAX，MIN，AVG</li>
</ul>
<p><strong>GROUP BY</strong></p>
<ul>
<li>满足“SELECT子句中的列名必须为分组列或列函数”</li>
<li>列函数对于group by子句定义的每个组各返回一个结果</li>
</ul>
<p><strong>HAVING</strong></p>
<ul>
<li>通常与GROUP BY子句一起使用</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一SQL中的顺序：where&gt;group by&gt;having</li>
<li>如果SQL语句中group by，可以使用having代替where</li>
</ul>
<h2 id="3-Java基础知识"><a href="#3-Java基础知识" class="headerlink" title="3. Java基础知识"></a>3. Java基础知识</h2><p><strong>1.面向对象的特性，多态如何实现？</strong></p>
<p>封装、多态、继承。多态的特性通过继承来实现。</p>
<p><strong>2.手写单例模式</strong></p>
<p><strong>3.HashMap</strong></p>
<p><strong>4.深拷贝和浅拷贝</strong></p>
<p>浅拷贝拷贝的只是对象的引用。而深拷贝是重新创建了一个对象的副本。</p>
<p><strong>5. 值传递和引用传递</strong></p>
<p><strong>6.死锁</strong></p>
<p>是指两个或者多个并发的进程中，每个进程持有某种资源又等待其他进程释放它们所保持的资源，在未改变这种状态之前都不能向前推进，则称这一组进程产生了死锁（deadLock）</p>
<p><strong>产生死锁的必要条件</strong>：</p>
<ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程占用</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其他进程占用的资源</li>
<li><strong>非抢占</strong>：已经被分配给一个进程的资源不能被强制性抢占，只能由该进程完成任务之后自愿释放</li>
<li><strong>循环等待</strong>：若干进程之间形成了一种头尾相连的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占用的资源。</li>
</ul>
<p><strong>7.线程之间的同步方式</strong></p>
<ul>
<li>互斥量</li>
<li>信号量</li>
<li>事件</li>
<li>临界区</li>
</ul>
<p><strong>8.java基本数据类型和占用的空间大小</strong></p>
<p><strong>9.重载和重写的是什么？</strong></p>
<p><strong>10.ReentrantLock底层实现？</strong></p>
<p><strong>11.手写阻塞队列？生产者消费者？优化方法？</strong></p>
<p>之前就采用wait/nitify/notifyAll，优化的话采用ReentrantLock的Condition类来实现。</p>
<p><strong>12.说一说你最熟悉的设计模式？</strong></p>
<p>单例模式，代理模式，MVC</p>
<p><strong>13.IO多路复用</strong></p>
<p><strong>14.LRU缓存怎么实现的？</strong></p>
<p>主要是利用双向链表来实现的，LRU称为最近最少使用算法，主要的实现是每访问一次就将此元素移动到链表末尾。每次取出都移除第一个元素，以保证存储的都是热点数据。</p>
<p><strong>15.注解是什么，底层如何实现的？</strong></p>
<p><strong>16.如何保证HashMap是安全的，CurrentHashMap的原理如何加锁的？</strong></p>
<p><strong>17.LinkedHashMap和HashMap的区别？</strong></p>
<p>内部维持着双向链表。</p>
<p><strong>18.互斥锁和同步锁的区别？</strong></p>
<p>互斥是通过竞争对资源的使用，彼此之间不知道对方的存在，执行顺序是一个乱序。</p>
<p>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方的存在，执行顺序往往是有序的。（同步就是信号量的意思）</p>
<p><strong>19.乐观锁和互斥锁的区别？</strong></p>
<p>乐观锁没有加锁，而互斥锁是已经加了锁。互斥锁类似于悲观锁。</p>
<p><strong>20.Java synchronized的类锁和对象锁，哪些是对象锁，那些是类锁？</strong></p>
<p>区别在于一个锁的是当前类，一个锁的是当前对象。</p>
<p>对象锁的话一般是锁代码块。而类锁的话是锁方法</p>
<p><strong>21.了解bitmap的解析吗</strong></p>
<p><strong>22. Java中的泛型，类型擦除，如果说Java的泛型是伪泛型，为什么不直接使用Obect代替？</strong></p>
<p>*<em>23. *</em></p>
<h2 id="4-Redis知识"><a href="#4-Redis知识" class="headerlink" title="4. Redis知识"></a>4. Redis知识</h2><p><strong>1.redis常用数据类型以及底层？Sorted Set的查找插入删除操作的时间复杂度？zset的大小限制？</strong></p>
<p>常用数据类型：String，Hash，List，Set，Sorted Set</p>
<p>String底层就是简单的k-v键值对。Hash底层就是field-(k-v键值对)，List底层就是链表，Set底层类似于Hash。value全为null的数据结构，Sorted Set底层使用了 ziplist，skipList，dict等数据结构</p>
<p><strong>2.redis持久化方式，有什么区别？如果AOF文件过大怎么办？</strong></p>
<p>RDB持久化，快照的方式来实现的在这个时候获取存储在内存里面的数据在某个时间点的副本。默认RDB</p>
<p>AOF文件追加的方式，文件追加就是追加当前执行的命令，然后恢复的时候服务器执行一遍命令即可。</p>
<p>AOF文件过大可以使用AOF重写机制。服务器通过读取数据库当前键值对来实现的，程序无须对现有AOF文件进行任意读入、分析或者写入操作。</p>
<p><strong>3.redis的有序列表怎么实现的？跳表有什么优势？与二叉树相比的话？</strong></p>
<p><strong>4.redis的过期策略？</strong></p>
<p>定期删除和惰性删除</p>
<ul>
<li><p>定期删除：每隔100ms抽取部分过期键删除</p>
</li>
<li><p>惰性删除：是用到的时候看有没有过期，过期了就删除</p>
</li>
</ul>
<p><strong>5.redis内存淘汰机制？</strong></p>
<p><strong>6.redis的mget与pipeline的区别？</strong></p>
<h2 id="5-Spring-SringBoot-SpringCloud"><a href="#5-Spring-SringBoot-SpringCloud" class="headerlink" title="5. Spring+SringBoot+SpringCloud"></a>5. Spring+SringBoot+SpringCloud</h2><p><strong>1.说说SpringCloud的注册中心？</strong></p>
<p><strong>2.负载均衡策略，Ribbon用到的是那种？</strong></p>
<p>轮询</p>
<p><strong>3.运行中注册中心如果有一个实例挂掉了会出现什么情况？</strong></p>
<p><strong>4.服务熔断和服务降级</strong></p>
<p><strong>5.服务中心怎么保证高可用？怎么保证一致性？一致性算法？</strong></p>
<p><strong>6.Spring Bean的生命周期？</strong></p>
<p><strong>7.SpringBoot的启动流程？</strong></p>
<p><strong>8.Spring AOP的实现原理？</strong></p>
<h2 id="6-JVM知识"><a href="#6-JVM知识" class="headerlink" title="6. JVM知识"></a>6. JVM知识</h2><p><strong>1.GC</strong></p>
<p><strong>2.类加载过程</strong></p>
<p>类加载过程主要分为五步：</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
</ul>
<p><strong>3.垃圾回收的方法</strong></p>
<ul>
<li>标记-清除</li>
<li>标记-整理</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ul>
<p><strong>4.类加载器</strong></p>
<p>常见的有启动类加载器Bootstrap ClassLoader，扩展类加载器Extension ClassLoader ，程序应用加载器Application ClassLoader</p>
<p><strong>5.JVM内存模型，各种变量存储的位置问题，垃圾收集器。</strong></p>
<p><strong>6.JVM如何判断对象可被回收？哪些可以作为GC roots</strong></p>
<h2 id="7-Linux知识"><a href="#7-Linux知识" class="headerlink" title="7. Linux知识"></a>7. Linux知识</h2><p><strong>1.Linux查看文件的第N行？</strong></p>
<p>vim file +n</p>
<p><strong>2.Linux文件系统原理？</strong></p>
<p><strong>3.如果一个文件100行，每行一个单词，怎么统计单词个数？</strong></p>
<p><strong>4.中断是什么，Linux的中断命令？</strong></p>
<p>中断是指CPU在执行程序的过程中，出现了某些突发事件急需处理，CPU暂停当前程序的执行，转去处理突发事件，处理完后又返回原程序被中断的地方继续执行。</p>
<p>Linux的中断命令：<code>ctrl+c</code></p>
<h2 id="8-项目"><a href="#8-项目" class="headerlink" title="8. 项目"></a>8. 项目</h2><p><strong>1.分布式锁？分布式锁除了redis还有其他实现吗？数据库和zookeeper实现？如何实现的说说？</strong></p>
<h2 id="9-SQL编写"><a href="#9-SQL编写" class="headerlink" title="9. SQL编写"></a>9. SQL编写</h2><p><strong>1.写一个SQL查询所有平均成绩大于60的同学？如果不用where student.id=score.id会出现什么？</strong></p>
<p><strong>2.写sql 学生成绩教师三个表、 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</strong></p>
<p><strong>3.写sql 找出语文成绩及格平均成绩不及格的学生姓名语文成绩</strong></p>
<p><code>select student,avg() from student stu join score sco where stu.id=sco.id</code></p>
<p><strong>4.手写sql语句，分组查询</strong></p>
<h2 id="10-智力题"><a href="#10-智力题" class="headerlink" title="10. 智力题"></a>10. 智力题</h2><p><strong>1. 有8个物体，其中有一个物体质量较大，如何两次称出它？</strong></p>
<p>8个物体分为A/B/C三组，A有3个，B有3个，C有两个，先AB称</p>
<ul>
<li>A倾斜的话，表名重物在A，此时取出两个即可知道重的</li>
<li>B等同A情况</li>
<li>如果ab一样不倾斜，表明在C中，此时一对一，可得出</li>
</ul>
<h2 id="11-常见算法题"><a href="#11-常见算法题" class="headerlink" title="11. 常见算法题"></a>11. 常见算法题</h2><p>LeetCode 001. Two Sum<br>LeetCode 015. 3Sum (可能会问 LeetCode 18. 4Sum 思路)<br>LeetCode 020. Valid Parentheses<br>LeetCode 021. Merge Two Sorted Lists<br>LeetCode 025. Reverse Nodes in k-Group<br>LeetCode 053. Maximum Subarray<br>LeetCode 066. Plus One<br>LeetCode 098. Validate Binary Search Tree<br>LeetCode 110. Balanced Binary Tree<br>LeetCode 134. Gas Station<br>LeetCode 136. Single Number<br>LeetCode 137. Single Number II<br>LeetCode 146. LRU Cache（变形题：带有过期时间的 LRU 缓存）<br>LeetCode 206. Reverse Linked List<br>LeetCode 215. Kth Largest Element in an Array<br>LeetCode 232. Implement Queue using Stacks<br>LeetCode 328. Odd Even Linked List<br>LeetCode 415. Add Strings<br>LeetCode 470：rand7() rand10()<br>LeetCode 496. Next Greater Element I（时间复杂度O(n)）<br>LeetCode 716. Max Stack（两个栈实现最大栈，要求 pop，push，get_max 都为O(1)）<br>LeetCode 860. Lemonade Change<br>LeetCode 862. Shortest Subarray with Sum at Least K<br>LeetCode 876. Middle of the Linked List<br>LeetCode 946. Validate Stack Sequences</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
